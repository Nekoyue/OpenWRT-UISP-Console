--- a/.gitignore
+++ b/.gitignore
@@ -132,3 +132,4 @@ all.config
 
 # Kdevelop4
 *.kdev4
+uImage
--- a/arch/arm/mach-alpine/Makefile
+++ b/arch/arm/mach-alpine/Makefile
@@ -1,2 +1,7 @@
+KBUILD_CFLAGS_KERNEL += -DAL_DEV_ID_ALPINE_V1=0 \
+                        -DAL_DEV_ID_ALPINE_V2=1 \
+                        -DAL_DEV_ID=AL_DEV_ID_ALPINE_V1 \
+                        -DCONFIG_GIC500_ARE=0
+
 obj-y				+= alpine_machine.o
 obj-$(CONFIG_SMP)		+= platsmp.o alpine_cpu_pm.o
--- a/arch/arm64/include/asm/checksum.h
+++ b/arch/arm64/include/asm/checksum.h
@@ -47,6 +47,9 @@ static inline __sum16 ip_fast_csum(const
 }
 #define ip_fast_csum ip_fast_csum
 
+extern unsigned int do_csum(const unsigned char *buff, int len);
+#define do_csum do_csum
+
 #include <asm-generic/checksum.h>
 
 #endif	/* __ASM_CHECKSUM_H */
--- a/arch/arm64/include/asm/io.h
+++ b/arch/arm64/include/asm/io.h
@@ -181,6 +181,7 @@ extern void __memset_io(volatile void __
 extern void __iomem *__ioremap(phys_addr_t phys_addr, size_t size, pgprot_t prot);
 extern void __iounmap(volatile void __iomem *addr);
 extern void __iomem *ioremap_cache(phys_addr_t phys_addr, size_t size);
+extern int pci_ioremap_io(unsigned int offset, phys_addr_t phys_addr);
 
 #define ioremap(addr, size)		__ioremap((addr), (size), __pgprot(PROT_DEVICE_nGnRE))
 #define ioremap_nocache(addr, size)	__ioremap((addr), (size), __pgprot(PROT_DEVICE_nGnRE))
--- a/arch/arm64/lib/Makefile
+++ b/arch/arm64/lib/Makefile
@@ -3,7 +3,7 @@ lib-y		:= clear_user.o delay.o copy_from
 		   copy_to_user.o copy_in_user.o copy_page.o		\
 		   clear_page.o memchr.o memcpy.o memmove.o memset.o	\
 		   memcmp.o strcmp.o strncmp.o strlen.o strnlen.o	\
-		   strchr.o strrchr.o tishift.o
+		   strchr.o strrchr.o tishift.o csum.o
 
 # Tell the compiler to treat all general purpose registers (with the
 # exception of the IP registers, which are already handled by the caller
--- a/arch/arm64/mm/ioremap.c
+++ b/arch/arm64/mm/ioremap.c
@@ -104,6 +104,18 @@ void __iomem *ioremap_cache(phys_addr_t
 }
 EXPORT_SYMBOL(ioremap_cache);
 
+#ifdef CONFIG_PCI
+int pci_ioremap_io(unsigned int offset, phys_addr_t phys_addr)
+{
+	BUG_ON(offset + SZ_64K > IO_SPACE_LIMIT);
+	return ioremap_page_range((unsigned long)PCI_IOBASE + offset,
+				  (unsigned long)PCI_IOBASE + offset + SZ_64K,
+				  phys_addr,
+				  __pgprot(PROT_DEVICE_nGnRE));
+}
+EXPORT_SYMBOL_GPL(pci_ioremap_io);
+#endif
+
 /*
  * Must be called after early_fixmap_init
  */
--- a/block/blk-core.c
+++ b/block/blk-core.c
@@ -2173,8 +2173,19 @@ static inline bool should_fail_request(s
 static inline bool bio_check_ro(struct bio *bio, struct hd_struct *part)
 {
 	const int op = bio_op(bio);
-
-	if (part->policy && op_is_write(op)) {
+	/**
+	 * @note
+	 * ubnt-hal/unifi-hal sets the block device as read-only by default and
+	 * unlocks some partitions only, which leads to policy violation as
+	 * part X is remapped on part 0. A bio layer from v4.1 doesn't have this
+	 *
+	 * Don't check ro flag for part 0 - apply this check on partitions only.
+	 *
+	 * This won't affect userspace in any way. Also this function returns
+	 * false every time anyway as the older lvm-tools doesn't work when
+	 * the policy is enforced.
+	 */
+	if (part->partno && part->policy && op_is_write(op)) {
 		char b[BDEVNAME_SIZE];
 
 		if (op_is_flush(bio->bi_opf) && !bio_sectors(bio))
--- a/block/genhd.c
+++ b/block/genhd.c
@@ -45,6 +45,172 @@ static void disk_add_events(struct gendi
 static void disk_del_events(struct gendisk *disk);
 static void disk_release_events(struct gendisk *disk);
 
+static LIST_HEAD(disk_hook_list);
+static DEFINE_MUTEX(disk_hook_lock);
+
+struct disk_event_hook {
+	gendisk_callback cb;
+	void *priv;
+};
+
+struct disk_hook_entry {
+	struct disk_event_hook hooks[DISK_EVENT_COUNT];
+	struct list_head list;
+};
+
+static void gendisk_event_hook_call(struct gendisk *disk, unsigned disk_event)
+{
+	struct disk_part_iter piter;
+	struct disk_hook_entry *entry;
+	struct hd_struct *part;
+
+	if (get_capacity(disk) == 0) {
+		return;
+	}
+
+	mutex_lock(&disk_hook_lock);
+	disk_part_iter_init(&piter, disk, DISK_PITER_INCL_PART0);
+	while ((part = disk_part_iter_next(&piter))) {
+		list_for_each_entry (entry, &disk_hook_list, list) {
+			if (entry->hooks[disk_event].cb) {
+				entry->hooks[disk_event].cb(disk, part,
+							    entry->hooks[disk_event].priv);
+				break;
+			}
+		}
+	}
+	disk_part_iter_exit(&piter);
+	mutex_unlock(&disk_hook_lock);
+}
+
+void gendisk_callback_for_each(gendisk_callback cb, void *priv)
+{
+	struct gendisk *disk = NULL;
+	struct class_dev_iter iter;
+	struct device *dev;
+	struct disk_part_iter piter;
+	struct hd_struct *part;
+
+	if(NULL == cb) {
+		WARN(1, "%s : cb can't be null\n", __func__);
+		return;
+	}
+
+	class_dev_iter_init(&iter, &block_class, NULL, &disk_type);
+	while ((dev = class_dev_iter_next(&iter))) {
+		disk = dev_to_disk(dev);
+
+		if (get_capacity(disk) == 0)
+			continue;
+
+		disk_part_iter_init(&piter, disk, DISK_PITER_INCL_PART0);
+		while ((part = disk_part_iter_next(&piter))) {
+			cb(disk, part, priv);
+		}
+		disk_part_iter_exit(&piter);
+	}
+	class_dev_iter_exit(&iter);
+}
+EXPORT_SYMBOL(gendisk_callback_for_each);
+
+int gendisk_event_hook_reg(gendisk_callback cb, void *priv, unsigned disk_event)
+{
+	struct disk_hook_entry *entry;
+
+	if(NULL == cb) {
+		WARN(1, "%s : cb can't be null\n", __func__);
+		return -EINVAL;
+	}
+
+
+	if (disk_event >= DISK_EVENT_COUNT) {
+		WARN(1, "%s : unknowm disk event\n", __func__);
+		return -EINVAL;
+	}
+
+	mutex_lock(&disk_hook_lock);
+	list_for_each_entry (entry, &disk_hook_list, list) {
+		if (entry->hooks[disk_event].cb == cb) {
+			/* Update private */
+			entry->hooks[disk_event].priv = priv;
+			mutex_unlock(&disk_hook_lock);
+			return 0;
+		}
+	}
+
+	/* Add new hook */
+	entry = kzalloc(sizeof(*entry), GFP_KERNEL);
+	if (NULL == entry) {
+		mutex_unlock(&disk_hook_lock);
+		return -ENOMEM;
+	}
+
+	INIT_LIST_HEAD(&entry->list);
+	list_add_tail(&entry->list, &disk_hook_list);
+	entry->hooks[disk_event].cb = cb;
+	entry->hooks[disk_event].priv = priv;
+	mutex_unlock(&disk_hook_lock);
+	return 0;
+}
+EXPORT_SYMBOL(gendisk_event_hook_reg);
+
+void gendisk_event_hook_unreg(gendisk_callback cb, unsigned disk_event)
+{
+	struct disk_hook_entry *entry, *entry_temp;
+
+	if(NULL == cb) {
+		WARN(1, "%s : cb can't be null\n", __func__);
+		return;
+	}
+
+	if (disk_event >= DISK_EVENT_COUNT) {
+		WARN(1, "%s : unknowm disk event\n", __func__);
+		return;
+	}
+
+	mutex_lock(&disk_hook_lock);
+	list_for_each_entry_safe (entry, entry_temp, &disk_hook_list, list) {
+		if (entry->hooks[disk_event].cb == cb) {
+			list_del(&entry->list);
+			kfree(entry);
+			goto found;
+		}
+	}
+	printk("%s: event hook has not been found.\n", __func__);
+found:
+	mutex_unlock(&disk_hook_lock);
+}
+EXPORT_SYMBOL(gendisk_event_hook_unreg);
+
+void ubnt_set_disk_ro(struct gendisk *disk, int flag)
+{
+	if (NULL == disk) {
+		WARN(1, "%s : disk can't be null\n", __func__);
+		return;
+	}
+
+	disk->ubnt_readonly = flag;
+	set_disk_ro(disk, flag);
+}
+EXPORT_SYMBOL(ubnt_set_disk_ro);
+
+void ubnt_set_part_ro(struct gendisk *disk, int partno, int flag)
+{
+	struct hd_struct *part = disk_get_part(disk, partno);
+
+	if (NULL == part) {
+		WARN(1, "%s : part can't be null\n", __func__);
+		return;
+	}
+
+	part->ubnt_readonly = flag;
+	part->policy = flag;
+	disk_put_part(part);
+
+	return;
+}
+EXPORT_SYMBOL(ubnt_set_part_ro);
+
 void part_inc_in_flight(struct request_queue *q, struct hd_struct *part, int rw)
 {
 	if (q->mq_ops)
@@ -731,6 +897,8 @@ static void __device_add_disk(struct dev
 	WARN_ON_ONCE(!blk_get_queue(disk->queue));
 
 	disk_add_events(disk);
+
+	gendisk_event_hook_call(disk, DISK_EVENT_ADD);
 	blk_integrity_add(disk);
 }
 
@@ -1080,6 +1248,7 @@ static int __init genhd_device_init(void
 	bdev_map = kobj_map_init(base_probe, &block_class_lock);
 	blk_dev_init();
 
+	INIT_LIST_HEAD(&disk_hook_list);
 	register_blkdev(BLOCK_EXT_MAJOR, "blkext");
 
 	/* create top-level block dir */
@@ -1552,15 +1721,21 @@ static void set_disk_ro_uevent(struct ge
 
 void set_device_ro(struct block_device *bdev, int flag)
 {
-	bdev->bd_part->policy = flag;
+	struct hd_struct *part = bdev->bd_part;
+
+	if(part->ubnt_readonly) {
+		flag = part->ubnt_readonly;
+	}
+	part->policy = flag;
 }
 
 EXPORT_SYMBOL(set_device_ro);
 
-void set_disk_ro(struct gendisk *disk, int flag)
+void set_disk_ro(struct gendisk *disk, int flag_in)
 {
 	struct disk_part_iter piter;
 	struct hd_struct *part;
+	int flag = (disk->ubnt_readonly) ? disk->ubnt_readonly : flag_in;
 
 	if (disk->part0.policy != flag) {
 		set_disk_ro_uevent(disk, flag);
@@ -1569,7 +1744,7 @@ void set_disk_ro(struct gendisk *disk, i
 
 	disk_part_iter_init(&piter, disk, DISK_PITER_INCL_EMPTY);
 	while ((part = disk_part_iter_next(&piter)))
-		part->policy = flag;
+		part->policy = (part->ubnt_readonly) ? part->ubnt_readonly : flag_in;
 	disk_part_iter_exit(&piter);
 }
 
@@ -1689,6 +1864,7 @@ void disk_block_events(struct gendisk *d
 
 	mutex_unlock(&ev->block_mutex);
 }
+EXPORT_SYMBOL(disk_block_events);
 
 static void __disk_unblock_events(struct gendisk *disk, bool check_now)
 {
@@ -1730,6 +1906,7 @@ void disk_unblock_events(struct gendisk
 	if (disk->ev)
 		__disk_unblock_events(disk, false);
 }
+EXPORT_SYMBOL(disk_unblock_events);
 
 /**
  * disk_flush_events - schedule immediate event checking and flushing
--- a/drivers/ata/Kconfig
+++ b/drivers/ata/Kconfig
@@ -193,6 +193,15 @@ config AHCI_MVEBU
 
 	  If unsure, say N.
 
+config AHCI_ALPINE
+	bool "Annapurna labs Alpine AHCI SATA support"
+	depends on ARCH_ALPINE
+	help
+	  This option enables support for the Alpine SoC's
+	  onboard AHCI SATA.
+
+	  If unsure, say N.
+
 config AHCI_OCTEON
 	tristate "Cavium Octeon Soc Serial ATA"
 	depends on SATA_AHCI_PLATFORM && CAVIUM_OCTEON_SOC
--- a/drivers/ata/Makefile
+++ b/drivers/ata/Makefile
@@ -27,6 +27,10 @@ obj-$(CONFIG_AHCI_TEGRA)	+= ahci_tegra.o
 obj-$(CONFIG_AHCI_XGENE)	+= ahci_xgene.o libahci.o libahci_platform.o
 obj-$(CONFIG_AHCI_QORIQ)	+= ahci_qoriq.o libahci.o libahci_platform.o
 
+ifdef CONFIG_ARCH_ALPINE
+include $(srctree)/drivers/soc/alpine/alpine_hal.mk
+endif
+
 # SFF w/ custom DMA
 obj-$(CONFIG_PDC_ADMA)		+= pdc_adma.o
 obj-$(CONFIG_PATA_ARASAN_CF)	+= pata_arasan_cf.o
--- a/drivers/ata/ahci.c
+++ b/drivers/ata/ahci.c
@@ -42,6 +42,8 @@
 #include <linux/device.h>
 #include <linux/dmi.h>
 #include <linux/gfp.h>
+#include <linux/gpio.h>
+#include <linux/of_gpio.h>
 #include <linux/msi.h>
 #include <scsi/scsi_host.h>
 #include <scsi/scsi_cmnd.h>
@@ -49,6 +51,10 @@
 #include <linux/ahci-remap.h>
 #include <linux/io-64-nonatomic-lo-hi.h>
 #include "ahci.h"
+#ifdef CONFIG_ARCH_ALPINE
+#include "al_hal_iofic.h"
+#include "al_hal_iofic_regs.h"
+#endif
 
 #define DRV_NAME	"ahci"
 #define DRV_VERSION	"3.0"
@@ -72,6 +78,7 @@ enum board_ids {
 	board_ahci_yes_fbs,
 
 	/* board IDs for specific chipsets in alphabetical order */
+	board_ahci_alpine,
 	board_ahci_avn,
 	board_ahci_mcp65,
 	board_ahci_mcp77,
@@ -105,6 +112,8 @@ static void ahci_mcp89_apple_enable(stru
 static bool is_mcp89_apple(struct pci_dev *pdev);
 static int ahci_p5wdh_hardreset(struct ata_link *link, unsigned int *class,
 				unsigned long deadline);
+static int ahci_al_hardreset(struct ata_link *link, unsigned int *class,
+				 unsigned long deadline);
 #ifdef CONFIG_PM
 static int ahci_pci_device_runtime_suspend(struct device *dev);
 static int ahci_pci_device_runtime_resume(struct device *dev);
@@ -184,6 +193,13 @@ static const struct ata_port_info ahci_p
 		.port_ops	= &ahci_ops,
 	},
 	/* by chipsets */
+	[board_ahci_alpine] = {
+		AHCI_HFLAGS	(AHCI_HFLAG_NO_PMP | AHCI_HFLAG_AL_MSIX | AHCI_HFLAG_MULTI_MSI),
+		.flags		= AHCI_FLAG_COMMON,
+		.pio_mask	= ATA_PIO4,
+		.udma_mask	= ATA_UDMA6,
+		.port_ops	= &ahci_ops,
+	},
 	[board_ahci_avn] = {
 		.flags		= AHCI_FLAG_COMMON,
 		.pio_mask	= ATA_PIO4,
@@ -433,6 +449,8 @@ static const struct pci_device_id ahci_p
 	{ PCI_VDEVICE(ATI, 0x4394), board_ahci_sb700 }, /* ATI SB700/800 */
 	{ PCI_VDEVICE(ATI, 0x4395), board_ahci_sb700 }, /* ATI SB700/800 */
 
+	/* Annapurna Labs */
+	{ PCI_VDEVICE(ANNAPURNA_LABS, 0x0031), board_ahci_alpine }, /* 0031 */
 	/* AMD */
 	{ PCI_VDEVICE(AMD, 0x7800), board_ahci }, /* AMD Hudson-2 */
 	{ PCI_VDEVICE(AMD, 0x7900), board_ahci }, /* AMD CZ */
@@ -824,7 +842,6 @@ static int ahci_avn_hardreset(struct ata
 	return rc;
 }
 
-
 #ifdef CONFIG_PM
 static void ahci_pci_disable_interrupts(struct ata_host *host)
 {
@@ -887,6 +904,9 @@ static int ahci_pci_device_resume(struct
 	struct ata_host *host = pci_get_drvdata(pdev);
 	int rc;
 
+	if (al_ahci_sss_wa_needed(dev))
+		al_ahci_flr(pdev);
+
 	/* Apple BIOS helpfully mangles the registers on resume */
 	if (is_mcp89_apple(pdev))
 		ahci_mcp89_apple_enable(pdev);
@@ -1435,40 +1455,6 @@ static inline void ahci_gtf_filter_worka
 {}
 #endif
 
-/*
- * On the Acer Aspire Switch Alpha 12, sometimes all SATA ports are detected
- * as DUMMY, or detected but eventually get a "link down" and never get up
- * again. When this happens, CAP.NP may hold a value of 0x00 or 0x01, and the
- * port_map may hold a value of 0x00.
- *
- * Overriding CAP.NP to 0x02 and the port_map to 0x7 will reveal all 3 ports
- * and can significantly reduce the occurrence of the problem.
- *
- * https://bugzilla.kernel.org/show_bug.cgi?id=189471
- */
-static void acer_sa5_271_workaround(struct ahci_host_priv *hpriv,
-				    struct pci_dev *pdev)
-{
-	static const struct dmi_system_id sysids[] = {
-		{
-			.ident = "Acer Switch Alpha 12",
-			.matches = {
-				DMI_MATCH(DMI_SYS_VENDOR, "Acer"),
-				DMI_MATCH(DMI_PRODUCT_NAME, "Switch SA5-271")
-			},
-		},
-		{ }
-	};
-
-	if (dmi_check_system(sysids)) {
-		dev_info(&pdev->dev, "enabling Acer Switch Alpha 12 workaround\n");
-		if ((hpriv->saved_cap & 0xC734FF00) == 0xC734FF00) {
-			hpriv->port_map = 0x7;
-			hpriv->cap = 0xC734FF02;
-		}
-	}
-}
-
 #ifdef CONFIG_ARM64
 /*
  * Due to ERRATA#22536, ThunderX needs to handle HOST_IRQ_STAT differently.
@@ -1561,6 +1547,18 @@ static int ahci_init_msi(struct pci_dev
 	if (hpriv->flags & AHCI_HFLAG_NO_MSI)
 		return -ENODEV;
 
+	if (al_ahci_enabled()) {
+		pr_debug("al pdev->vendor: %d anpa: %d\n", pdev->vendor,
+			 PCI_VENDOR_ID_ANNAPURNA_LABS);
+		if (pdev->vendor == PCI_VENDOR_ID_ANNAPURNA_LABS) {
+			nvec = al_init_msix_interrupts(pdev, n_ports, hpriv);
+			pr_debug("init msix interrupts returned: %d\n", nvec);
+			hpriv->get_irq_vector = ahci_get_irq_vector;
+			if (nvec > 0)
+				return nvec;
+		}
+	}
+
 	/*
 	 * If number of MSIs is less than number of ports then Sharing Last
 	 * Message mode could be enforced. In this case assume that advantage
@@ -1667,6 +1665,9 @@ static int ahci_init_one(struct pci_dev
 	struct ata_host *host;
 	int n_ports, i, rc;
 	int ahci_pci_bar = AHCI_PCI_BAR_STANDARD;
+#ifdef CONFIG_ARCH_ALPINE
+	struct device_node	*np;
+#endif
 
 	VPRINTK("ENTER\n");
 
@@ -1801,6 +1802,62 @@ static int ahci_init_one(struct pci_dev
 
 	ahci_set_em_messages(hpriv, &pi);
 
+#ifdef CONFIG_ARCH_ALPINE
+	for (i = 0; i < AHCI_MAX_PORTS; i++)
+		hpriv->led_gpio[i] = -1;
+
+	np = of_find_compatible_node(NULL, NULL, "annapurna-labs,al-sata-sw-leds");
+	if (np) {
+		int err;
+		struct device_node *child;
+		u32	domain;
+		u32	pci_bus;
+		u32	pci_dev;
+		u32	port;
+
+		for_each_child_of_node(np, child) {
+			err = of_property_read_u32(child, "pci_domain", &domain);
+			if (err)
+				continue;
+			if (domain != pci_domain_nr(pdev->bus))
+				continue;
+
+			err = of_property_read_u32(child, "pci_bus", &pci_bus);
+			if (err)
+				continue;
+			if (pci_bus != pdev->bus->number)
+				continue;
+
+			err = of_property_read_u32(child, "pci_dev", &pci_dev);
+			if (err)
+				continue;
+			if (pci_dev != PCI_SLOT(pdev->devfn))
+				continue;
+
+			err = of_property_read_u32(child, "port", &port);
+			if (err)
+				continue;
+
+			err = of_get_named_gpio(child, "gpios", 0);
+			if (IS_ERR_VALUE(err))
+				continue;
+
+			hpriv->led_gpio[port] = err;
+
+			err = gpio_request(hpriv->led_gpio[port], "sata led gpio");
+			if (err) {
+				dev_err(&pdev->dev, "al ahci gpio_request %d failed: %d\n",
+						hpriv->led_gpio[port], err);
+				continue;
+			}
+			gpio_direction_output(hpriv->led_gpio[port], 0);
+			hpriv->em_msg_type = EM_MSG_TYPE_LED;
+			pi.flags |= ATA_FLAG_EM | ATA_FLAG_SW_ACTIVITY;
+		}
+
+		of_node_put(np);
+	}
+#endif
 	if (ahci_broken_system_poweroff(pdev)) {
 		pi.flags |= ATA_FLAG_NO_POWEROFF_SPINDOWN;
 		dev_info(&pdev->dev,
@@ -1825,10 +1882,6 @@ static int ahci_init_one(struct pci_dev
 			 "online status unreliable, applying workaround\n");
 	}
 
-
-	/* Acer SA5-271 workaround modifies private_data */
-	acer_sa5_271_workaround(hpriv, pdev);
-
 	/* CAP.NP sometimes indicate the index of the last enabled
 	 * port, at other times, that of the last possible port, so
 	 * determining the maximum port number requires looking at
--- a/drivers/ata/ahci.h
+++ b/drivers/ata/ahci.h
@@ -240,6 +240,7 @@ enum {
 						        error-handling stage) */
 	AHCI_HFLAG_NO_DEVSLP		= (1 << 17), /* no device sleep */
 	AHCI_HFLAG_NO_FBS		= (1 << 18), /* no FBS */
+	AHCI_HFLAG_AL_MSIX		= (1 << 19), /* alpine msix */
 
 #ifdef CONFIG_PCI_MSI
 	AHCI_HFLAG_MULTI_MSI		= (1 << 20), /* per-port MSI(-X) */
@@ -380,6 +381,9 @@ struct ahci_host_priv {
 	/* only required for per-port MSI(-X) support */
 	int			(*get_irq_vector)(struct ata_host *host,
 						  int port);
+#ifdef CONFIG_ARCH_ALPINE
+	int			led_gpio[AHCI_MAX_PORTS];
+#endif
 };
 
 extern int ahci_ignore_sss;
@@ -425,6 +429,7 @@ void ahci_start_engine(struct ata_port *
 int ahci_check_ready(struct ata_link *link);
 int ahci_kick_engine(struct ata_port *ap);
 int ahci_port_resume(struct ata_port *ap);
+int ahci_port_suspend(struct ata_port *ap, pm_message_t mesg);
 void ahci_set_em_messages(struct ahci_host_priv *hpriv,
 			  struct ata_port_info *pi);
 int ahci_reset_em(struct ata_host *host);
@@ -432,6 +437,7 @@ void ahci_print_info(struct ata_host *ho
 int ahci_host_activate(struct ata_host *host, struct scsi_host_template *sht);
 void ahci_error_handler(struct ata_port *ap);
 u32 ahci_handle_port_intr(struct ata_host *host, u32 irq_masked);
+void ahci_power_up(struct ata_port *ap);
 
 static inline void __iomem *__ahci_port_base(struct ata_host *host,
 					     unsigned int port_no)
@@ -452,4 +458,9 @@ static inline int ahci_nr_ports(u32 cap)
 	return (cap & 0x1f) + 1;
 }
 
+bool al_ahci_enabled(void);
+int al_init_msix_interrupts(struct pci_dev *pdev, unsigned int n_ports,
+			    struct ahci_host_priv *hpriv);
+void al_ahci_flr(struct pci_dev *pdev);
+bool al_ahci_sss_wa_needed(struct device *dev);
 #endif /* _AHCI_H */
--- a/drivers/ata/libahci.c
+++ b/drivers/ata/libahci.c
@@ -31,7 +31,6 @@
  * http://www.intel.com/technology/serialata/pdf/rev1_1.pdf
  *
  */
-
 #include <linux/kernel.h>
 #include <linux/gfp.h>
 #include <linux/module.h>
@@ -43,11 +42,28 @@
 #include <linux/device.h>
 #include <scsi/scsi_host.h>
 #include <scsi/scsi_cmnd.h>
+#include <linux/gpio.h>
 #include <linux/libata.h>
 #include <linux/pci.h>
 #include "ahci.h"
 #include "libata.h"
 
+#ifdef CONFIG_ARCH_ALPINE
+#include "al_hal_unit_adapter.h"
+#include "al_hal_unit_adapter_regs.h"
+#include "al_hal_iofic.h"
+#include "al_hal_iofic_regs.h"
+#endif
+
+#define al_ahci_iofic_base(base)	((base) + 0x2000)
+#define AL_AHCI_SPEED_AN_TRIES		(16)
+
+struct alpine_host_priv {
+	/* for msix interrupts */
+	unsigned int msix_vecs;
+	struct msix_entry msix_entries[];
+};
+
 static int ahci_skip_host_reset;
 int ahci_ignore_sss;
 EXPORT_SYMBOL_GPL(ahci_ignore_sss);
@@ -91,9 +107,6 @@ static int ahci_hardreset(struct ata_lin
 static void ahci_postreset(struct ata_link *link, unsigned int *class);
 static void ahci_post_internal_cmd(struct ata_queued_cmd *qc);
 static void ahci_dev_config(struct ata_device *dev);
-#ifdef CONFIG_PM
-static int ahci_port_suspend(struct ata_port *ap, pm_message_t mesg);
-#endif
 static ssize_t ahci_activity_show(struct ata_device *dev, char *buf);
 static ssize_t ahci_activity_store(struct ata_device *dev,
 				   enum sw_activity val);
@@ -116,6 +129,13 @@ static ssize_t ahci_show_em_supported(st
 				      struct device_attribute *attr, char *buf);
 static irqreturn_t ahci_single_level_irq_intr(int irq, void *dev_instance);
 
+static int al_sata_link_hardreset(struct ata_link *link,
+				  const unsigned long *timing,
+				  unsigned long deadline);
+bool al_ahci_sss_wa_needed(struct device *dev);
+static void al_ahci_port_start(struct ata_port *ap);
+static void al_ahci_port_stop(struct ata_port *ap);
+
 static DEVICE_ATTR(ahci_host_caps, S_IRUGO, ahci_show_host_caps, NULL);
 static DEVICE_ATTR(ahci_host_cap2, S_IRUGO, ahci_show_host_cap2, NULL);
 static DEVICE_ATTR(ahci_host_version, S_IRUGO, ahci_show_host_version, NULL);
@@ -146,6 +166,11 @@ struct device_attribute *ahci_sdev_attrs
 };
 EXPORT_SYMBOL_GPL(ahci_sdev_attrs);
 
+#ifdef CONFIG_ARCH_ALPINE
+ssize_t al_ahci_transmit_led_message(struct ata_port *ap, u32 state,
+					    ssize_t size);
+#endif
+
 struct ata_port_operations ahci_ops = {
 	.inherits		= &sata_pmp_port_ops,
 
@@ -174,13 +199,19 @@ struct ata_port_operations ahci_ops = {
 	.em_store		= ahci_led_store,
 	.sw_activity_show	= ahci_activity_show,
 	.sw_activity_store	= ahci_activity_store,
+#ifdef CONFIG_ARCH_ALPINE
+	.transmit_led_message	= al_ahci_transmit_led_message,
+#else
 	.transmit_led_message	= ahci_transmit_led_message,
+#endif
 #ifdef CONFIG_PM
 	.port_suspend		= ahci_port_suspend,
 	.port_resume		= ahci_port_resume,
 #endif
 	.port_start		= ahci_port_start,
 	.port_stop		= ahci_port_stop,
+	.al_link_hardreset	= al_sata_link_hardreset,
+	.al_ahci_sss_wa_needed	= al_ahci_sss_wa_needed,
 };
 EXPORT_SYMBOL_GPL(ahci_ops);
 
@@ -419,6 +450,228 @@ static ssize_t ahci_show_em_supported(st
 		       em_ctl & EM_CTL_SGPIO ? "sgpio " : "");
 }
 
+int __read_mostly al_ahci_sss_enabled = 1;
+module_param_named(alpine_sss, al_ahci_sss_enabled, int, 0444);
+MODULE_PARM_DESC(alpine_sss,
+		 "Enabled staggered spinup flag for Alpine SoC(0=disable, 1=enable)");
+
+#ifdef CONFIG_AHCI_ALPINE
+bool al_ahci_enabled(void)
+{
+	return true;
+}
+#else
+bool al_ahci_enabled(void)
+{
+	return false;
+}
+#endif
+EXPORT_SYMBOL_GPL(al_ahci_enabled);
+
+int al_init_msix_interrupts(struct pci_dev *pdev, unsigned int n_ports,
+			    struct ahci_host_priv *hpriv)
+{
+	int i, rc;
+	void __iomem *iofic_base = al_ahci_iofic_base(hpriv->mmio);
+	struct alpine_host_priv *al_data;
+
+	hpriv->plat_data = NULL;
+
+	al_data = kzalloc(sizeof(unsigned int) + n_ports *
+			  sizeof(struct msix_entry), GFP_KERNEL);
+
+	if (!al_data)
+		return -ENOMEM;
+
+	al_data->msix_vecs = n_ports;
+
+	for (i = 0; i < n_ports; i++) {
+		/* entries 0-2 are in group A */
+		al_data->msix_entries[i].entry = 3 + i;
+		al_data->msix_entries[i].vector = 0;
+	}
+
+	rc = pci_enable_msix_exact(pdev, al_data->msix_entries, n_ports);
+
+	if (rc) {
+		dev_info(&pdev->dev,
+			 "failed to enable MSIX, vectors %d rc %d\n",
+			 n_ports, rc);
+		kfree(al_data);
+		return -EPERM;
+	}
+
+	/* we use only group B */
+	al_iofic_config(iofic_base, 1 /*GROUP_B*/,
+			INT_CONTROL_GRP_SET_ON_POSEDGE |
+			INT_CONTROL_GRP_AUTO_CLEAR |
+			INT_CONTROL_GRP_AUTO_MASK |
+			INT_CONTROL_GRP_CLEAR_ON_READ);
+
+	al_iofic_moder_res_config(iofic_base, 1, 15);
+
+	al_iofic_unmask(iofic_base, 1, (1 << n_ports) - 1);
+
+	hpriv->plat_data = al_data;
+
+	return n_ports;
+}
+EXPORT_SYMBOL_GPL(al_init_msix_interrupts);
+
+static void alpine_clean_cause(struct ata_port *ap_this)
+{
+	struct ata_host *host = ap_this->host;
+	struct ahci_host_priv *hpriv = host->private_data;
+	void __iomem *iofic_base = al_ahci_iofic_base(hpriv->mmio);
+
+	/* clean host cause */
+	writel(1 << ap_this->port_no, hpriv->mmio + HOST_IRQ_STAT);
+
+	/* unmask the interrupt in the iofic (auto-masked) */
+	al_iofic_unmask(iofic_base, 1, 1 << ap_this->port_no);
+}
+
+static int al_port_irq(struct ata_host *host, int port)
+{
+	struct ahci_host_priv *hpriv = host->private_data;
+	struct alpine_host_priv *al_priv = hpriv->plat_data;
+
+	return al_priv->msix_entries[port].vector;
+}
+
+static int al_ahci_read_pcie_config(void *handle, int where, uint32_t *val)
+{
+	/* handle is a pointer to the pci_dev */
+	pci_read_config_dword((struct pci_dev *)handle, where, val);
+	return 0;
+}
+
+static int al_ahci_write_pcie_config(void *handle, int where, uint32_t val)
+{
+	/* handle is a pointer to the pci_dev */
+	pci_write_config_dword((struct pci_dev *)handle, where, val);
+	return 0;
+}
+
+static int al_ahci_write_pcie_flr(void *handle)
+{
+	/* handle is a pointer to the pci_dev */
+	__pci_reset_function_locked((struct pci_dev *)handle);
+	udelay(1000);
+	return 0;
+}
+
+void al_ahci_flr(struct pci_dev *pdev)
+{
+	struct al_unit_adapter unit_adapter;
+	int status;
+
+	status = al_unit_adapter_handle_init(&unit_adapter,
+					     AL_UNIT_ADAPTER_TYPE_SATA, 0,
+					     al_ahci_read_pcie_config,
+					     al_ahci_write_pcie_config,
+					     al_ahci_write_pcie_flr,
+					     pdev);
+	if (status) {
+		BUG();
+		return;
+	}
+
+	al_pcie_perform_flr(&unit_adapter);
+}
+EXPORT_SYMBOL_GPL(al_ahci_flr);
+
+bool al_ahci_sss_wa_needed(struct device *dev)
+{
+	struct pci_dev *pdev = to_pci_dev(dev);
+
+	return (al_ahci_enabled() &&
+		pdev->vendor == PCI_VENDOR_ID_ANNAPURNA_LABS) &&
+		al_ahci_sss_enabled;
+}
+EXPORT_SYMBOL_GPL(al_ahci_sss_wa_needed);
+
+static inline int al_sata_phy_reset(struct ata_link *link)
+{
+	int rc;
+	u32 scontrol;
+
+	rc = sata_scr_read(link, SCR_CONTROL, &scontrol);
+
+	if (rc)
+		return rc;
+	/*Speed negotiation is not finished, reset SATA link once again*/
+	scontrol = (scontrol & 0x0f0) | 0x301;
+
+	rc = sata_scr_write_flush(link, SCR_CONTROL, scontrol);
+	if (rc)
+		return rc;
+
+	ata_msleep(link->ap, 1);
+	scontrol = (scontrol & 0x0f0) | 0x300;
+	return sata_scr_write_flush(link, SCR_CONTROL, scontrol);
+}
+
+static int al_sata_link_hardreset(struct ata_link *link,
+				  const unsigned long *timing,
+				  unsigned long deadline)
+{
+	u32 sstatus;
+	int i, rc = 0;
+
+	rc = sata_scr_read(link, SCR_STATUS, &sstatus);
+	if (rc)
+		return rc;
+
+	/*reset to determine link state*/
+	rc = al_sata_phy_reset(link);
+	if (rc)
+		return rc;
+
+	if (!(sstatus & 0xF))
+		goto out;
+
+	ahci_power_up(link->ap);
+
+	for (i = 0; i < AL_AHCI_SPEED_AN_TRIES; i++) {
+		udelay(200);
+		rc = sata_scr_read(link, SCR_STATUS, &sstatus);
+		if (rc)
+			goto out;
+		/*Check if device is present*/
+		if (!(sstatus & 0x3)) {
+			rc = 0;
+			goto out;
+		}
+		/*Check negotiated speed*/
+		if (sstatus & 0xF0)
+			break;
+		ata_dev_warn(&link->device[0],
+			     "WARNING: repeat PHY hardreset for port\n");
+
+		rc = al_sata_phy_reset(link);
+		if (rc)
+			return rc;
+	}
+	if (sstatus & 0x3) {
+		u32 serror;
+
+		rc = sata_link_debounce(link, timing, deadline);
+		if (rc)
+			goto out;
+
+		rc = sata_scr_read(link, SCR_ERROR, &serror);
+		if (!rc)
+			sata_scr_write(link, SCR_ERROR, serror);
+
+		al_ahci_port_start(link->ap);
+		return 0;
+	}
+out:
+	al_ahci_port_stop(link->ap);
+	return rc;
+}
+
 /**
  *	ahci_save_initial_config - Save and fixup initial config values
  *	@dev: target AHCI device
@@ -450,6 +703,16 @@ void ahci_save_initial_config(struct dev
 	 * reset.  Values without are used for driver operation.
 	 */
 	hpriv->saved_cap = cap = readl(mmio + HOST_CAP);
+
+	if (al_ahci_enabled()) {
+		if (al_ahci_sss_wa_needed(dev)) {
+			cap |= HOST_CAP_SSS;
+			hpriv->saved_cap |= HOST_CAP_SSS;
+		} else {
+			pr_warn("Warning: AHCI al_ahci_sss_enabled flag is disabled\n");
+		}
+	}
+
 	hpriv->saved_port_map = port_map = readl(mmio + HOST_PORTS_IMPL);
 
 	/* CAP2 register is only defined for AHCI 1.2 and later */
@@ -739,7 +1002,7 @@ static int ahci_stop_fis_rx(struct ata_p
 	return 0;
 }
 
-static void ahci_power_up(struct ata_port *ap)
+void ahci_power_up(struct ata_port *ap)
 {
 	struct ahci_host_priv *hpriv = ap->host->private_data;
 	void __iomem *port_mmio = ahci_port_base(ap);
@@ -756,6 +1019,7 @@ static void ahci_power_up(struct ata_por
 	/* wake up link */
 	writel(cmd | PORT_CMD_ICC_ACTIVE, port_mmio + PORT_CMD);
 }
+EXPORT_SYMBOL_GPL(ahci_power_up);
 
 static int ahci_set_lpm(struct ata_link *link, enum ata_lpm_policy policy,
 			unsigned int hints)
@@ -830,7 +1094,7 @@ static int ahci_set_lpm(struct ata_link
 	return 0;
 }
 
-#ifdef CONFIG_PM
+#if defined(CONFIG_PM) || defined(CONFIG_ARCH_ALPINE)
 static void ahci_power_down(struct ata_port *ap)
 {
 	struct ahci_host_priv *hpriv = ap->host->private_data;
@@ -971,6 +1235,7 @@ int ahci_reset_controller(struct ata_hos
 }
 EXPORT_SYMBOL_GPL(ahci_reset_controller);
 
+#define LED_DELAY_TIME   100
 static void ahci_sw_activity(struct ata_link *link)
 {
 	struct ata_port *ap = link->ap;
@@ -982,7 +1247,7 @@ static void ahci_sw_activity(struct ata_
 
 	emp->activity++;
 	if (!timer_pending(&emp->timer))
-		mod_timer(&emp->timer, jiffies + msecs_to_jiffies(10));
+		mod_timer(&emp->timer, jiffies + msecs_to_jiffies(LED_DELAY_TIME));
 }
 
 static void ahci_sw_activity_blink(struct timer_list *t)
@@ -1018,12 +1283,13 @@ static void ahci_sw_activity_blink(struc
 
 		/* toggle state */
 		led_message |= (activity_led_state << 16);
-		mod_timer(&emp->timer, jiffies + msecs_to_jiffies(100));
+		mod_timer(&emp->timer, jiffies + msecs_to_jiffies(LED_DELAY_TIME));
 	} else {
 		/* switch to idle */
 		led_message &= ~EM_MSG_LED_VALUE_ACTIVITY;
-		if (emp->blink_policy == BLINK_OFF)
+		if ((ata_phys_link_online(link)) || (emp->blink_policy == BLINK_OFF))
 			led_message |= (1 << 16);
+		mod_timer(&emp->timer, jiffies + msecs_to_jiffies(500));
 	}
 	spin_unlock_irqrestore(ap->lock, flags);
 	ap->ops->transmit_led_message(ap, led_message, 4);
@@ -1038,7 +1304,9 @@ static void ahci_init_sw_activity(struct
 	/* init activity stats, setup timer */
 	emp->saved_activity = emp->activity = 0;
 	emp->link = link;
-	timer_setup(&emp->timer, ahci_sw_activity_blink, 0);
+	emp->blink_policy = BLINK_ON;
+	if (!timer_pending(&emp->timer))
+		timer_setup(&emp->timer, ahci_sw_activity_blink, 0);
 
 	/* check our blink policy and set flag for link if it's enabled */
 	if (emp->blink_policy)
@@ -1060,6 +1328,38 @@ int ahci_reset_em(struct ata_host *host)
 }
 EXPORT_SYMBOL_GPL(ahci_reset_em);
 
+#ifdef CONFIG_ARCH_ALPINE
+ssize_t al_ahci_transmit_led_message(struct ata_port *ap, u32 state,
+					    ssize_t size)
+{
+	struct ahci_host_priv *hpriv = ap->host->private_data;
+	struct ahci_port_priv *pp = ap->private_data;
+	unsigned long flags;
+	int led_val = 0;
+	int pmp;
+	struct ahci_em_priv *emp;
+
+	/* get the slot number from the message */
+	pmp = (state & EM_MSG_LED_PMP_SLOT) >> 8;
+	if (pmp < EM_MAX_SLOTS)
+		emp = &pp->em_priv[pmp];
+	else
+		return -EINVAL;
+
+	if (hpriv->led_gpio[ap->port_no] == -1)
+		return -EINVAL;
+
+	if (state & EM_MSG_LED_VALUE_ON)
+		led_val = 1;
+
+	gpio_set_value(hpriv->led_gpio[ap->port_no], led_val);
+
+	/* save off new led state for port/slot */
+	emp->led_state = state;
+	return size;
+}
+#endif
+
 static ssize_t ahci_transmit_led_message(struct ata_port *ap, u32 state,
 					ssize_t size)
 {
@@ -1915,6 +2215,7 @@ static irqreturn_t ahci_multi_irqs_intr_
 	struct ata_port *ap = dev_instance;
 	void __iomem *port_mmio = ahci_port_base(ap);
 	u32 status;
+	struct ata_host *host = ap->host;
 
 	VPRINTK("ENTER\n");
 
@@ -1927,6 +2228,12 @@ static irqreturn_t ahci_multi_irqs_intr_
 
 	VPRINTK("EXIT\n");
 
+	if (al_ahci_enabled()) {
+		spin_lock(&host->lock);
+		alpine_clean_cause(ap);
+		spin_unlock(&host->lock);
+	}
+
 	return IRQ_HANDLED;
 }
 
@@ -2000,6 +2307,31 @@ static irqreturn_t ahci_single_level_irq
 	return IRQ_RETVAL(rc);
 }
 
+/* 1 on not anapurna, 0 on success, <0 on error */
+static int al_ahci_request_irq(struct ata_host *host, int port)
+{
+	int port_irq;
+	struct ahci_port_priv *pp = host->ports[port]->private_data;
+	struct ahci_host_priv *hpriv = host->private_data;
+
+	if (al_ahci_enabled()) {
+		if (!(hpriv->flags & AHCI_HFLAG_AL_MSIX)) {
+			pr_debug("%s no msix\n", __func__);
+			return 1;
+		}
+		port_irq = al_port_irq(host, port);
+		pr_debug("%s port: %d\n", __func__, port);
+		if (port_irq < 0)
+			return port_irq;
+
+		return devm_request_irq(host->dev, port_irq,
+					ahci_multi_irqs_intr_hard, 0,
+					pp->irq_desc, host->ports[port]);
+	}
+
+	return 1;
+}
+
 unsigned int ahci_qc_issue(struct ata_queued_cmd *qc)
 {
 	struct ata_port *ap = qc->ap;
@@ -2298,6 +2630,21 @@ static void ahci_pmp_detach(struct ata_p
 		writel(pp->intr_mask, port_mmio + PORT_IRQ_MASK);
 }
 
+static void al_ahci_port_start(struct ata_port *ap)
+{
+	ahci_start_port(ap);
+}
+
+static void al_ahci_port_stop(struct ata_port *ap)
+{
+	const pm_message_t dummy = {
+		.event = 1,
+	};
+
+	/* Same as port suspend */
+	ahci_port_suspend(ap, dummy);
+}
+
 int ahci_port_resume(struct ata_port *ap)
 {
 	ahci_rpm_get_port(ap);
@@ -2314,8 +2661,8 @@ int ahci_port_resume(struct ata_port *ap
 }
 EXPORT_SYMBOL_GPL(ahci_port_resume);
 
-#ifdef CONFIG_PM
-static int ahci_port_suspend(struct ata_port *ap, pm_message_t mesg)
+#if defined(CONFIG_PM) || defined(CONFIG_ARCH_ALPINE)
+int ahci_port_suspend(struct ata_port *ap, pm_message_t mesg)
 {
 	const char *emsg = NULL;
 	int rc;
@@ -2331,6 +2678,7 @@ static int ahci_port_suspend(struct ata_
 	ahci_rpm_put_port(ap);
 	return rc;
 }
+EXPORT_SYMBOL_GPL(ahci_port_suspend);
 #endif
 
 static int ahci_port_start(struct ata_port *ap)
@@ -2554,6 +2902,7 @@ static int ahci_host_activate_multi_irqs
 	struct ahci_host_priv *hpriv = host->private_data;
 	int i, rc;
 
+	pr_debug("ahci_host_activate_multi_irqs\n");
 	rc = ata_host_start(host);
 	if (rc)
 		return rc;
@@ -2571,8 +2920,11 @@ static int ahci_host_activate_multi_irqs
 			continue;
 		}
 
-		rc = devm_request_irq(host->dev, irq, ahci_multi_irqs_intr_hard,
-				0, pp->irq_desc, host->ports[i]);
+		rc = al_ahci_request_irq(host, i);
+		pr_debug("al_ahci_request_irq returned: %d\n",rc);
+		if (rc >0)
+			rc = devm_request_irq(host->dev, irq, ahci_multi_irqs_intr_hard,
+					0, dev_driver_string(host->dev), host->ports[i]);
 
 		if (rc)
 			return rc;
--- a/drivers/ata/libata-core.c
+++ b/drivers/ata/libata-core.c
@@ -175,6 +175,10 @@ MODULE_DESCRIPTION("Library module for A
 MODULE_LICENSE("GPL");
 MODULE_VERSION(DRV_VERSION);
 
+int al_ahci_sss_port_number = -1;
+module_param_named(alpine_sss_port_number, al_ahci_sss_port_number, int, 0444);
+MODULE_PARM_DESC(alpine_sss_port_number,
+		 "Enable hardreset for staggered spinup for specific AHCI host (host_number = host number to enable the hardreset (ataXX), -1 = enabled for all ports)");
 
 static bool ata_sstatus_online(u32 sstatus)
 {
@@ -4121,27 +4125,43 @@ int sata_link_hardreset(struct ata_link
 		sata_set_spd(link);
 	}
 
-	/* issue phy wake/reset */
-	if ((rc = sata_scr_read(link, SCR_CONTROL, &scontrol)))
-		goto out;
+	if (link->ap->ops->al_ahci_sss_wa_needed(link->ap->host->dev)) {
+		u32 host_num = link->ap->scsi_host->host_no;
 
-	scontrol = (scontrol & 0x0f0) | 0x301;
+		if (host_num == al_ahci_sss_port_number ||
+		    al_ahci_sss_port_number == -1) {
+			pr_debug("Link reset for AHCI host num %d", host_num);
+			rc = link->ap->ops->al_link_hardreset(link, timing,
+							      deadline);
+			if (rc)
+				goto out;
+		} else {
+			pr_warn("Warning: Link reset was skiped for AHCI host num %d",
+				host_num);
+		}
+	} else {
+		/* issue phy wake/reset */
+		if ((rc = sata_scr_read(link, SCR_CONTROL, &scontrol)))
+			goto out;
 
-	if ((rc = sata_scr_write_flush(link, SCR_CONTROL, scontrol)))
-		goto out;
+		scontrol = (scontrol & 0x0f0) | 0x301;
 
-	/* Couldn't find anything in SATA I/II specs, but AHCI-1.1
-	 * 10.4.2 says at least 1 ms.
-	 */
-	ata_msleep(link->ap, 1);
+		if ((rc = sata_scr_write_flush(link, SCR_CONTROL, scontrol)))
+			goto out;
 
-	/* bring link back */
-	rc = sata_link_resume(link, timing, deadline);
-	if (rc)
-		goto out;
-	/* if link is offline nothing more to do */
-	if (ata_phys_link_offline(link))
-		goto out;
+		/* Couldn't find anything in SATA I/II specs, but AHCI-1.1
+		 * 10.4.2 says at least 1 ms.
+		 */
+		ata_msleep(link->ap, 1);
+
+		/* bring link back */
+		rc = sata_link_resume(link, timing, deadline);
+		if (rc)
+			goto out;
+		/* if link is offline nothing more to do */
+		if (ata_phys_link_offline(link))
+			goto out;
+	}
 
 	/* Link is online.  From this point, -ENODEV too is an error. */
 	if (online)
--- a/drivers/bluetooth/hci_bcsp.c
+++ b/drivers/bluetooth/hci_bcsp.c
@@ -502,7 +502,9 @@ static void bcsp_complete_rx_pkt(struct
 			/* handle re-transmitted packet or
 			 * when packet was missed
 			 */
-			BT_ERR("Out-of-order packet arrived, got %u expected %u",
+			/* EOSN-1367: in case of UDM,UDM PRO this message is harmless.
+			   Change a verbosity of the message from BT_ERR to BT_DBG */
+			BT_DBG("Out-of-order packet arrived, got %u expected %u",
 			       bcsp->rx_skb->data[0] & 0x07, bcsp->rxseq_txack);
 
 			/* do not process out-of-order packet payload */
--- a/drivers/dma/Kconfig
+++ b/drivers/dma/Kconfig
@@ -620,6 +620,14 @@ config ZX_DMA
 	help
 	  Support the DMA engine for ZTE ZX family platform devices.
 
+config AL_SSM_PCIE
+	tristate "AL SSM PCIE support"
+	depends on ARCH_ALPINE
+	default n
+	help
+	  Enable support for AL-SSM PCIE driver.
+	  The driver will drive the SSM unit, collect SSM errors,
+	  and provide enabling SR-IOV functionality.
 
 # driver files
 source "drivers/dma/bestcomm/Kconfig"
@@ -662,4 +670,26 @@ config DMATEST
 config DMA_ENGINE_RAID
 	bool
 
+config AL_DMA
+       tristate "Annapurna Labs DMA support"
+       depends on ARCH_ALPINE
+       select DMA_ENGINE
+       select ASYNC_TX_ENABLE_CHANNEL_SWITCH
+       select DMA_ENGINE_RAID
+       help
+         Enable support for the Annapurna Labs DMA and RAID acceleration
+         engine.
+
+config AL_DMA_STATS
+       bool "Annapurna Labs DMA statistics enabled"
+       depends on AL_DMA
+       help
+         Enable Annapurna Labs DMA and RAID acceleration engine statistics.
+
+config AL_DMA_PCI_IOV
+       bool "Annapurna Labs DMA Virtual Function enabled"
+       depends on AL_DMA
+       help
+         Enable Annapurna Labs DMA Virtual Function.
+
 endif
--- a/drivers/dma/Makefile
+++ b/drivers/dma/Makefile
@@ -73,6 +73,10 @@ obj-$(CONFIG_XGENE_DMA) += xgene-dma.o
 obj-$(CONFIG_ZX_DMA) += zx_dma.o
 obj-$(CONFIG_ST_FDMA) += st_fdma.o
 
+include $(srctree)/drivers/soc/alpine/alpine_hal.mk
+obj-$(CONFIG_AL_SSM_PCIE) += al_ssm_pcie.o
+
+obj-y += al/
 obj-y += mediatek/
 obj-y += qcom/
 obj-y += ti/
--- a/drivers/edac/Kconfig
+++ b/drivers/edac/Kconfig
@@ -460,4 +460,22 @@ config EDAC_TI
 	  Support for error detection and correction on the
           TI SoCs.
 
+config EDAC_ALPINE_L1
+        tristate "Alpine L1 EDAC"
+        depends on ARCH_ALPINE
+        help
+          Support for Alpine chips AL7 L1 cache EDAC
+
+config EDAC_ALPINE_L2
+        tristate "Alpine L2 EDAC"
+        depends on ARCH_ALPINE
+        help
+          Support for Alpine chips AL7 L2 cache EDAC
+
+config EDAC_ALPINE_SYSTEM_FABRIC
+        tristate "Alpine EDAC System Fabric"
+        depends on ARCH_ALPINE
+        help
+          Support for Alpine chips System Fabric EDAC
+
 endif # EDAC
--- a/drivers/edac/Makefile
+++ b/drivers/edac/Makefile
@@ -77,3 +77,7 @@ obj-$(CONFIG_EDAC_ALTERA)		+= altera_eda
 obj-$(CONFIG_EDAC_SYNOPSYS)		+= synopsys_edac.o
 obj-$(CONFIG_EDAC_XGENE)		+= xgene_edac.o
 obj-$(CONFIG_EDAC_TI)			+= ti_edac.o
+include $(srctree)/drivers/soc/alpine/alpine_hal.mk
+obj-$(CONFIG_EDAC_ALPINE_SYSTEM_FABRIC)	+= alpine_system_fabric_edac.o
+obj-$(CONFIG_EDAC_ALPINE_L1)		+= alpine_l1_edac.o
+obj-$(CONFIG_EDAC_ALPINE_L2)		+= alpine_l2_edac.o
--- a/drivers/edac/edac_device.c
+++ b/drivers/edac/edac_device.c
@@ -49,7 +49,7 @@ static void edac_device_dump_device(stru
 
 struct edac_device_ctl_info *edac_device_alloc_ctl_info(
 	unsigned sz_private,
-	char *edac_device_name, unsigned nr_instances,
+	const char *edac_device_name, unsigned nr_instances,
 	char *edac_block_name, unsigned nr_blocks,
 	unsigned offset_value,		/* zero, 1, or other based offset */
 	struct edac_dev_sysfs_block_attribute *attrib_spec, unsigned nr_attrib,
--- a/drivers/edac/edac_device.h
+++ b/drivers/edac/edac_device.h
@@ -240,7 +240,7 @@ struct edac_device_ctl_info {
  */
 extern struct edac_device_ctl_info *edac_device_alloc_ctl_info(
 		unsigned sizeof_private,
-		char *edac_device_name, unsigned nr_instances,
+		const char *edac_device_name, unsigned nr_instances,
 		char *edac_block_name, unsigned nr_blocks,
 		unsigned offset_value,
 		struct edac_dev_sysfs_block_attribute *block_attributes,
--- a/drivers/gpio/Kconfig
+++ b/drivers/gpio/Kconfig
@@ -412,6 +412,11 @@ config GPIO_PL061
 	help
 	  Say yes here to support the PrimeCell PL061 GPIO device
 
+config GPIO_AL_SGPO
+	bool "Annapurna Labs SGPO support"
+	help
+	  Say yes here to support the Annapurna Labs SGPO device
+
 config GPIO_PMIC_EIC_SPRD
 	tristate "Spreadtrum PMIC EIC support"
 	depends on MFD_SC27XX_PMIC || COMPILE_TEST
--- a/drivers/gpio/Makefile
+++ b/drivers/gpio/Makefile
@@ -1,6 +1,10 @@
 # SPDX-License-Identifier: GPL-2.0
 # generic gpio support: platform drivers, dedicated expander chips, etc
 
+KBUILD_CFLAGS_KERNEL += -I$(srctree)/drivers/soc/alpine/HAL/include/pbs \
+                        -I$(srctree)/drivers/soc/alpine/HAL/include/common/ \
+						-I$(srctree)/drivers/soc/alpine/ \
+
 ccflags-$(CONFIG_DEBUG_GPIO)	+= -DDEBUG
 
 obj-$(CONFIG_GPIOLIB)		+= devres.o
@@ -159,3 +163,4 @@ obj-$(CONFIG_GPIO_ZEVIO)	+= gpio-zevio.o
 obj-$(CONFIG_GPIO_ZYNQ)		+= gpio-zynq.o
 obj-$(CONFIG_GPIO_ZX)		+= gpio-zx.o
 obj-$(CONFIG_GPIO_LOONGSON1)	+= gpio-loongson1.o
+obj-$(CONFIG_GPIO_AL_SGPO)     += gpio-alpine-sgpo.o
--- a/drivers/gpio/gpio-pca953x.c
+++ b/drivers/gpio/gpio-pca953x.c
@@ -263,6 +263,23 @@ static int pca953x_read_regs_16(struct p
 	return ret;
 }
 
+static int pca957x_read_regs_16(struct pca953x_chip *chip, int reg, u8 *val)
+{
+	int ret;
+
+	ret = i2c_smbus_read_byte_data(chip->client, reg << 1);
+	if (ret < 0)
+		return ret;
+	val[0] = ret;
+
+	ret = i2c_smbus_read_byte_data(chip->client, (reg << 1) + 1);
+	if (ret < 0)
+		return ret;
+	val[1] = ret;
+
+	return (val[0] << 8) + val[1];
+}
+
 static int pca953x_read_regs_24(struct pca953x_chip *chip, int reg, u8 *val)
 {
 	int bank_shift = fls((chip->gpio_chip.ngpio - 1) / BANK_SZ);
@@ -886,11 +903,13 @@ static int pca953x_probe(struct i2c_clie
 		chip->write_regs = pca953x_write_regs_24;
 		chip->read_regs = pca953x_read_regs_24;
 	} else {
-		if (PCA_CHIP_TYPE(chip->driver_data) == PCA953X_TYPE)
+		if (PCA_CHIP_TYPE(chip->driver_data) == PCA953X_TYPE) {
 			chip->write_regs = pca953x_write_regs_16;
-		else
+			chip->read_regs = pca953x_read_regs_16;
+		} else {
 			chip->write_regs = pca957x_write_regs_16;
-		chip->read_regs = pca953x_read_regs_16;
+			chip->read_regs = pca957x_read_regs_16;
+		}
 	}
 
 	if (PCA_CHIP_TYPE(chip->driver_data) == PCA953X_TYPE)
--- a/drivers/gpio/gpio-pl061.c
+++ b/drivers/gpio/gpio-pl061.c
@@ -23,6 +23,7 @@
 #include <linux/gpio/driver.h>
 #include <linux/device.h>
 #include <linux/amba/bus.h>
+#include <linux/amba/pl061.h>
 #include <linux/slab.h>
 #include <linux/pinctrl/consumer.h>
 #include <linux/pm.h>
@@ -285,13 +286,34 @@ static int pl061_irq_set_wake(struct irq
 static int pl061_probe(struct amba_device *adev, const struct amba_id *id)
 {
 	struct device *dev = &adev->dev;
+	struct pl061_platform_data *pdata = dev_get_platdata(dev);
 	struct pl061 *pl061;
-	int ret, irq;
+	int ret, irq, irq_base = 0;
 
 	pl061 = devm_kzalloc(dev, sizeof(*pl061), GFP_KERNEL);
 	if (pl061 == NULL)
 		return -ENOMEM;
 
+        if (pdata) {
+		pl061->gc.base = pdata->gpio_base;
+		irq_base = pdata->irq_base;
+		if (irq_base <= 0) {
+			dev_err(&adev->dev, "invalid IRQ base in pdata\n");
+			return -ENODEV;
+		}
+	} else if (adev->dev.of_node) {
+		const void *ptr;
+		unsigned int baseidx = -1; /* GPIO dynamic allocation */
+
+		ptr = of_get_property(adev->dev.of_node, "baseidx", NULL);
+		if (ptr)
+			baseidx = be32_to_cpup(ptr);
+		pl061->gc.base = baseidx;
+	} else {
+		pl061->gc.base = -1;
+		irq_base = 0;
+	}
+
 	pl061->base = devm_ioremap_resource(dev, &adev->res);
 	if (IS_ERR(pl061->base))
 		return PTR_ERR(pl061->base);
@@ -302,7 +324,6 @@ static int pl061_probe(struct amba_devic
 		pl061->gc.free = gpiochip_generic_free;
 	}
 
-	pl061->gc.base = -1;
 	pl061->gc.get_direction = pl061_get_direction;
 	pl061->gc.direction_input = pl061_direction_input;
 	pl061->gc.direction_output = pl061_direction_output;
--- a/drivers/hwmon/lm63.c
+++ b/drivers/hwmon/lm63.c
@@ -68,6 +68,7 @@ static const unsigned short normal_i2c[]
 #define LM63_REG_CONVRATE		0x04
 #define LM63_REG_CONFIG2		0xBF
 #define LM63_REG_CONFIG_FAN		0x4A
+#define LM63_REG_CONFIG_FAN_PWM_OUT_POL	0x10
 
 #define LM63_REG_TACH_COUNT_MSB		0x47
 #define LM63_REG_TACH_COUNT_LSB		0x46
@@ -93,6 +94,7 @@ static const unsigned short normal_i2c[]
 #define LM63_REG_REMOTE_LOW_LSB		0x14
 #define LM63_REG_REMOTE_TCRIT		0x19
 #define LM63_REG_REMOTE_TCRIT_HYST	0x21
+#define LM63_REG_REMOTE_DIODE_FILTER	0xBF
 
 #define LM63_REG_ALERT_STATUS		0x02
 #define LM63_REG_ALERT_MASK		0x16
@@ -186,6 +188,8 @@ struct lm63_data {
 	bool lut_temp_highres;
 	bool remote_unsigned; /* true if unsigned remote upper limits */
 	bool trutherm;
+	bool pwm_polarity;
+	char init_pwm[4];
 };
 
 static inline int temp8_from_reg(struct lm63_data *data, int nr)
@@ -389,13 +393,10 @@ static ssize_t show_pwm1(struct device *
 	return sprintf(buf, "%d\n", pwm);
 }
 
-static ssize_t set_pwm1(struct device *dev, struct device_attribute *devattr,
+static ssize_t set_pwm1_index(struct lm63_data *data, int nr,
 			const char *buf, size_t count)
 {
-	struct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);
-	struct lm63_data *data = dev_get_drvdata(dev);
 	struct i2c_client *client = data->client;
-	int nr = attr->index;
 	unsigned long val;
 	int err;
 	u8 reg;
@@ -418,6 +419,14 @@ static ssize_t set_pwm1(struct device *d
 	return count;
 }
 
+static ssize_t set_pwm1(struct device *dev, struct device_attribute *devattr,
+			const char *buf, size_t count)
+{
+	struct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);
+	return set_pwm1_index(dev_get_drvdata(dev), attr->index, buf, count);
+}
+
+
 static ssize_t pwm1_enable_show(struct device *dev,
 				struct device_attribute *dummy, char *buf)
 {
@@ -460,6 +469,33 @@ static ssize_t pwm1_enable_store(struct
 	return count;
 }
 
+static ssize_t show_pwm1_freq(struct device *dev, struct device_attribute *dummy,
+			 char *buf)
+{
+	struct lm63_data *data = lm63_update_device(dev);
+
+	return sprintf(buf, "%d\n", data->pwm1_freq);
+}
+
+static ssize_t set_pwm1_freq(struct device *dev, struct device_attribute *dummy,
+			const char *buf, size_t count)
+{
+	struct lm63_data *data = dev_get_drvdata(dev);
+	struct i2c_client *client = data->client;
+	unsigned long val;
+	int err;
+
+	err = kstrtoul(buf, 10, &val);
+	if (err)
+		return err;
+
+	val = clamp_val(val, 1, 31);
+	mutex_lock(&data->update_lock);
+	i2c_smbus_write_byte_data(client, LM63_REG_PWM_FREQ, val & 0x1f);
+	mutex_unlock(&data->update_lock);
+	return count;
+}
+
 /*
  * There are 8bit registers for both local(temp1) and remote(temp2) sensor.
  * For remote sensor registers temp2_offset has to be considered,
@@ -756,6 +792,8 @@ static SENSOR_DEVICE_ATTR(fan1_min, S_IW
 
 static SENSOR_DEVICE_ATTR(pwm1, S_IWUSR | S_IRUGO, show_pwm1, set_pwm1, 0);
 static DEVICE_ATTR_RW(pwm1_enable);
+static DEVICE_ATTR(pwm1_freq, S_IWUSR | S_IRUGO,
+	show_pwm1_freq, set_pwm1_freq);
 static SENSOR_DEVICE_ATTR(pwm1_auto_point1_pwm, S_IWUSR | S_IRUGO,
 	show_pwm1, set_pwm1, 1);
 static SENSOR_DEVICE_ATTR(pwm1_auto_point1_temp, S_IWUSR | S_IRUGO,
@@ -861,6 +899,7 @@ static DEVICE_ATTR_RW(update_interval);
 static struct attribute *lm63_attributes[] = {
 	&sensor_dev_attr_pwm1.dev_attr.attr,
 	&dev_attr_pwm1_enable.attr,
+	&dev_attr_pwm1_freq.attr,
 	&sensor_dev_attr_pwm1_auto_point1_pwm.dev_attr.attr,
 	&sensor_dev_attr_pwm1_auto_point1_temp.dev_attr.attr,
 	&sensor_dev_attr_pwm1_auto_point1_temp_hyst.dev_attr.attr,
@@ -1029,6 +1068,7 @@ static void lm63_init_client(struct lm63
 	struct i2c_client *client = data->client;
 	struct device *dev = &client->dev;
 	u8 convrate;
+	int temp2_crit;
 
 	data->config = i2c_smbus_read_byte_data(client, LM63_REG_CONFIG1);
 	data->config_fan = i2c_smbus_read_byte_data(client,
@@ -1042,14 +1082,37 @@ static void lm63_init_client(struct lm63
 					  data->config);
 	}
 	/* Tachometer is always enabled on LM64 */
-	if (data->kind == lm64)
+	if (data->kind == lm64) {
 		data->config |= 0x04;
+	} else if (data->kind == lm63) {
+		if (client->dev.of_node) {
+			if (of_property_read_bool(client->dev.of_node, "tachometer-en")) {
+				/*
+					In the configuration register (0x3) of LM63, BIT2: is a alert and tachometer selection
+						1: is open drain as an output
+						0: is high impedance as an input.
+				*/
+				data->config |= 0x04;
+			} else {
+				data->config &= ~0x04;
+			}
+			i2c_smbus_write_byte_data(client, LM63_REG_CONFIG1, data->config);
+		}
+	}
+
+	if (client->dev.of_node) {
+		if (0 == of_property_read_u32(client->dev.of_node, "temp2-crit", &temp2_crit)) {
+			data->config |= 0x02;
+			i2c_smbus_write_byte_data(client, LM63_REG_CONFIG1, data->config);
+			i2c_smbus_write_byte_data(client, LM63_REG_REMOTE_TCRIT, TEMP8_TO_REG(temp2_crit));
+		}
+	}
 
 	/* We may need pwm1_freq before ever updating the client data */
-	data->pwm1_freq = i2c_smbus_read_byte_data(client, LM63_REG_PWM_FREQ);
 	if (data->pwm1_freq == 0)
 		data->pwm1_freq = 1;
 
+	i2c_smbus_write_byte_data(client, LM63_REG_PWM_FREQ, data->pwm1_freq & 0x1f);
 	switch (data->kind) {
 	case lm63:
 	case lm64:
@@ -1087,6 +1150,26 @@ static void lm63_init_client(struct lm63
 			data->remote_unsigned = true;
 	}
 
+	if (data->pwm_polarity) {
+		data->config_fan |= LM63_REG_CONFIG_FAN_PWM_OUT_POL;
+	} else {
+		data->config_fan &= (~LM63_REG_CONFIG_FAN_PWM_OUT_POL);
+	}
+	i2c_smbus_write_byte_data(client, LM63_REG_CONFIG_FAN, data->config_fan);
+
+	if (data->init_pwm[0] != '\0') {
+		set_pwm1_index(data, 0, data->init_pwm, 0);
+	}
+
+	/*
+	 * Set thermal diode filter to Level 1 filtering (bits 2:1)
+	 * 00: Filter Disabled Remote Diode
+	 * 01: Filter Level 1 (minimal filtering, same as 10)
+	 * 10: Filter Level 1 (minimal filtering, same as 01)
+	 * 11: Filter Level 2 (maximum filtering)
+	 */
+	i2c_smbus_write_byte_data(client, LM63_REG_REMOTE_DIODE_FILTER, 0x4);
+
 	/* Show some debug info about the LM63 configuration */
 	if (data->kind == lm63)
 		dev_dbg(dev, "Alert/tach pin configured for %s\n",
@@ -1106,7 +1189,7 @@ static int lm63_probe(struct i2c_client
 	struct device *dev = &client->dev;
 	struct device *hwmon_dev;
 	struct lm63_data *data;
-	int groups = 0;
+	int groups = 0, pwm_polarity, pwm_duty, pwm_freq;
 
 	data = devm_kzalloc(dev, sizeof(struct lm63_data), GFP_KERNEL);
 	if (!data)
@@ -1124,6 +1207,16 @@ static int lm63_probe(struct i2c_client
 	if (data->kind == lm64)
 		data->temp2_offset = 16000;
 
+	data->init_pwm[0] = '\0';
+	if (client->dev.of_node) {
+		if (0 == of_property_read_u32(client->dev.of_node, "pwm-polarity", &pwm_polarity))
+			data->pwm_polarity = pwm_polarity;
+		if (0 == of_property_read_u32(client->dev.of_node, "pwm-duty", &pwm_duty))
+			snprintf(data->init_pwm, sizeof(data->init_pwm), "%u", pwm_duty);
+		if (0 == of_property_read_u32(client->dev.of_node, "pwm-freq", &pwm_freq))
+			data->pwm1_freq = pwm_freq;
+	}
+
 	/* Initialize chip */
 	lm63_init_client(data);
 
--- a/drivers/i2c/i2c-core-base.c
+++ b/drivers/i2c/i2c-core-base.c
@@ -958,6 +958,37 @@ unsigned int i2c_adapter_depth(struct i2
 EXPORT_SYMBOL_GPL(i2c_adapter_depth);
 
 /*
+ * Let users lock/unlock I2C bus through sysfs. When the I2C adapter is
+ * locked all i2c transactions to i2c devices under this adapter will be
+ * blocked unil the lock_control release it.
+ *
+ * Pass [y|1|on] to lock, and [n|0|off] to unlock (case insensitive).
+ */
+static ssize_t lock_control_store(struct device *dev,
+				  struct device_attribute *attr,
+				  const char *buf, size_t count)
+{
+	struct i2c_adapter *i2c_adapter = to_i2c_adapter(dev);
+	bool val;
+
+	if (kstrtobool(buf, &val))
+		return -EINVAL;
+
+	dev_dbg(dev, "Attempt to %s bus %s\n", val ? "lock" : "unlock",
+		i2c_adapter->name);
+	if (val)
+		i2c_lock_bus(i2c_adapter, I2C_LOCK_ROOT_ADAPTER);
+	else
+		i2c_unlock_bus(i2c_adapter, I2C_LOCK_ROOT_ADAPTER);
+	dev_dbg(dev, "Bus %s is %s\n", i2c_adapter->name,
+		val ? "locked" : "unlocked");
+
+	return count;
+}
+
+static DEVICE_ATTR_WO(lock_control);
+
+/*
  * Let users instantiate I2C devices through sysfs. This can be used when
  * platform initialization code doesn't contain the proper data for
  * whatever reason. Also useful for drivers that do device detection and
@@ -1086,6 +1117,7 @@ static struct attribute *i2c_adapter_att
 	&dev_attr_name.attr,
 	&dev_attr_new_device.attr,
 	&dev_attr_delete_device.attr,
+	&dev_attr_lock_control.attr,
 	NULL
 };
 ATTRIBUTE_GROUPS(i2c_adapter);
--- a/drivers/irqchip/Kconfig
+++ b/drivers/irqchip/Kconfig
@@ -346,6 +346,14 @@ config IRQ_UNIPHIER_AIDET
 	help
 	  Support for the UniPhier AIDET (ARM Interrupt Detector).
 
+config ALPINE_IOFIC
+	bool "Alpine Fabric Interrupt Controller"
+	depends on ARCH_ALPINE
+	depends on OF
+	select AL_HAL
+	help
+	  Support the Alpine generic IOFIC
+
 config MESON_IRQ_GPIO
        bool "Meson GPIO Interrupt Multiplexer"
        depends on ARCH_MESON
--- a/drivers/irqchip/Makefile
+++ b/drivers/irqchip/Makefile
@@ -82,6 +82,8 @@ obj-$(CONFIG_ARCH_ASPEED)		+= irq-aspeed
 obj-$(CONFIG_STM32_EXTI) 		+= irq-stm32-exti.o
 obj-$(CONFIG_QCOM_IRQ_COMBINER)		+= qcom-irq-combiner.o
 obj-$(CONFIG_IRQ_UNIPHIER_AIDET)	+= irq-uniphier-aidet.o
+include $(srctree)/drivers/soc/alpine/alpine_hal.mk
+obj-$(CONFIG_ALPINE_IOFIC)		+= irq-alpine-iofic.o
 obj-$(CONFIG_ARCH_SYNQUACER)		+= irq-sni-exiu.o
 obj-$(CONFIG_MESON_IRQ_GPIO)		+= irq-meson-gpio.o
 obj-$(CONFIG_GOLDFISH_PIC) 		+= irq-goldfish-pic.o
--- a/drivers/leds/trigger/Kconfig
+++ b/drivers/leds/trigger/Kconfig
@@ -129,4 +129,11 @@ config LEDS_TRIGGER_NETDEV
 	  This allows LEDs to be controlled by network device activity.
 	  If unsure, say Y.
 
+config LEDS_TRIGGER_EXTERNAL
+	tristate "LED External Trigger"
+	depends on LEDS_TRIGGERS
+	help
+	  This allows LEDs to be controlled by external trigger.
+	  If unsure, say Y.
+
 endif # LEDS_TRIGGERS
--- a/drivers/leds/trigger/Makefile
+++ b/drivers/leds/trigger/Makefile
@@ -13,3 +13,4 @@ obj-$(CONFIG_LEDS_TRIGGER_TRANSIENT)	+=
 obj-$(CONFIG_LEDS_TRIGGER_CAMERA)	+= ledtrig-camera.o
 obj-$(CONFIG_LEDS_TRIGGER_PANIC)	+= ledtrig-panic.o
 obj-$(CONFIG_LEDS_TRIGGER_NETDEV)	+= ledtrig-netdev.o
+obj-$(CONFIG_LEDS_TRIGGER_EXTERNAL)	+= ledtrig-ext.o
--- a/drivers/misc/Kconfig
+++ b/drivers/misc/Kconfig
@@ -485,6 +485,11 @@ config VEXPRESS_SYSCFG
 	  bus. System Configuration interface is one of the possible means
 	  of generating transactions on this bus.
 
+config UBNT_REBOOT_REASON
+	tristate "Record reboot reason driver"
+	---help---
+	  Record the reboot reason via reserved memory
+
 config ASPEED_LPC_CTRL
 	depends on (ARCH_ASPEED || COMPILE_TEST) && REGMAP && MFD_SYSCON
 	tristate "Aspeed ast2400/2500 HOST LPC to BMC bridge control"
--- a/drivers/misc/Makefile
+++ b/drivers/misc/Makefile
@@ -58,3 +58,4 @@ obj-$(CONFIG_ASPEED_LPC_SNOOP)	+= aspeed
 obj-$(CONFIG_PCI_ENDPOINT_TEST)	+= pci_endpoint_test.o
 obj-$(CONFIG_OCXL)		+= ocxl/
 obj-$(CONFIG_MISC_RTSX)		+= cardreader/
+obj-$(CONFIG_UBNT_REBOOT_REASON) += resvmem_reboot.o
--- a/drivers/mtd/devices/m25p80.c
+++ b/drivers/mtd/devices/m25p80.c
@@ -265,6 +265,7 @@ static void m25p_shutdown(struct spi_mem
  * keep them available as module aliases for existing platforms.
  */
 static const struct spi_device_id m25p_ids[] = {
+	{"spi_flash_jedec_detection"},
 	/*
 	 * Allow non-DT platform devices to bind to the "spi-nor" modalias, and
 	 * hack around the fact that the SPI core does not provide uevent
@@ -284,7 +285,7 @@ static const struct spi_device_id m25p_i
 	 */
 	{"at25df321a"},	{"at25df641"},	{"at26df081a"},
 	{"mx25l4005a"},	{"mx25l1606e"},	{"mx25l6405d"},	{"mx25l12805d"},
-	{"mx25l25635e"},{"mx66l51235l"},
+	{"mx25l25635e"},{"mx66l51235l"}, {"mx25u12835f"},
 	{"n25q064"},	{"n25q128a11"},	{"n25q128a13"},	{"n25q512a"},
 	{"s25fl256s1"},	{"s25fl512s"},	{"s25sl12801"},	{"s25fl008k"},
 	{"s25fl064k"},
--- a/drivers/mtd/mtdcore.c
+++ b/drivers/mtd/mtdcore.c
@@ -230,6 +230,17 @@ static ssize_t mtd_numeraseregions_show(
 static DEVICE_ATTR(numeraseregions, S_IRUGO, mtd_numeraseregions_show,
 	NULL);
 
+static ssize_t mtd_jedec_id_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct mtd_info *mtd = dev_get_drvdata(dev);
+
+	return snprintf(buf, PAGE_SIZE, "%06x\n", mtd->jedec_id);
+
+}
+
+static DEVICE_ATTR(jedec_id, S_IRUGO, mtd_jedec_id_show, NULL);
+
 static ssize_t mtd_name_show(struct device *dev,
 		struct device_attribute *attr, char *buf)
 {
@@ -338,6 +349,7 @@ static struct attribute *mtd_attrs[] = {
 	&dev_attr_oobsize.attr,
 	&dev_attr_oobavail.attr,
 	&dev_attr_numeraseregions.attr,
+	&dev_attr_jedec_id.attr,
 	&dev_attr_name.attr,
 	&dev_attr_ecc_strength.attr,
 	&dev_attr_ecc_step_size.attr,
@@ -1833,6 +1845,19 @@ void *mtd_kmalloc_up_to(const struct mtd
 }
 EXPORT_SYMBOL_GPL(mtd_kmalloc_up_to);
 
+void mtd_callback_for_each(mtd_callback cb, void *priv) {
+
+	struct mtd_info *mtd;
+	if(cb) {
+		mutex_lock(&mtd_table_mutex);
+		mtd_for_each_device(mtd) {
+			cb(mtd, priv);
+		}
+		mutex_unlock(&mtd_table_mutex);
+	}
+}
+EXPORT_SYMBOL(mtd_callback_for_each);
+
 #ifdef CONFIG_PROC_FS
 
 /*====================================================================*/
--- a/drivers/mtd/mtdpart.c
+++ b/drivers/mtd/mtdpart.c
@@ -354,6 +354,7 @@ static struct mtd_part *allocate_partiti
 	slave->mtd.oobavail = parent->oobavail;
 	slave->mtd.subpage_sft = parent->subpage_sft;
 	slave->mtd.pairing = parent->pairing;
+	slave->mtd.jedec_id = parent->jedec_id;
 
 	slave->mtd.name = name;
 	slave->mtd.owner = parent->owner;
--- a/drivers/mtd/nand/raw/Kconfig
+++ b/drivers/mtd/nand/raw/Kconfig
@@ -561,4 +561,10 @@ config MTD_NAND_TEGRA
 	  is supported. Extra OOB bytes when using HW ECC are currently
 	  not supported.
 
+config MTD_NAND_AL
+	tristate "NAND support for Annapurna Labs NAND controller"
+	depends on MTD_NAND
+	help
+	  Enable support for NAND Flash chips on Annapurna Labs NAND controllers.
+
 endif # MTD_NAND
--- a/drivers/mtd/nand/raw/Makefile
+++ b/drivers/mtd/nand/raw/Makefile
@@ -58,6 +58,9 @@ obj-$(CONFIG_MTD_NAND_QCOM)		+= qcom_nan
 obj-$(CONFIG_MTD_NAND_MTK)		+= mtk_ecc.o mtk_nand.o
 obj-$(CONFIG_MTD_NAND_TEGRA)		+= tegra_nand.o
 
+include $(srctree)/drivers/soc/alpine/alpine_hal.mk
+obj-$(CONFIG_MTD_NAND_AL)		+= al_nand.o
+
 nand-objs := nand_base.o nand_bbt.o nand_timings.o nand_ids.o
 nand-objs += nand_amd.o
 nand-objs += nand_hynix.o
--- a/drivers/mtd/spi-nor/spi-nor.c
+++ b/drivers/mtd/spi-nor/spi-nor.c
@@ -972,6 +972,12 @@ static int macronix_quad_enable(struct s
  * old entries may be missing 4K flag.
  */
 static const struct flash_info spi_nor_ids[] = {
+	/* spi_flash_jedec_detection --
+	*   using this configuration means the user is counting on this driver
+	*   to perform memory device detection automatically (using jedec
+	*   probe).
+	*/
+	{ "spi_flash_jedec_detection", INFO(0xD373C7, 0, 0, 0, 0) },
 	/* Atmel -- some are (confusingly) marketed as "DataFlash" */
 	{ "at25fs010",  INFO(0x1f6601, 0, 32 * 1024,   4, SECT_4K) },
 	{ "at25fs040",  INFO(0x1f6604, 0, 64 * 1024,   8, SECT_4K) },
@@ -1081,6 +1087,8 @@ static const struct flash_info spi_nor_i
 	{ "mx25l1606e",  INFO(0xc22015, 0, 64 * 1024,  32, SECT_4K) },
 	{ "mx25l3205d",  INFO(0xc22016, 0, 64 * 1024,  64, SECT_4K) },
 	{ "mx25l3255e",  INFO(0xc29e16, 0, 64 * 1024,  64, SECT_4K) },
+	{ "mx25u25635f", INFO(0xc22539, 0, 64 * 1024, 512, SECT_4K) },
+	{ "mx25u12835f", INFO(0xc22538, 0, 64 * 1024, 256, 0) },
 	{ "mx25l6405d",  INFO(0xc22017, 0, 64 * 1024, 128, SECT_4K) },
 	{ "mx25u2033e",  INFO(0xc22532, 0, 64 * 1024,   4, SECT_4K) },
 	{ "mx25u4035",   INFO(0xc22533, 0, 64 * 1024,   8, SECT_4K) },
@@ -1106,6 +1114,7 @@ static const struct flash_info spi_nor_i
 	{ "n25q128a13",  INFO(0x20ba18, 0, 64 * 1024,  256, SECT_4K | SPI_NOR_QUAD_READ) },
 	{ "n25q256a",    INFO(0x20ba19, 0, 64 * 1024,  512, SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ) },
 	{ "n25q256ax1",  INFO(0x20bb19, 0, 64 * 1024,  512, SECT_4K | SPI_NOR_QUAD_READ) },
+	{ "n25q16a",     INFO(0x20bb19, 0, 64 * 1024, 1024, SECT_4K | USE_FSR | SPI_NOR_QUAD_READ) },
 	{ "n25q512a",    INFO(0x20bb20, 0, 64 * 1024, 1024, SECT_4K | USE_FSR | SPI_NOR_QUAD_READ) },
 	{ "n25q512ax3",  INFO(0x20ba20, 0, 64 * 1024, 1024, SECT_4K | USE_FSR | SPI_NOR_QUAD_READ) },
 	{ "n25q00",      INFO(0x20ba21, 0, 64 * 1024, 2048, SECT_4K | USE_FSR | SPI_NOR_QUAD_READ | NO_CHIP_ERASE) },
@@ -2797,6 +2806,23 @@ void spi_nor_restore(struct spi_nor *nor
 }
 EXPORT_SYMBOL_GPL(spi_nor_restore);
 
+/**
+ * spi_nor_read_fact_prot_reg
+ * Read factory OTP area.
+ */
+
+static int spi_nor_read_fact_prot_reg(struct mtd_info *mtd, loff_t from,
+            size_t len, size_t *retlen, u_char *buf)
+{
+	struct spi_nor *nor = mtd_to_spi_nor(mtd);
+	int err;
+
+	err = spi_nor_read_sfdp(nor, from, len, buf);
+	*retlen = err ? 0: len;
+
+    return 0;
+}
+
 int spi_nor_scan(struct spi_nor *nor, const char *name,
 		 const struct spi_nor_hwcaps *hwcaps)
 {
@@ -2871,9 +2897,11 @@ int spi_nor_scan(struct spi_nor *nor, co
 	mtd->writesize = 1;
 	mtd->flags = MTD_CAP_NORFLASH;
 	mtd->size = params.size;
+	mtd->jedec_id = (info->id[0] << 16) | (info->id[1] << 8) | (info->id[2]);
 	mtd->_erase = spi_nor_erase;
 	mtd->_read = spi_nor_read;
 	mtd->_resume = spi_nor_resume;
+	mtd->_read_fact_prot_reg = spi_nor_read_fact_prot_reg;
 
 	/* NOR protection support for STmicro/Micron chips and similar */
 	if (JEDEC_MFR(info) == SNOR_MFR_MICRON ||
--- a/drivers/net/Kconfig
+++ b/drivers/net/Kconfig
@@ -499,6 +499,8 @@ config THUNDERBOLT_NET
 
 source "drivers/net/hyperv/Kconfig"
 
+source "drivers/net/power/Kconfig"
+
 config NETDEVSIM
 	tristate "Simulated networking device"
 	depends on DEBUG_FS
--- a/drivers/net/Makefile
+++ b/drivers/net/Makefile
@@ -72,6 +72,7 @@ obj-$(CONFIG_USB_NET_DRIVERS) += usb/
 
 obj-$(CONFIG_HYPERV_NET) += hyperv/
 obj-$(CONFIG_NTB_NETDEV) += ntb_netdev.o
+obj-$(CONFIG_POE_BCM59111) += power/
 
 obj-$(CONFIG_FUJITSU_ES) += fjes/
 
--- a/drivers/net/ethernet/Kconfig
+++ b/drivers/net/ethernet/Kconfig
@@ -177,6 +177,7 @@ source "drivers/net/ethernet/socionext/K
 source "drivers/net/ethernet/stmicro/Kconfig"
 source "drivers/net/ethernet/sun/Kconfig"
 source "drivers/net/ethernet/synopsys/Kconfig"
+source "drivers/net/ethernet/al/Kconfig"
 source "drivers/net/ethernet/tehuti/Kconfig"
 source "drivers/net/ethernet/ti/Kconfig"
 source "drivers/net/ethernet/toshiba/Kconfig"
--- a/drivers/net/ethernet/Makefile
+++ b/drivers/net/ethernet/Makefile
@@ -95,3 +95,4 @@ obj-$(CONFIG_NET_VENDOR_WIZNET) += wizne
 obj-$(CONFIG_NET_VENDOR_XILINX) += xilinx/
 obj-$(CONFIG_NET_VENDOR_XIRCOM) += xircom/
 obj-$(CONFIG_NET_VENDOR_SYNOPSYS) += synopsys/
+obj-$(CONFIG_NET_AL_ETH) += al/
--- a/drivers/net/phy/Kconfig
+++ b/drivers/net/phy/Kconfig
@@ -26,6 +26,12 @@ config MDIO_BCM_IPROC
 	  This module provides a driver for the MDIO busses found in the
 	  Broadcom iProc SoC's.
 
+config AR8033_DISABLE_EEE
+       bool "Disable 1000BT/100BT EEE advertisement"
+       depends on AT803X_PHY
+       ---help---
+         Disable EEE advertisement for 1000BT/100BT
+
 config MDIO_BCM_UNIMAC
 	tristate "Broadcom UniMAC MDIO bus controller"
 	depends on HAS_IOMEM
@@ -210,6 +216,107 @@ config LED_TRIGGER_PHY
 		for any speed known to the PHY.
 
 
+comment "Switch configuration API + drivers"
+
+config SWCONFIG
+	tristate "Switch configuration API"
+	---help---
+	  Switch configuration API using netlink. This allows
+	  you to configure the VLAN features of certain switches.
+
+config SWCONFIG_UBNT_EXT
+	bool "Switch configuration ubnt extension"
+	depends on SWCONFIG
+	default y
+	---help---
+	  ubnt swconfig extension
+
+config SWCONFIG_UBNT_EXT_SYNC_ARL
+        bool "ubnt extension cache sync with switch chip"
+        depends on SWCONFIG_UBNT_EXT
+        default n
+        ---help---
+          ubnt extension cache sync with switch chip
+
+config SWCONFIG_LEDS
+	bool "Switch LED trigger support"
+	depends on (SWCONFIG && LEDS_TRIGGERS)
+
+config UBNT_ACL
+	bool "Ubiquiti's ACL abstraction for PHY drivers"
+
+config ADM6996_PHY
+	tristate "Driver for ADM6996 switches"
+	select SWCONFIG
+	---help---
+	  Currently supports the ADM6996FC and ADM6996M switches.
+	  Support for FC is very limited.
+
+config AR8216_PHY
+	tristate "Driver for Atheros AR8216 switches"
+	select ETHERNET_PACKET_MANGLE
+	select SWCONFIG
+	select UBNT_ACL
+
+config AR8216_PHY_LEDS
+	bool "Atheros AR8216 switch LED support"
+	depends on (AR8216_PHY && LEDS_CLASS)
+
+source "drivers/net/phy/b53/Kconfig"
+
+config IP17XX_PHY
+	tristate "Driver for IC+ IP17xx switches"
+	select SWCONFIG
+
+config MVSWITCH_PHY
+	tristate "Driver for Marvell 88E6060 switches"
+	select ETHERNET_PACKET_MANGLE
+
+config MVSW61XX_PHY
+	tristate "Driver for Marvell 88E6171/6172 switches"
+	select SWCONFIG
+
+config PSB6970_PHY
+	tristate "Lantiq XWAY Tantos (PSB6970) Ethernet switch"
+	select SWCONFIG
+	select ETHERNET_PACKET_MANGLE
+
+config RTL8306_PHY
+	tristate "Driver for Realtek RTL8306S switches"
+	select SWCONFIG
+
+config RTL8366_SMI
+	tristate "Driver for the RTL8366 SMI interface"
+	depends on GPIOLIB
+	---help---
+	  This module implements the SMI interface protocol which is used
+	  by some RTL8366 ethernet switch devices via the generic GPIO API.
+
+if RTL8366_SMI
+
+config RTL8366_SMI_DEBUG_FS
+	bool "RTL8366 SMI interface debugfs support"
+        depends on DEBUG_FS
+        default n
+
+config RTL8366S_PHY
+	tristate "Driver for the Realtek RTL8366S switch"
+	select SWCONFIG
+
+config RTL8366RB_PHY
+	tristate "Driver for the Realtek RTL8366RB switch"
+	select SWCONFIG
+
+config RTL8367_PHY
+	tristate "Driver for the Realtek RTL8367R/M switches"
+	select SWCONFIG
+
+config RTL8367B_PHY
+	tristate "Driver fot the Realtek RTL8367R-VB switch"
+	select SWCONFIG
+
+endif # RTL8366_SMI
+
 comment "MII PHY device drivers"
 
 config SFP
@@ -218,6 +325,12 @@ config SFP
 	depends on HWMON || HWMON=n
 	select MDIO_I2C
 
+config AT8033_SEL_1P8
+	bool "RGMII voltage level setup"
+	depends on AT803X_PHY
+	---help---
+	  Enable 1V8 voltage level for RGMII
+
 config AMD_PHY
 	tristate "AMD PHYs"
 	---help---
@@ -437,6 +550,17 @@ config XILINX_GMII2RGMII
 	  the Reduced Gigabit Media Independent Interface(RGMII) between
 	  Ethernet physical media devices and the Gigabit Ethernet controller.
 
+config RTL83XX_API
+	bool "RTL83XX ASIC drivers for RTL83xx family"
+	---help---
+	  This module contains ASIC driver for RTL83xx family.
+
+config RTL8370_PHY
+	bool "Driver for the Realtek RTL8370MB switch"
+	select SWCONFIG 
+	select RTL83XX_API
+	select UBNT_ACL
+
 endif # PHYLIB
 
 config MICREL_KS8995MA
--- a/drivers/net/phy/Makefile
+++ b/drivers/net/phy/Makefile
@@ -4,6 +4,9 @@
 libphy-y			:= phy.o phy-c45.o phy-core.o phy_device.o
 mdio-bus-y			+= mdio_bus.o mdio_device.o
 
+# CFLAGS
+CFLAGS_rtl8370.o := -I ./drivers/net/phy/rtl83xx_api
+
 ifdef CONFIG_MDIO_DEVICE
 obj-y				+= mdio-boardinfo.o
 endif
@@ -22,6 +25,25 @@ libphy-$(CONFIG_LED_TRIGGER_PHY)	+= phy_
 obj-$(CONFIG_PHYLINK)		+= phylink.o
 obj-$(CONFIG_PHYLIB)		+= libphy.o
 
+obj-$(CONFIG_SWCONFIG)		+= swconfig.o
+obj-$(CONFIG_SWCONFIG_UBNT_EXT) += swconfig_ubnt.o
+obj-$(CONFIG_UBNT_ACL)		+= ubnt_acl.o
+obj-$(CONFIG_ADM6996_PHY)	+= adm6996.o
+obj-$(CONFIG_AR8216_PHY)	+= ar8216.o ar8327.o
+obj-$(CONFIG_RTL83XX_API)	+= rtl83xx_api/
+obj-$(CONFIG_RTL8370_PHY)	+= rtl8370.o
+obj-$(CONFIG_SWCONFIG_B53)	+= b53/
+obj-$(CONFIG_IP17XX_PHY)	+= ip17xx.o
+obj-$(CONFIG_MVSWITCH_PHY)	+= mvswitch.o
+obj-$(CONFIG_MVSW61XX_PHY)	+= mvsw61xx.o
+obj-$(CONFIG_PSB6970_PHY)	+= psb6970.o
+obj-$(CONFIG_RTL8306_PHY)	+= rtl8306.o
+obj-$(CONFIG_RTL8366_SMI)	+= rtl8366_smi.o
+obj-$(CONFIG_RTL8366S_PHY)	+= rtl8366s.o
+obj-$(CONFIG_RTL8366RB_PHY)	+= rtl8366rb.o
+obj-$(CONFIG_RTL8367_PHY)	+= rtl8367.o
+obj-$(CONFIG_RTL8367B_PHY)	+= rtl8367b.o
+
 obj-$(CONFIG_MDIO_BCM_IPROC)	+= mdio-bcm-iproc.o
 obj-$(CONFIG_MDIO_BCM_UNIMAC)	+= mdio-bcm-unimac.o
 obj-$(CONFIG_MDIO_BITBANG)	+= mdio-bitbang.o
--- a/drivers/net/phy/at803x.c
+++ b/drivers/net/phy/at803x.c
@@ -34,7 +34,7 @@
 
 #define AT803X_SMART_SPEED			0x14
 #define AT803X_LED_CONTROL			0x18
-
+#define AT803X_LED_OVERRIDE			0x19
 #define AT803X_DEVICE_ADDR			0x03
 #define AT803X_LOC_MAC_ADDR_0_15_OFFSET		0x804C
 #define AT803X_LOC_MAC_ADDR_16_31_OFFSET	0x804B
@@ -60,6 +60,15 @@
 #define AT803X_DEBUG_REG_5			0x05
 #define AT803X_DEBUG_TX_CLK_DLY_EN		BIT(8)
 
+#ifdef CONFIG_AT8033_SEL_1P8
+#define AT8033_DEBUG_SEL_1P8		0x1F
+#define AT8033_DEBUG_SEL_1P8_EN		BIT(3)
+#endif
+
+#ifdef CONFIG_AR8033_DISABLE_EEE
+#define AT8033_EEE_ADVERT		0x3C
+#endif
+
 #define ATH8030_PHY_ID 0x004dd076
 #define ATH8031_PHY_ID 0x004dd074
 #define ATH8035_PHY_ID 0x004dd072
@@ -269,6 +278,30 @@ static int at803x_config_init(struct phy
 			return ret;
 	}
 
+	/* invert LED_ACT -> LED_ACT = 0 */
+	ret = phy_write(phydev, AT803X_LED_OVERRIDE, 0x0200);
+	if (ret)
+		return ret;
+
+#ifdef CONFIG_AT8033_SEL_1P8
+	ret = phy_write(phydev, AT803X_DEBUG_ADDR,
+			AT8033_DEBUG_SEL_1P8);
+	if (ret)
+		return ret;
+	ret = phy_write(phydev, AT803X_DEBUG_DATA,
+			(phy_read(phydev, AT803X_DEBUG_DATA) | AT8033_DEBUG_SEL_1P8_EN));
+	if (ret)
+		return ret;
+#endif
+#ifdef CONFIG_AR8033_DISABLE_EEE
+	ret = phy_write(phydev, AT803X_MMD_ACCESS_CONTROL, 0x7);
+	ret = phy_write(phydev, AT803X_MMD_ACCESS_CONTROL_DATA, AT8033_EEE_ADVERT);
+	phy_write(phydev, AT803X_MMD_ACCESS_CONTROL, 0x4007);
+	phy_read(phydev, AT803X_MMD_ACCESS_CONTROL_DATA);
+	/* disable 1000BT/100BT EEE by default */
+	phy_write(phydev, AT803X_MMD_ACCESS_CONTROL_DATA, 0x0);
+	phy_read(phydev, AT803X_MMD_ACCESS_CONTROL_DATA);
+#endif
 	return 0;
 }
 
@@ -407,8 +440,10 @@ static struct phy_driver at803x_driver[]
 	.config_init		= at803x_config_init,
 	.set_wol		= at803x_set_wol,
 	.get_wol		= at803x_get_wol,
+#ifndef CONFIG_ARCH_ALPINE
 	.suspend		= at803x_suspend,
 	.resume			= at803x_resume,
+#endif
 	.features		= PHY_GBIT_FEATURES,
 	.flags			= PHY_HAS_INTERRUPT,
 	.aneg_done		= at803x_aneg_done,
--- a/drivers/net/phy/mdio_bus.c
+++ b/drivers/net/phy/mdio_bus.c
@@ -346,6 +346,46 @@ static int mdiobus_create_device(struct
 }
 
 /**
+ * mdiobus_match_name - compares specified string to the device name
+ * @dev: device object to be examined
+ * @data: pointer to string to compare device name to
+ *
+ * Description: matching function used in call to class_find_device() to find
+ * a device with the specified name
+ */
+static int mdiobus_match_name( struct device * dev, const void * data )
+{
+	if (!dev_name(dev)){
+		return 0;
+	}
+
+	return !strncmp(dev_name(dev), (char *)data, strlen((char *)data));
+}
+
+/**
+ * mdiobus_find_by_name - Convenience function for retrieving an mii_bus pointer
+ * by name
+ * @name: name of the bus being searched for
+ */
+struct mii_bus * mdiobus_find_by_name( char * name )
+{
+	struct device * dev = NULL;
+	/*
+	 * Search devices registered for with the mdio_bus_class using the device 
+	 * name as the matching criteria
+	 */
+	dev = class_find_device( &mdio_bus_class, NULL, (void *)name, mdiobus_match_name );
+
+	if(dev) {
+		put_device(dev);
+	}
+
+	/* return the mii_bus pointer or NULL if none was found */
+	return (dev) ? container_of( dev, struct mii_bus, dev ) : NULL;
+}
+EXPORT_SYMBOL( mdiobus_find_by_name );
+
+/**
  * __mdiobus_register - bring up all the PHYs on a given bus and attach them to bus
  * @bus: target mii_bus
  * @owner: module containing bus accessor functions
--- a/drivers/net/phy/phy.c
+++ b/drivers/net/phy/phy.c
@@ -36,6 +36,8 @@
 #include <linux/uaccess.h>
 #include <linux/atomic.h>
 
+#include <net/netlink.h>
+#include <linux/rtnetlink.h>
 #include <asm/irq.h>
 
 #define PHY_STATE_STR(_state)			\
@@ -383,6 +385,73 @@ void phy_ethtool_ksettings_get(struct ph
 }
 EXPORT_SYMBOL(phy_ethtool_ksettings_get);
 
+static int phy_ethtool_gset(struct phy_device *phydev, struct ethtool_cmd *cmd)
+{
+	cmd->supported = phydev->supported;
+
+	cmd->advertising = phydev->advertising;
+	cmd->lp_advertising = phydev->lp_advertising;
+
+	ethtool_cmd_speed_set(cmd, phydev->speed);
+	cmd->duplex = phydev->duplex;
+	if (phydev->interface == PHY_INTERFACE_MODE_MOCA)
+		cmd->port = PORT_BNC;
+	else
+		cmd->port = PORT_MII;
+	cmd->phy_address = phydev->mdio.addr;
+	cmd->transceiver = phy_is_internal(phydev) ?
+		XCVR_INTERNAL : XCVR_EXTERNAL;
+	cmd->autoneg = phydev->autoneg;
+	cmd->eth_tp_mdix_ctrl = phydev->mdix_ctrl;
+	cmd->eth_tp_mdix = phydev->mdix;
+
+	return 0;
+}
+
+int phy_ethtool_ioctl(struct phy_device *phydev, void *useraddr)
+{
+	u32 cmd;
+	int tmp;
+	struct ethtool_cmd ecmd = { ETHTOOL_GSET };
+	struct ethtool_value edata = { ETHTOOL_GLINK };
+
+	if (get_user(cmd, (u32 *) useraddr))
+		return -EFAULT;
+
+	switch (cmd) {
+	case ETHTOOL_GSET:
+		phy_ethtool_gset(phydev, &ecmd);
+		if (copy_to_user(useraddr, &ecmd, sizeof(ecmd)))
+			return -EFAULT;
+		return 0;
+
+	case ETHTOOL_SSET:
+		if (copy_from_user(&ecmd, useraddr, sizeof(ecmd)))
+			return -EFAULT;
+		return phy_ethtool_sset(phydev, &ecmd);
+
+	case ETHTOOL_NWAY_RST:
+		/* if autoneg is off, it's an error */
+		tmp = phy_read(phydev, MII_BMCR);
+		if (tmp & BMCR_ANENABLE) {
+			tmp |= (BMCR_ANRESTART);
+			phy_write(phydev, MII_BMCR, tmp);
+			return 0;
+		}
+		return -EINVAL;
+
+	case ETHTOOL_GLINK:
+		edata.data = (phy_read(phydev,
+				MII_BMSR) & BMSR_LSTATUS) ? 1 : 0;
+		if (copy_to_user(useraddr, &edata, sizeof(edata)))
+			return -EFAULT;
+		return 0;
+	}
+
+	return -EOPNOTSUPP;
+}
+EXPORT_SYMBOL(phy_ethtool_ioctl);
+
 /**
  * phy_mii_ioctl - generic PHY MII ioctl interface
  * @phydev: the phy_device struct
@@ -1330,6 +1399,38 @@ void phy_ethtool_get_wol(struct phy_devi
 }
 EXPORT_SYMBOL(phy_ethtool_get_wol);
 
+void ubnt_net_notify(void *net, int group, int nlmsgtype,
+			void *data, int size)
+{
+	struct sk_buff *skb = NULL;
+	struct nlmsghdr *nlh = NULL;
+	struct phymsg *msg = NULL;
+	struct net *ndev = (struct net *)net;
+	int err = -ENOBUFS;
+
+	skb = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_ATOMIC);
+	if (!skb)
+		goto errout;
+
+	nlh = nlmsg_put(skb, 0, 0, nlmsgtype, sizeof(struct phymsg), 0);
+	if (!nlh) {
+		err = -EMSGSIZE;
+		kfree_skb(skb);
+		goto errout;
+	}
+
+	msg = nlmsg_data(nlh);
+	memcpy(msg, (struct phymsg *)data, sizeof(*msg));
+	nlmsg_end(skb, nlh);
+
+	rtnl_notify(skb, ndev, 0, group, NULL, GFP_ATOMIC);
+	return;
+errout:
+	if (err < 0)
+		rtnl_set_sk_err(ndev, RTNLGRP_NEIGH, err);
+}
+EXPORT_SYMBOL(ubnt_net_notify);
+
 int phy_ethtool_get_link_ksettings(struct net_device *ndev,
 				   struct ethtool_link_ksettings *cmd)
 {
--- a/drivers/net/phy/phy_device.c
+++ b/drivers/net/phy/phy_device.c
@@ -1144,6 +1144,9 @@ void phy_detach(struct phy_device *phyde
 	struct module *ndev_owner = dev->dev.parent->driver->owner;
 	struct mii_bus *bus;
 
+	if (phydev->drv && phydev->drv->detach)
+		phydev->drv->detach(phydev);
+
 	if (phydev->sysfs_links) {
 		sysfs_remove_link(&dev->dev.kobj, "phydev");
 		sysfs_remove_link(&phydev->mdio.dev.kobj, "attached_dev");
@@ -1518,15 +1521,8 @@ int genphy_update_link(struct phy_device
 {
 	int status;
 
-	/* The link state is latched low so that momentary link
-	 * drops can be detected. Do not double-read the status
-	 * in polling mode to detect such short link drops.
-	 */
-	if (!phy_polling_mode(phydev)) {
-		status = phy_read(phydev, MII_BMSR);
-		if (status < 0)
-			return status;
-	}
+	if (phydev->drv && phydev->drv->update_link)
+		return phydev->drv->update_link(phydev);
 
 	/* Read link and autonegotiation status */
 	status = phy_read(phydev, MII_BMSR);
@@ -2008,8 +2004,10 @@ static struct phy_driver genphy_driver =
 			  SUPPORTED_AUI | SUPPORTED_FIBRE |
 			  SUPPORTED_BNC,
 	.aneg_done	= genphy_aneg_done,
+#ifndef CONFIG_ARCH_ALPINE
 	.suspend	= genphy_suspend,
 	.resume		= genphy_resume,
+#endif
 	.set_loopback   = genphy_loopback,
 };
 
--- a/drivers/net/phy/realtek.c
+++ b/drivers/net/phy/realtek.c
@@ -16,6 +16,7 @@
 #include <linux/bitops.h>
 #include <linux/phy.h>
 #include <linux/module.h>
+#include <linux/of_address.h>
 
 #define RTL821x_PHYSR				0x11
 #define RTL821x_PHYSR_DUPLEX			BIT(13)
@@ -162,6 +163,33 @@ static int rtl8211c_config_init(struct p
 	return genphy_config_init(phydev);
 }
 
+static void rtl8211f_led_config(struct phy_device *phydev)
+{
+	struct device_node *node;
+	u32 led_config;
+	struct of_device_id of_realtek_table[] = {
+		{.compatible = "realtek,rtl8211fs"},
+		{ /* end of list */ },
+	};
+
+	node = of_find_matching_node(NULL, of_realtek_table);
+	if (!node) {
+		/* rtl8211fs entry could not be found */
+		return;
+	}
+
+	dev_info(&phydev->mdio.dev, "rtl8211fs entry is found\n");
+	/* configure LED setup accordingly */
+	if (!of_property_read_u32(node, "led-mode", &led_config)) {
+		dev_info(&phydev->mdio.dev, "led-mode: 0x%04x\n", led_config);
+		phy_write(phydev, RTL821x_PAGE_SELECT, 0xd04);
+		phy_write(phydev, 0x10, led_config);
+		phy_write(phydev, RTL821x_PAGE_SELECT, 0x0);
+	}
+
+	return;
+}
+
 static int rtl8211f_config_init(struct phy_device *phydev)
 {
 	int ret;
@@ -171,6 +199,8 @@ static int rtl8211f_config_init(struct p
 	if (ret < 0)
 		return ret;
 
+	rtl8211f_led_config(phydev);
+
 	/* enable TX-delay for rgmii-id and rgmii-txid, otherwise disable it */
 	if (phydev->interface == PHY_INTERFACE_MODE_RGMII_ID ||
 	    phydev->interface == PHY_INTERFACE_MODE_RGMII_TXID)
--- a/drivers/pci/controller/Kconfig
+++ b/drivers/pci/controller/Kconfig
@@ -45,7 +45,6 @@ config PCIE_CADENCE_EP
 	  Say Y here if you want to support the Cadence PCIe  controller in
 	  endpoint mode. This PCIe controller may be embedded into many
 	  different vendors SoCs.
-
 endmenu
 
 config PCIE_XILINX_NWL
@@ -278,5 +277,24 @@ config VMD
 	  To compile this driver as a module, choose M here: the
 	  module will be called vmd.
 
+config PCI_INTERNAL_ALPINE
+	bool "Annapurna Labs Alpine internal PCIe controller"
+	depends on ARCH_ALPINE
+	depends on OF
+
+config PCI_EXTERNAL_ALPINE
+	bool "Annapurna Labs Alpine external PCIe controller"
+	depends on ARCH_ALPINE
+	depends on OF
+	select AL_HAL
+
+config PCI_EXTERNAL_ERR_ALPINE
+	bool "Amazon Alpine external PCIe Errors"
+	depends on ARCH_ALPINE
+	depends on OF
+	select AL_HAL
+	help
+	  Enable support for External PCIe errors for ALPINE SOCs.
+
 source "drivers/pci/controller/dwc/Kconfig"
 endmenu
--- a/drivers/pci/controller/Makefile
+++ b/drivers/pci/controller/Makefile
@@ -29,6 +29,12 @@ obj-$(CONFIG_PCIE_MEDIATEK) += pcie-medi
 obj-$(CONFIG_PCIE_MOBIVEIL) += pcie-mobiveil.o
 obj-$(CONFIG_PCIE_TANGO_SMP8759) += pcie-tango.o
 obj-$(CONFIG_VMD) += vmd.o
+
+include $(srctree)/drivers/soc/alpine/alpine_hal.mk
+obj-$(CONFIG_PCI_INTERNAL_ALPINE) += pci-internal-alpine.o
+obj-$(CONFIG_PCI_EXTERNAL_ALPINE) += pci-external-alpine.o
+obj-$(CONFIG_PCI_EXTERNAL_ERR_ALPINE) += pci-external-err-alpine.o
+
 # pcie-hisi.o quirks are needed even without CONFIG_PCIE_DW
 obj-y				+= dwc/
 
--- a/drivers/pci/pci-pf-stub.c
+++ b/drivers/pci/pci-pf-stub.c
@@ -19,6 +19,8 @@
  */
 static const struct pci_device_id pci_pf_stub_whitelist[] = {
 	{ PCI_VDEVICE(AMAZON, 0x0053) },
+	{ PCI_VDEVICE(ANNAPURNA_LABS, PCI_DEVICE_ID_AL_SSM) },
+	{ PCI_VDEVICE(ANNAPURNA_LABS, PCI_DEVICE_ID_AL_SSM_VF) },
 	/* required last entry */
 	{ 0 }
 };
--- a/drivers/pci/quirks.c
+++ b/drivers/pci/quirks.c
@@ -1818,6 +1818,14 @@ DECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_IN
 DECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_INTEL,	PCI_DEVICE_ID_INTEL_PXH_1,	quirk_pcie_pxh);
 DECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_INTEL,	PCI_DEVICE_ID_INTEL_PXHV,	quirk_pcie_pxh);
 
+static void quirk_pcie_al_bridge(struct pci_dev *dev)
+{
+	dev->no_msi = 1;
+	dev_warn(&dev->dev, "AL PCIe bridge quirk detected, disable MSI(X)\n");
+}
+DECLARE_PCI_FIXUP_CLASS_FINAL(PCI_VENDOR_ID_ANNAPURNA_LABS, 0x0031,
+			      PCI_CLASS_BRIDGE_PCI, 8, quirk_pcie_al_bridge);
+
 /*
  * Some Intel PCI Express chipsets have trouble with downstream device
  * power management.
@@ -2977,6 +2985,13 @@ DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_AT
 			quirk_msi_intx_disable_qca_bug);
 DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_ATTANSIC, 0xe091,
 			quirk_msi_intx_disable_qca_bug);
+
+DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_ANNAPURNA_LABS,
+			PCI_DEVICE_ID_AL_ETH_ADVANCED,
+			quirk_msi_intx_disable_bug);
+DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_ANNAPURNA_LABS,
+			PCI_DEVICE_ID_AL_SSM,
+			quirk_msi_intx_disable_bug);
 #endif /* CONFIG_PCI_MSI */
 
 /*
--- a/drivers/power/reset/Kconfig
+++ b/drivers/power/reset/Kconfig
@@ -215,6 +215,13 @@ config POWER_RESET_RMOBILE
 	help
 	  Reboot support for Renesas R-Mobile and SH-Mobile SoCs.
 
+config POWER_RESET_ALPINE
+	bool "Annapurna Labs Alpine reset driver"
+	depends on ARCH_ALPINE
+	depends on OF
+	help
+	  Reboot support for Annpurna Labs boards.
+
 config POWER_RESET_ZX
 	tristate "ZTE SoCs reset driver"
 	depends on ARCH_ZX || COMPILE_TEST
--- a/drivers/power/reset/Makefile
+++ b/drivers/power/reset/Makefile
@@ -23,6 +23,7 @@ obj-$(CONFIG_POWER_RESET_VEXPRESS) += ve
 obj-$(CONFIG_POWER_RESET_XGENE) += xgene-reboot.o
 obj-$(CONFIG_POWER_RESET_KEYSTONE) += keystone-reset.o
 obj-$(CONFIG_POWER_RESET_SYSCON) += syscon-reboot.o
+obj-$(CONFIG_POWER_RESET_ALPINE) += alpine-reboot.o
 obj-$(CONFIG_POWER_RESET_SYSCON_POWEROFF) += syscon-poweroff.o
 obj-$(CONFIG_POWER_RESET_RMOBILE) += rmobile-reset.o
 obj-$(CONFIG_POWER_RESET_ZX) += zx-reboot.o
--- a/drivers/scsi/Kconfig
+++ b/drivers/scsi/Kconfig
@@ -94,6 +94,13 @@ config BLK_DEV_SD
 	  In this case, do not compile the driver for your SCSI host adapter
 	  (below) as a module either.
 
+config SCSI_UBNT_STATIC_BOOT_DEV
+	bool "UBNT static boot flash name"
+	depends on BLK_DEV_SD
+	---help---
+	  When the SCSI host type is an usb storage and the vendor name is "Generic ",
+	  this option will name a static disk name (/dev/boot) for that device.
+
 config CHR_DEV_ST
 	tristate "SCSI tape support"
 	depends on SCSI
--- a/drivers/scsi/sd.c
+++ b/drivers/scsi/sd.c
@@ -2622,6 +2622,19 @@ sd_read_write_protect_flag(struct scsi_d
 	int res;
 	struct scsi_device *sdp = sdkp->device;
 	struct scsi_mode_data data;
+	/*
+	 * NOTE:
+	 * Disks are read-only on UDM by default, only a few partitions are set as
+	 * read-write. A reapplying of read-only policy on every `.revalidate_disk`
+	 * by `set_disk_ro` after `ubnt-hal` sets its own policy is unwanted as
+	 * `ubnt-hal` enforces only the read-only flag and `set_disk_ro` applies the
+	 * policy flag to the whole disk including all its partitions. That means
+	 * every partition with read-write flag set by `ubnt-hal` is going to be
+	 * overridden with read-only flag by `set_disk_ro` in this function.
+	 *
+	 * More info in PR: https://github.com/ubiquiti/ubios-kernel/pull/24
+	 */
+	int disk_ro = 0; /* UBNT change, originally `get_disk_ro(sdkp->disk);` */
 	int old_wp = sdkp->write_prot;
 
 	set_disk_ro(sdkp->disk, 0);
@@ -3422,10 +3435,23 @@ static int sd_probe(struct device *dev)
 		goto out_put;
 	}
 
-	error = sd_format_disk_name("sd", index, gd->disk_name, DISK_NAME_LEN);
-	if (error) {
-		sdev_printk(KERN_WARNING, sdp, "SCSI disk (sd) name length exceeded.\n");
-		goto out_free_index;
+#ifdef CONFIG_SCSI_UBNT_STATIC_BOOT_DEV
+	/*
+	 * Fix the disk name to "boot" if the host type is an usb storage and
+	 * the vendor name is "Generic " for Genesys GL3224E or "Generic-" for
+	 * Realtek RTS5315 (2nd source).
+	 */
+	if (strcmp(sdp->host->hostt->proc_name, "usb-storage") == 0 &&
+		strncmp(sdp->vendor, "Generic", 7) == 0) {
+		strcpy(gd->disk_name, "boot");
+	} else
+#endif
+	{
+		error = sd_format_disk_name("sd", index, gd->disk_name, DISK_NAME_LEN);
+		if (error) {
+			sdev_printk(KERN_WARNING, sdp, "SCSI disk (sd) name length exceeded.\n");
+			goto out_free_index;
+		}
 	}
 
 	sdkp->device = sdp;
--- a/drivers/soc/Kconfig
+++ b/drivers/soc/Kconfig
@@ -18,5 +18,6 @@ source "drivers/soc/ux500/Kconfig"
 source "drivers/soc/versatile/Kconfig"
 source "drivers/soc/xilinx/Kconfig"
 source "drivers/soc/zte/Kconfig"
+source "drivers/soc/alpine/Kconfig"
 
 endmenu
--- a/drivers/soc/Makefile
+++ b/drivers/soc/Makefile
@@ -25,3 +25,4 @@ obj-$(CONFIG_ARCH_U8500)	+= ux500/
 obj-$(CONFIG_PLAT_VERSATILE)	+= versatile/
 obj-y				+= xilinx/
 obj-$(CONFIG_ARCH_ZX)		+= zte/
+obj-$(CONFIG_AL_HAL)		+= alpine/
--- a/drivers/spi/spi-dw-mmio.c
+++ b/drivers/spi/spi-dw-mmio.c
@@ -119,6 +119,7 @@ static int dw_spi_mmio_probe(struct plat
 	struct resource *mem;
 	int ret;
 	int num_cs;
+	int bus_num;
 
 	dwsmmio = devm_kzalloc(&pdev->dev, sizeof(struct dw_spi_mmio),
 			GFP_KERNEL);
@@ -148,7 +149,12 @@ static int dw_spi_mmio_probe(struct plat
 	if (ret)
 		return ret;
 
-	dws->bus_num = pdev->id;
+	bus_num = pdev->id;
+
+	if (pdev->dev.of_node)
+		of_property_read_u32(pdev->dev.of_node, "bus-num", &bus_num);
+
+	dws->bus_num = bus_num;
 
 	dws->max_freq = clk_get_rate(dwsmmio->clk);
 
--- a/drivers/spi/spi-dw.c
+++ b/drivers/spi/spi-dw.c
@@ -37,7 +37,7 @@ struct chip_data {
 
 	u16 clk_div;		/* baud rate divider */
 	u32 speed_hz;		/* baud rate */
-	void (*cs_control)(u32 command);
+	void (*cs_control)(struct dw_spi *dws, u32 command);
 };
 
 #ifdef CONFIG_DEBUG_FS
@@ -140,9 +140,11 @@ void dw_spi_set_cs(struct spi_device *sp
 
 	/* Chip select logic is inverted from spi_set_cs() */
 	if (chip && chip->cs_control)
-		chip->cs_control(!enable);
+		chip->cs_control(dws, !enable);
 
-	if (!enable)
+	if (enable)
+		dw_writel(dws, DW_SPI_SER, 0);
+	else
 		dw_writel(dws, DW_SPI_SER, BIT(spi->chip_select));
 }
 EXPORT_SYMBOL_GPL(dw_spi_set_cs);
@@ -334,22 +336,6 @@ static int dw_spi_transfer_one(struct sp
 		| (spi->mode << SPI_MODE_OFFSET)
 		| (chip->tmode << SPI_TMOD_OFFSET);
 
-	/*
-	 * Adjust transfer mode if necessary. Requires platform dependent
-	 * chipselect mechanism.
-	 */
-	if (chip->cs_control) {
-		if (dws->rx && dws->tx)
-			chip->tmode = SPI_TMOD_TR;
-		else if (dws->rx)
-			chip->tmode = SPI_TMOD_RO;
-		else
-			chip->tmode = SPI_TMOD_TO;
-
-		cr0 &= ~SPI_TMOD_MASK;
-		cr0 |= (chip->tmode << SPI_TMOD_OFFSET);
-	}
-
 	dw_writel(dws, DW_SPI_CTRL0, cr0);
 
 	/* Check if current transfer is a DMA transaction */
@@ -403,12 +389,32 @@ static void dw_spi_handle_err(struct spi
 	spi_reset_chip(dws);
 }
 
+static int dw_spi_gpio_cs_control_setup(int gpio)
+{
+	int status;
+
+	status = gpio_request(gpio, "dw_spi_gpio_cs_control");
+	if (status < 0)
+		return status;
+
+	status = gpio_direction_output(gpio, 1);
+
+	return status;
+}
+
+static void dw_spi_gpio_cs_control(struct dw_spi *dws, u32 value)
+{
+	/* CS is active low */
+	gpio_set_value(dws->master->cs_gpios[0], value ? 0 : 1);
+}
+
 /* This may be called twice for each spi dev */
 static int dw_spi_setup(struct spi_device *spi)
 {
 	struct dw_spi_chip *chip_info = NULL;
 	struct chip_data *chip;
 	int ret;
+	int status;
 
 	/* Only alloc on first setup */
 	chip = spi_get_ctldata(spi);
@@ -432,6 +438,13 @@ static int dw_spi_setup(struct spi_devic
 
 		chip->poll_mode = chip_info->poll_mode;
 		chip->type = chip_info->type;
+	} else if (spi->master->cs_gpios) {
+		/* DT defined GPIO to control the CS, perform setup and use it */
+		status = dw_spi_gpio_cs_control_setup(spi->master->cs_gpios[0]);
+		if (status) {
+			return status;
+		}
+		chip->cs_control = dw_spi_gpio_cs_control;
 	}
 
 	chip->tmode = SPI_TMOD_TR;
@@ -478,6 +491,32 @@ static void spi_hw_init(struct device *d
 	}
 }
 
+static struct spi_master *g_master;
+
+void
+dw_spi_lock(void)
+{
+	if (!g_master) {
+		pr_err("dw_spi: no bus to lock\n");
+		return;
+	}
+
+	mutex_lock(&g_master->bus_lock_mutex);
+}
+EXPORT_SYMBOL(dw_spi_lock);
+
+void
+dw_spi_unlock(void)
+{
+	if (!g_master) {
+		pr_err("dw_spi: no bus to unlock\n");
+		return;
+	}
+
+	mutex_unlock(&g_master->bus_lock_mutex);
+}
+EXPORT_SYMBOL(dw_spi_unlock);
+
 int dw_spi_add_host(struct device *dev, struct dw_spi *dws)
 {
 	struct spi_controller *master;
@@ -520,6 +559,8 @@ int dw_spi_add_host(struct device *dev,
 	if (dws->set_cs)
 		master->set_cs = dws->set_cs;
 
+	g_master = master;
+
 	/* Basic HW init */
 	spi_hw_init(dev, dws);
 
--- a/drivers/spi/spi-dw.h
+++ b/drivers/spi/spi-dw.h
@@ -243,7 +243,7 @@ static inline void spi_shutdown_chip(str
 struct dw_spi_chip {
 	u8 poll_mode;	/* 1 for controller polling mode */
 	u8 type;	/* SPI/SSP/MicroWire */
-	void (*cs_control)(u32 command);
+	void (*cs_control)(struct dw_spi *dws, u32 command);
 };
 
 extern void dw_spi_set_cs(struct spi_device *spi, bool enable);
--- a/drivers/spi/spidev.c
+++ b/drivers/spi/spidev.c
@@ -677,6 +677,8 @@ static const struct of_device_id spidev_
 	{ .compatible = "lineartechnology,ltc2488" },
 	{ .compatible = "ge,achc" },
 	{ .compatible = "semtech,sx1301" },
+	{ .compatible = "spidev" },
+	{ .compatible = "ui,spiraw" },
 	{},
 };
 MODULE_DEVICE_TABLE(of, spidev_dt_ids);
--- a/drivers/thermal/Kconfig
+++ b/drivers/thermal/Kconfig
@@ -199,6 +199,25 @@ config THERMAL_EMULATION
 	  because userland can easily disable the thermal policy by simply
 	  flooding this sysfs node with low temperature values.
 
+config THERMAL_MMIO
+	bool
+	prompt "mmio based thermal driver"
+	help
+	  This options provides generic thermal driver
+	  that will only use memory mapped reads to
+	  get the temperature.
+	  Any system that allows temperature reading by
+	  single memory map reading, be it register or
+	  shared memory, is a possible candidate to work
+	  with this driver.
+	  This driver is most suitable for cases like these:
+	  * all the setup of thermal HW were done by other
+	    entity (e.g. bootloader)
+	  * the thermal HW management is done by external CPU
+	    (e.g. micro-controller)
+	  * the HW is working out-of-the-box and only report
+	    temperature by simply reading one register
+
 config HISI_THERMAL
 	tristate "Hisilicon thermal driver"
 	depends on ARCH_HISI || COMPILE_TEST
@@ -468,6 +487,24 @@ config GENERIC_ADC_THERMAL
 	  to this driver. This driver reports the temperature by reading ADC
 	  channel and converts it to temperature based on lookup table.
 
+config AL_THERMAL_V2
+	bool "Annapurna Labs V2 thermal sensor driver"
+	depends on ARCH_ALPINE
+	depends on OF
+	select AL_HAL
+	help
+	  Enable this to plug the Annapurna Labs V2 thermal sensor driver into the
+	  Linux thermal framework
+
+config AL_THERMAL_V3
+	bool "Annapurna Labs V3 thermal sensor driver"
+	depends on ARCH_ALPINE
+	depends on OF
+	select AL_HAL
+	help
+	  Enable this to plug the Annapurna Labs V3 thermal sensor driver into the
+	  Linux thermal framework
+
 menu "Qualcomm thermal drivers"
 depends on (ARCH_QCOM && OF) || COMPILE_TEST
 source "drivers/thermal/qcom/Kconfig"
--- a/drivers/thermal/Makefile
+++ b/drivers/thermal/Makefile
@@ -27,6 +27,9 @@ thermal_sys-$(CONFIG_CLOCK_THERMAL)	+= c
 # devfreq cooling
 thermal_sys-$(CONFIG_DEVFREQ_THERMAL) += devfreq_cooling.o
 
+# generic memory mapped thermal driver
+thermal_sys-$(CONFIG_THERMAL_MMIO)	+= thermal_mmio.o
+
 # platform thermal drivers
 obj-y				+= broadcom/
 obj-$(CONFIG_QCOM_SPMI_TEMP_ALARM)	+= qcom-spmi-temp-alarm.o
@@ -61,3 +64,7 @@ obj-$(CONFIG_MTK_THERMAL)	+= mtk_thermal
 obj-$(CONFIG_GENERIC_ADC_THERMAL)	+= thermal-generic-adc.o
 obj-$(CONFIG_ZX2967_THERMAL)	+= zx2967_thermal.o
 obj-$(CONFIG_UNIPHIER_THERMAL)	+= uniphier_thermal.o
+
+include $(srctree)/drivers/soc/alpine/alpine_hal.mk
+obj-$(CONFIG_AL_THERMAL_V2)	+= al_thermal_v2.o
+obj-$(CONFIG_AL_THERMAL_V3)	+= al_thermal_v3.o
--- a/drivers/watchdog/sp805_wdt.c
+++ b/drivers/watchdog/sp805_wdt.c
@@ -29,6 +29,16 @@
 #include <linux/spinlock.h>
 #include <linux/types.h>
 #include <linux/watchdog.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/of_irq.h>
+
+#include <linux/reboot.h>
+#include "watchdog_core.h"
+
+#if defined(CONFIG_UBNT_REBOOT_REASON)
+#include <linux/resvmem_reboot.h>
+#endif
 
 /* default timeout in seconds */
 #define DEFAULT_TIMEOUT		60
@@ -71,6 +81,8 @@ struct sp805_wdt {
 	u64				rate;
 	struct amba_device		*adev;
 	unsigned int			load_val;
+	int				irq;
+	bool				ris_status;
 };
 
 static bool nowayout = WATCHDOG_NOWAYOUT;
@@ -152,6 +164,7 @@ static int wdt_config(struct watchdog_de
 {
 	struct sp805_wdt *wdt = watchdog_get_drvdata(wdd);
 	int ret;
+	bool status;
 
 	if (!ping) {
 
@@ -176,8 +189,15 @@ static int wdt_config(struct watchdog_de
 
 	/* Flush posted writes. */
 	readl_relaxed(wdt->base + WDTLOCK);
+
+	status = wdt->ris_status;
+	wdt->ris_status = false;
 	spin_unlock(&wdt->lock);
 
+	if (status) {
+		pr_crit("Watchdog reboot averted\n");
+	}
+
 	return 0;
 }
 
@@ -227,11 +247,44 @@ static const struct watchdog_ops wdt_ops
 	.restart	= wdt_restart,
 };
 
+static irqreturn_t sp805_wdt_interrupt(int irq, void *dev_id)
+{
+	struct sp805_wdt *wdt = (struct sp805_wdt *)dev_id;
+	bool status = readl_relaxed(wdt->base + WDTRIS) & INT_MASK;
+	if(status && (wdt->ris_status != status)) {
+		pr_crit("Watchdog is about to reboot system\n");
+		wdt->ris_status = true;
+#if defined(CONFIG_UBNT_REBOOT_REASON)
+		resvmem_set_reboot_reason(RESVMEM_REBOOT_WATCHDOG);
+#endif
+	} else if(!status) {
+		pr_crit("Watchdog reboot averted\n");
+		wdt->ris_status = false;
+	}
+
+	return IRQ_HANDLED;
+}
+
+static int sp805_wdt_reboot_notifier(struct notifier_block *nb,
+				    unsigned long code, void *data)
+{
+	struct watchdog_device *wdd;
+	wdd = container_of(nb, struct watchdog_device, reboot_nb);
+	if (code == SYS_DOWN || code == SYS_HALT || code == SYS_POWER_OFF) {
+		if (watchdog_active(wdd)) {
+			if (wdd->ops->stop(wdd))
+				return NOTIFY_BAD;
+		}
+	}
+
+	return NOTIFY_DONE;
+}
+
 static int
 sp805_wdt_probe(struct amba_device *adev, const struct amba_id *id)
 {
 	struct sp805_wdt *wdt;
-	int ret = 0;
+	int irq, ret = 0;
 
 	wdt = devm_kzalloc(&adev->dev, sizeof(*wdt), GFP_KERNEL);
 	if (!wdt) {
@@ -274,6 +327,15 @@ sp805_wdt_probe(struct amba_device *adev
 	watchdog_set_drvdata(&wdt->wdd, wdt);
 	watchdog_set_restart_priority(&wdt->wdd, 128);
 
+	wdt->wdd.reboot_nb.notifier_call = sp805_wdt_reboot_notifier;
+	ret = register_reboot_notifier(&wdt->wdd.reboot_nb);
+	if (ret) {
+		pr_err("sp805 watchdog%d: Cannot register reboot notifier (%d)\n",
+		       wdt->wdd.id, ret);
+		watchdog_dev_unregister(&wdt->wdd);
+		return ret;
+	}
+
 	/*
 	 * If 'timeout-sec' devicetree property is specified, use that.
 	 * Otherwise, use DEFAULT_TIMEOUT
@@ -299,6 +361,20 @@ sp805_wdt_probe(struct amba_device *adev
 	}
 	amba_set_drvdata(adev, wdt);
 
+	irq = irq_of_parse_and_map(adev->dev.of_node, 0);
+	if (irq <= 0) {
+		dev_err(&adev->dev, "sp805 failed to get IRQ\n");
+		goto err;
+	}
+	wdt->irq = irq;
+
+	wdt->ris_status = false;
+	ret = request_irq(irq, sp805_wdt_interrupt, 0, "sp805_wis", wdt);
+	if (ret) {
+		dev_err(&adev->dev, "sp805 IRQ %d request fail\n", irq);
+		goto err;
+	}
+
 	dev_info(&adev->dev, "registration successful\n");
 	return 0;
 
@@ -313,6 +389,7 @@ static int sp805_wdt_remove(struct amba_
 
 	watchdog_unregister_device(&wdt->wdd);
 	watchdog_set_drvdata(&wdt->wdd, NULL);
+	free_irq(wdt->irq, wdt);
 
 	return 0;
 }
--- a/fs/proc/Makefile
+++ b/fs/proc/Makefile
@@ -33,3 +33,4 @@ proc-$(CONFIG_PROC_KCORE)	+= kcore.o
 proc-$(CONFIG_PROC_VMCORE)	+= vmcore.o
 proc-$(CONFIG_PRINTK)	+= kmsg.o
 proc-$(CONFIG_PROC_PAGE_MONITOR)	+= page.o
+proc-y	+= fcd-hwinfo.o
--- a/include/linux/genhd.h
+++ b/include/linux/genhd.h
@@ -117,6 +117,7 @@ struct hd_struct {
 	struct device __dev;
 	struct kobject *holder_dir;
 	int policy, partno;
+	int ubnt_readonly;
 	struct partition_meta_info *info;
 #ifdef CONFIG_FAIL_MAKE_REQUEST
 	int make_it_fail;
@@ -199,6 +200,7 @@ struct gendisk {
 	void *private_data;
 
 	int flags;
+	int ubnt_readonly;
 	struct rw_semaphore lookup_sem;
 	struct kobject *slave_dir;
 
@@ -402,6 +404,22 @@ static inline void free_part_info(struct
 extern void part_round_stats(struct request_queue *q, int cpu, struct hd_struct *part);
 
 /* block/genhd.c */
+typedef void (*gendisk_callback)(struct gendisk *disk, struct hd_struct *part, void * priv);
+extern void gendisk_callback_for_each(gendisk_callback cb, void *priv);
+extern int gendisk_event_hook_reg(gendisk_callback cb, void *priv, unsigned disk_event);
+extern void gendisk_event_hook_unreg(gendisk_callback cb, unsigned disk_event);
+#define DISK_EVENTS(EVENT) \
+		EVENT(DISK_EVENT_ADD)
+
+enum {
+#define EVENT(_ename) _ename,
+	DISK_EVENTS(EVENT)
+#undef EVENT
+	DISK_EVENT_COUNT
+};
+extern void ubnt_set_part_ro(struct gendisk *disk, int partno, int flag);
+extern void ubnt_set_disk_ro(struct gendisk *disk, int flag);
+
 extern void device_add_disk(struct device *parent, struct gendisk *disk,
 			    const struct attribute_group **groups);
 static inline void add_disk(struct gendisk *disk)
--- a/include/linux/if_bridge.h
+++ b/include/linux/if_bridge.h
@@ -129,4 +129,8 @@ br_fdb_find_port(const struct net_device
 }
 #endif
 
+struct net_bridge_port;
+typedef int br_handle_entry_hook_t(struct net_bridge_port *p, void *fdb, int oper, void *context);
+extern br_handle_entry_hook_t *br_handle_entry_hook;
+
 #endif
--- a/include/linux/init.h
+++ b/include/linux/init.h
@@ -142,6 +142,7 @@ typedef void (*ctor_fn_t)(void);
 extern int do_one_initcall(initcall_t fn);
 extern char __initdata boot_command_line[];
 extern char *saved_command_line;
+#define UBNT_HAS_SAVED_COMMAND_LINE
 extern unsigned int reset_devices;
 
 /* used by init/main.c */
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -1014,6 +1014,11 @@ struct ata_port_operations {
 	 * fields must be pointers.
 	 */
 	const struct ata_port_operations	*inherits;
+
+	int (*al_link_hardreset)(struct ata_link *link,
+				 const unsigned long *timing,
+				 unsigned long deadline);
+	bool (*al_ahci_sss_wa_needed)(struct device *dev);
 };
 
 struct ata_port_info {
--- a/include/linux/mtd/mtd.h
+++ b/include/linux/mtd/mtd.h
@@ -278,6 +278,9 @@ struct mtd_info {
 	int numeraseregions;
 	struct mtd_erase_region_info *eraseregions;
 
+	/* JEDEC ID */
+	uint32_t jedec_id;
+
 	/*
 	 * Do not call via these pointers, use corresponding mtd_*()
 	 * wrappers instead.
@@ -598,4 +601,6 @@ static inline int mtd_is_bitflip_or_ecce
 
 unsigned mtd_mmap_capabilities(struct mtd_info *mtd);
 
+typedef void (*mtd_callback)(struct mtd_info* mtd, void * priv);
+void mtd_callback_for_each(mtd_callback cb, void *priv);
 #endif /* __MTD_MTD_H__ */
--- a/include/linux/netdevice.h
+++ b/include/linux/netdevice.h
@@ -186,6 +186,9 @@ struct net_device_stats {
 	unsigned long	tx_window_errors;
 	unsigned long	rx_compressed;
 	unsigned long	tx_compressed;
+#ifdef CONFIG_LLDP_RX_DROP_COUNTER
+	unsigned long	rx_lldp_dropped;
+#endif
 };
 
 
@@ -1491,6 +1494,7 @@ enum netdev_priv_flags {
 	IFF_FAILOVER_SLAVE		= 1<<28,
 	IFF_L3MDEV_RX_HANDLER		= 1<<29,
 	IFF_LIVE_RENAME_OK		= 1<<30,
+	IFF_NO_IP_ALIGN			= 1<<31,
 };
 
 #define IFF_802_1Q_VLAN			IFF_802_1Q_VLAN
@@ -1523,6 +1527,7 @@ enum netdev_priv_flags {
 #define IFF_FAILOVER_SLAVE		IFF_FAILOVER_SLAVE
 #define IFF_L3MDEV_RX_HANDLER		IFF_L3MDEV_RX_HANDLER
 #define IFF_LIVE_RENAME_OK		IFF_LIVE_RENAME_OK
+#define IFF_NO_IP_ALIGN			IFF_NO_IP_ALIGN
 
 /**
  *	struct net_device - The DEVICE structure.
@@ -1794,6 +1799,9 @@ struct net_device {
 	atomic_long_t		rx_dropped;
 	atomic_long_t		tx_dropped;
 	atomic_long_t		rx_nohandler;
+#ifdef CONFIG_LLDP_RX_DROP_COUNTER
+	atomic_long_t		rx_lldp_dropped;
+#endif
 
 	/* Stats to monitor link on/off, flapping */
 	atomic_t		carrier_up_count;
@@ -1823,6 +1831,11 @@ struct net_device {
 	const struct tlsdev_ops *tlsdev_ops;
 #endif
 
+#ifdef CONFIG_ETHERNET_PACKET_MANGLE
+	void (*eth_mangle_rx)(struct net_device *dev, struct sk_buff *skb);
+	struct sk_buff *(*eth_mangle_tx)(struct net_device *dev, struct sk_buff *skb);
+#endif
+
 	const struct header_ops *header_ops;
 
 	unsigned int		flags;
@@ -1903,6 +1916,10 @@ struct net_device {
 	struct mpls_dev __rcu	*mpls_ptr;
 #endif
 
+#ifdef CONFIG_ETHERNET_PACKET_MANGLE
+	void			*phy_ptr; /* PHY device specific data */
+#endif
+
 /*
  * Cache lines mostly used on receive path (including eth_type_trans())
  */
@@ -2032,8 +2049,21 @@ struct net_device {
 	struct lock_class_key	*qdisc_tx_busylock;
 	struct lock_class_key	*qdisc_running_key;
 	bool			proto_down;
+	unsigned int ubnt_flags;
+#define UBNT_FRAME_ID_ENABLE    (1 << 0)
+#define UBNT_RATE_ID_ENABLE     (1 << 1)
+#define UBNT_NFBYPASS_ENABLE    (1 << 2)
+#define UBNT_NFBYPASS_MARK      (1 << 3)
+#define UBNT_VWIRE              (1 << 4)
+#define UBNT_VPORT              (1 << 5)
 	unsigned		wol_enabled:1;
 };
+#define UBNT_IS_FRAME_ID_ENABLE(_dev)   ((_dev)->ubnt_flags & UBNT_FRAME_ID_ENABLE)
+#define UBNT_IS_RATE_ID_ENABLE(_dev)    ((_dev)->ubnt_flags & UBNT_RATE_ID_ENABLE)
+#define UBNT_IS_NFBYPASS_ENABLE(_dev)   ((_dev)->ubnt_flags & UBNT_NFBYPASS_ENABLE)
+#define UBNT_IS_NFBYPASS_MARK(_dev)     ((_dev)->ubnt_flags & UBNT_NFBYPASS_MARK)
+#define UBNT_IS_VWIRE(_dev)             ((_dev)->ubnt_flags & UBNT_VWIRE)
+#define UBNT_IS_VPORT(_dev)             ((_dev)->ubnt_flags & UBNT_VPORT)
 #define to_net_dev(d) container_of(d, struct net_device, dev)
 
 static inline bool netif_elide_gro(const struct net_device *dev)
--- a/include/linux/pci_ids.h
+++ b/include/linux/pci_ids.h
@@ -2587,7 +2587,14 @@
 
 #define PCI_VENDOR_ID_ASMEDIA		0x1b21
 
-#define PCI_VENDOR_ID_AMAZON_ANNAPURNA_LABS	0x1c36
+#define PCI_VENDOR_ID_ANNAPURNA_LABS	0x1c36
+#define PCI_DEVICE_ID_AL_ETH           0x0001
+#define PCI_DEVICE_ID_AL_ETH_ADVANCED      0x0002
+#define PCI_DEVICE_ID_AL_ETH_NIC       0x0004
+#define PCI_DEVICE_ID_AL_ETH_ADVANCED_VF   0x8002
+#define PCI_DEVICE_ID_AL_SSM           0x0022
+#define PCI_DEVICE_ID_AL_SSM_VF            0x8022
+#define PCI_DEVICE_ID_AL_SATA          0x0031
 
 #define PCI_VENDOR_ID_CIRCUITCO		0x1cc8
 #define PCI_SUBSYSTEM_ID_CIRCUITCO_MINNOWBOARD	0x0001
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -28,6 +28,9 @@
 
 #include <linux/atomic.h>
 
+#define PHY_FAKE_ID_BASE 	(0xa5a55a5a)
+#define PHY_FAKE_ID_RTL8370 (PHY_FAKE_ID_BASE + 1)
+
 #define PHY_DEFAULT_FEATURES	(SUPPORTED_Autoneg | \
 				 SUPPORTED_TP | \
 				 SUPPORTED_MII)
@@ -243,6 +246,7 @@ static inline struct mii_bus *mdiobus_al
 }
 
 int __mdiobus_register(struct mii_bus *bus, struct module *owner);
+struct mii_bus * mdiobus_find_by_name( char * name );
 #define mdiobus_register(bus) __mdiobus_register(bus, THIS_MODULE)
 void mdiobus_unregister(struct mii_bus *bus);
 void mdiobus_free(struct mii_bus *bus);
@@ -550,6 +554,12 @@ struct phy_driver {
 	/* Determines the negotiated speed and duplex */
 	int (*read_status)(struct phy_device *phydev);
 
+	/* 
+	 * Update the value in phydev->link to reflect the 
+	 * current link value
+	 */
+	int (*update_link)(struct phy_device *phydev);
+
 	/* Clears any pending interrupts */
 	int (*ack_interrupt)(struct phy_device *phydev);
 
@@ -562,6 +572,12 @@ struct phy_driver {
 	 */
 	int (*did_interrupt)(struct phy_device *phydev);
 
+	/*
+	 * Called before an ethernet device is detached
+	 * from the PHY.
+	 */
+	void (*detach)(struct phy_device *phydev);
+
 	/* Clears up any memory if needed */
 	void (*remove)(struct phy_device *phydev);
 
@@ -1047,6 +1063,7 @@ void phy_ethtool_ksettings_get(struct ph
 			       struct ethtool_link_ksettings *cmd);
 int phy_ethtool_ksettings_set(struct phy_device *phydev,
 			      const struct ethtool_link_ksettings *cmd);
+int phy_ethtool_ioctl(struct phy_device *phydev, void *useraddr);
 int phy_mii_ioctl(struct phy_device *phydev, struct ifreq *ifr, int cmd);
 int phy_start_interrupts(struct phy_device *phydev);
 void phy_print_status(struct phy_device *phydev);
@@ -1075,6 +1092,8 @@ int phy_ethtool_get_link_ksettings(struc
 int phy_ethtool_set_link_ksettings(struct net_device *ndev,
 				   const struct ethtool_link_ksettings *cmd);
 int phy_ethtool_nway_reset(struct net_device *ndev);
+void ubnt_net_notify(void *net, int group, int nlmsgtype,
+			void *data, int size);
 
 #if IS_ENABLED(CONFIG_PHYLIB)
 int __init mdio_bus_init(void);
--- a/include/linux/platform_data/b53.h
+++ b/include/linux/platform_data/b53.h
@@ -29,6 +29,9 @@ struct b53_platform_data {
 	u32 chip_id;
 	u16 enabled_ports;
 
+	/* allow to specify an ethX alias */
+	const char *alias;
+
 	/* only used by MMAP'd driver */
 	unsigned big_endian:1;
 	void __iomem *regs;
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -174,6 +174,7 @@ struct uart_port {
 #if defined(CONFIG_SERIAL_CORE_CONSOLE) || defined(SUPPORT_SYSRQ)
 	unsigned long		sysrq;			/* sysrq timeout */
 	unsigned int		sysrq_ch;		/* char for sysrq */
+	unsigned int		sysrq_pw_window[4];	/* sysrq password window */
 #endif
 
 	/* flags must be updated while holding port mutex */
@@ -492,7 +493,20 @@ uart_handle_sysrq_char(struct uart_port
 {
 	if (port->sysrq) {
 		if (ch && time_before(jiffies, port->sysrq)) {
-			handle_sysrq(ch);
+			// BREAK u BREAK b BREAK n BREAK t
+			if (port->sysrq_pw_window[0] == 'u' &&
+			    port->sysrq_pw_window[1] == 'b'  &&
+			    port->sysrq_pw_window[2] == 'n' &&
+			    port->sysrq_pw_window[3] == 't') {
+				handle_sysrq(ch);
+			} else {
+				unsigned int i;
+
+				for (i = 0; i < 3; i++)
+					port->sysrq_pw_window[i] = port->sysrq_pw_window[i+1];
+
+				port->sysrq_pw_window[3] = ch;
+			}
 			port->sysrq = 0;
 			return 1;
 		}
--- a/include/linux/skbuff.h
+++ b/include/linux/skbuff.h
@@ -831,6 +831,7 @@ struct sk_buff {
 		__u32		reserved_tailroom;
 	};
 
+	__u32           ubnt_mark;
 	union {
 		__be16		inner_protocol;
 		__u8		inner_ipproto;
@@ -2563,6 +2564,10 @@ static inline int pskb_trim(struct sk_bu
 	return (len < skb->len) ? __pskb_trim(skb, len) : 0;
 }
 
+extern struct sk_buff *__netdev_alloc_skb_ip_align(struct net_device *dev,
+		unsigned int length, gfp_t gfp);
+
+
 /**
  *	pskb_trim_unique - remove end from a paged unique (not cloned) buffer
  *	@skb: buffer to alter
@@ -2694,16 +2699,6 @@ static inline struct sk_buff *dev_alloc_
 }
 
 
-static inline struct sk_buff *__netdev_alloc_skb_ip_align(struct net_device *dev,
-		unsigned int length, gfp_t gfp)
-{
-	struct sk_buff *skb = __netdev_alloc_skb(dev, length + NET_IP_ALIGN, gfp);
-
-	if (NET_IP_ALIGN && skb)
-		skb_reserve(skb, NET_IP_ALIGN);
-	return skb;
-}
-
 static inline struct sk_buff *netdev_alloc_skb_ip_align(struct net_device *dev,
 		unsigned int length)
 {
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -819,7 +819,11 @@ static inline struct hci_conn *hci_conn_
 	rcu_read_lock();
 
 	list_for_each_entry_rcu(c, &h->list, list) {
+#ifdef CONFIG_BT_NORDIC_QUIRK_LOOKUP_FIX
+		if (!bacmp(&c->dst, ba)) {
+#else
 		if (c->type == type && !bacmp(&c->dst, ba)) {
+#endif
 			rcu_read_unlock();
 			return c;
 		}
--- a/include/net/cfg80211.h
+++ b/include/net/cfg80211.h
@@ -1033,6 +1033,7 @@ struct station_del_parameters {
 	const u8 *mac;
 	u8 subtype;
 	u16 reason_code;
+	bool sta_roamed;
 };
 
 /**
--- a/include/net/netfilter/nf_conntrack_extend.h
+++ b/include/net/netfilter/nf_conntrack_extend.h
@@ -28,6 +28,9 @@ enum nf_ct_ext_id {
 #if IS_ENABLED(CONFIG_NETFILTER_SYNPROXY)
 	NF_CT_EXT_SYNPROXY,
 #endif
+#ifdef CONFIG_NF_CONNTRACK_DPI
+	NF_CT_EXT_DPI,
+#endif
 	NF_CT_EXT_NUM,
 };
 
@@ -40,6 +43,7 @@ enum nf_ct_ext_id {
 #define NF_CT_EXT_TIMEOUT_TYPE struct nf_conn_timeout
 #define NF_CT_EXT_LABELS_TYPE struct nf_conn_labels
 #define NF_CT_EXT_SYNPROXY_TYPE struct nf_conn_synproxy
+#define NF_CT_EXT_DPI_TYPE struct nf_conn_dpi
 
 /* Extensions: optional stuff which isn't permanently in struct. */
 struct nf_ct_ext {
--- a/include/net/udp_tunnel.h
+++ b/include/net/udp_tunnel.h
@@ -33,6 +33,8 @@ struct udp_port_cfg {
 	unsigned int		use_udp_checksums:1,
 				use_udp6_tx_checksums:1,
 				use_udp6_rx_checksums:1,
+				reuse_addr:1,
+				reuse_port:1,
 				ipv6_v6only:1;
 };
 
--- a/include/uapi/linux/if_ether.h
+++ b/include/uapi/linux/if_ether.h
@@ -91,6 +91,7 @@
 #define ETH_P_802_EX1	0x88B5		/* 802.1 Local Experimental 1.  */
 #define ETH_P_PREAUTH	0x88C7		/* 802.11 Preauthentication */
 #define ETH_P_TIPC	0x88CA		/* TIPC 			*/
+#define ETH_P_LLDP	0x88CC		/* LLDP				*/
 #define ETH_P_MACSEC	0x88E5		/* 802.1ae MACsec */
 #define ETH_P_8021AH	0x88E7          /* 802.1ah Backbone Service Tag */
 #define ETH_P_MVRP	0x88F5          /* 802.1Q MVRP                  */
--- a/include/uapi/linux/if_link.h
+++ b/include/uapi/linux/if_link.h
@@ -38,6 +38,11 @@ struct rtnl_link_stats {
 	__u32	tx_compressed;
 
 	__u32	rx_nohandler;		/* dropped, no handler found	*/
+
+	/* extra */
+#ifdef CONFIG_LLDP_RX_DROP_COUNTER
+	__u32	rx_lldp_dropped;
+#endif
 };
 
 /* The main device statistics structure */
@@ -73,6 +78,11 @@ struct rtnl_link_stats64 {
 	__u64	tx_compressed;
 
 	__u64	rx_nohandler;		/* dropped, no handler found	*/
+
+	/* extra */
+#ifdef CONFIG_LLDP_RX_DROP_COUNTER
+	__u64	rx_lldp_dropped;
+#endif
 };
 
 /* The struct should be in sync with struct ifmap */
--- a/include/uapi/linux/netfilter/nfnetlink_conntrack.h
+++ b/include/uapi/linux/netfilter/nfnetlink_conntrack.h
@@ -55,6 +55,7 @@ enum ctattr_type {
 	CTA_LABELS,
 	CTA_LABELS_MASK,
 	CTA_SYNPROXY,
+	CTA_DPI,
 	__CTA_MAX
 };
 #define CTA_MAX (__CTA_MAX - 1)
@@ -276,4 +277,18 @@ enum ctattr_expect_stats {
 };
 #define CTA_STATS_EXP_MAX (__CTA_STATS_EXP_MAX - 1)
 
+enum ctattr_dpi {
+	CTA_DPI_UNSPEC,
+	CTA_DPI_PROTO,
+	CTA_DPI_DNS,
+	CTA_DPI_DNS_LEN,
+	CTA_DPI_DOMAIN_NAME,
+	CTA_DPI_DOMAIN_NAME_LEN,
+	CTA_DPI_CAT,
+	CTA_DPI_APP,
+	__CTA_DPI_MAX,
+};
+#define CTA_DPI_MAX (__CTA_DPI_MAX - 1)
+#define USE_CTA_DPI_CATAPP 1
+
 #endif /* _IPCONNTRACK_NETLINK_H */
--- a/include/uapi/linux/netfilter_bridge/ebt_mark_t.h
+++ b/include/uapi/linux/netfilter_bridge/ebt_mark_t.h
@@ -13,6 +13,10 @@
 #define MARK_OR_VALUE  (0xffffffe0)
 #define MARK_AND_VALUE (0xffffffd0)
 #define MARK_XOR_VALUE (0xffffffc0)
+#define MARK_UBNT_SET_VALUE (0xffffffb0)
+#define MARK_UBNT_OR_VALUE (0xffffffa0)
+#define MARK_UBNT_AND_VALUE (0xffffff90)
+#define MARK_UBNT_XOR_VALUE (0xffffff80)
 
 struct ebt_mark_t_info {
 	unsigned long mark;
--- a/include/uapi/linux/nl80211.h
+++ b/include/uapi/linux/nl80211.h
@@ -11,7 +11,7 @@
  * Copyright 2008 Jouni Malinen <jouni.malinen@atheros.com>
  * Copyright 2008 Colin McCabe <colin@cozybit.com>
  * Copyright 2015-2017	Intel Deutschland GmbH
- * Copyright (C) 2018 Intel Corporation
+ * Copyright (C) 2018-2020 Intel Corporation
  *
  * Permission to use, copy, modify, and/or distribute this software for any
  * purpose with or without fee is hereby granted, provided that the above
@@ -52,6 +52,11 @@
 #define NL80211_MULTICAST_GROUP_NAN		"nan"
 #define NL80211_MULTICAST_GROUP_TESTMODE	"testmode"
 
+#define NL80211_EDMG_BW_CONFIG_MIN	4
+#define NL80211_EDMG_BW_CONFIG_MAX	15
+#define NL80211_EDMG_CHANNELS_MIN	1
+#define NL80211_EDMG_CHANNELS_MAX	0x3c /* 0b00111100 */
+
 /**
  * DOC: Station handling
  *
@@ -178,18 +183,27 @@
  *
  * By setting @NL80211_EXT_FEATURE_4WAY_HANDSHAKE_STA_PSK flag drivers
  * can indicate they support offloading EAPOL handshakes for WPA/WPA2
- * preshared key authentication. In %NL80211_CMD_CONNECT the preshared
- * key should be specified using %NL80211_ATTR_PMK. Drivers supporting
- * this offload may reject the %NL80211_CMD_CONNECT when no preshared
- * key material is provided, for example when that driver does not
- * support setting the temporal keys through %CMD_NEW_KEY.
+ * preshared key authentication in station mode. In %NL80211_CMD_CONNECT
+ * the preshared key should be specified using %NL80211_ATTR_PMK. Drivers
+ * supporting this offload may reject the %NL80211_CMD_CONNECT when no
+ * preshared key material is provided, for example when that driver does
+ * not support setting the temporal keys through %NL80211_CMD_NEW_KEY.
  *
  * Similarly @NL80211_EXT_FEATURE_4WAY_HANDSHAKE_STA_1X flag can be
  * set by drivers indicating offload support of the PTK/GTK EAPOL
- * handshakes during 802.1X authentication. In order to use the offload
- * the %NL80211_CMD_CONNECT should have %NL80211_ATTR_WANT_1X_4WAY_HS
- * attribute flag. Drivers supporting this offload may reject the
- * %NL80211_CMD_CONNECT when the attribute flag is not present.
+ * handshakes during 802.1X authentication in station mode. In order to
+ * use the offload the %NL80211_CMD_CONNECT should have
+ * %NL80211_ATTR_WANT_1X_4WAY_HS attribute flag. Drivers supporting this
+ * offload may reject the %NL80211_CMD_CONNECT when the attribute flag is
+ * not present.
+ *
+ * By setting @NL80211_EXT_FEATURE_4WAY_HANDSHAKE_AP_PSK flag drivers
+ * can indicate they support offloading EAPOL handshakes for WPA/WPA2
+ * preshared key authentication in AP mode. In %NL80211_CMD_START_AP
+ * the preshared key should be specified using %NL80211_ATTR_PMK. Drivers
+ * supporting this offload may reject the %NL80211_CMD_START_AP when no
+ * preshared key material is provided, for example when that driver does
+ * not support setting the temporal keys through %NL80211_CMD_NEW_KEY.
  *
  * For 802.1X the PMK or PMK-R0 are set by providing %NL80211_ATTR_PMK
  * using %NL80211_CMD_SET_PMK. For offloaded FT support also
@@ -235,6 +249,58 @@
  */
 
 /**
+ * DOC: SAE authentication offload
+ *
+ * By setting @NL80211_EXT_FEATURE_SAE_OFFLOAD flag drivers can indicate they
+ * support offloading SAE authentication for WPA3-Personal networks in station
+ * mode. Similarly @NL80211_EXT_FEATURE_SAE_OFFLOAD_AP flag can be set by
+ * drivers indicating the offload support in AP mode.
+ *
+ * The password for SAE should be specified using %NL80211_ATTR_SAE_PASSWORD in
+ * %NL80211_CMD_CONNECT and %NL80211_CMD_START_AP for station and AP mode
+ * respectively.
+ */
+
+/**
+ * DOC: VLAN offload support for setting group keys and binding STAs to VLANs
+ *
+ * By setting @NL80211_EXT_FEATURE_VLAN_OFFLOAD flag drivers can indicate they
+ * support offloading VLAN functionality in a manner where the driver exposes a
+ * single netdev that uses VLAN tagged frames and separate VLAN-specific netdevs
+ * can then be added using RTM_NEWLINK/IFLA_VLAN_ID similarly to the Ethernet
+ * case. Frames received from stations that are not assigned to any VLAN are
+ * delivered on the main netdev and frames to such stations can be sent through
+ * that main netdev.
+ *
+ * %NL80211_CMD_NEW_KEY (for group keys), %NL80211_CMD_NEW_STATION, and
+ * %NL80211_CMD_SET_STATION will optionally specify vlan_id using
+ * %NL80211_ATTR_VLAN_ID.
+ */
+
+/**
+ * DOC: TID configuration
+ *
+ * TID config support can be checked in the %NL80211_ATTR_TID_CONFIG
+ * attribute given in wiphy capabilities.
+ *
+ * The necessary configuration parameters are mentioned in
+ * &enum nl80211_tid_config_attr and it will be passed to the
+ * %NL80211_CMD_SET_TID_CONFIG command in %NL80211_ATTR_TID_CONFIG.
+ *
+ * If the configuration needs to be applied for specific peer then the MAC
+ * address of the peer needs to be passed in %NL80211_ATTR_MAC, otherwise the
+ * configuration will be applied for all the connected peers in the vif except
+ * any peers that have peer specific configuration for the TID by default; if
+ * the %NL80211_TID_CONFIG_ATTR_OVERRIDE flag is set, peer specific values
+ * will be overwritten.
+ *
+ * All this configuration is valid only for STA's current connection
+ * i.e. the configuration will be reset to default when the STA connects back
+ * after disconnection/roaming, and this configuration will be cleared when
+ * the interface goes down.
+ */
+
+/**
  * enum nl80211_commands - supported nl80211 commands
  *
  * @NL80211_CMD_UNSPEC: unspecified command to catch errors
@@ -243,13 +309,14 @@
  *	to get a list of all present wiphys.
  * @NL80211_CMD_SET_WIPHY: set wiphy parameters, needs %NL80211_ATTR_WIPHY or
  *	%NL80211_ATTR_IFINDEX; can be used to set %NL80211_ATTR_WIPHY_NAME,
- *	%NL80211_ATTR_WIPHY_TXQ_PARAMS, %NL80211_ATTR_WIPHY_FREQ (and the
- *	attributes determining the channel width; this is used for setting
- *	monitor mode channel),  %NL80211_ATTR_WIPHY_RETRY_SHORT,
- *	%NL80211_ATTR_WIPHY_RETRY_LONG, %NL80211_ATTR_WIPHY_FRAG_THRESHOLD,
- *	and/or %NL80211_ATTR_WIPHY_RTS_THRESHOLD.
- *	However, for setting the channel, see %NL80211_CMD_SET_CHANNEL
- *	instead, the support here is for backward compatibility only.
+ *	%NL80211_ATTR_WIPHY_TXQ_PARAMS, %NL80211_ATTR_WIPHY_FREQ,
+ *	%NL80211_ATTR_WIPHY_FREQ_OFFSET (and the attributes determining the
+ *	channel width; this is used for setting monitor mode channel),
+ *	%NL80211_ATTR_WIPHY_RETRY_SHORT, %NL80211_ATTR_WIPHY_RETRY_LONG,
+ *	%NL80211_ATTR_WIPHY_FRAG_THRESHOLD, and/or
+ *	%NL80211_ATTR_WIPHY_RTS_THRESHOLD.  However, for setting the channel,
+ *	see %NL80211_CMD_SET_CHANNEL instead, the support here is for backward
+ *	compatibility only.
  * @NL80211_CMD_NEW_WIPHY: Newly created wiphy, response to get request
  *	or rename notification. Has attributes %NL80211_ATTR_WIPHY and
  *	%NL80211_ATTR_WIPHY_NAME.
@@ -298,7 +365,8 @@
  *	%NL80211_ATTR_AUTH_TYPE, %NL80211_ATTR_INACTIVITY_TIMEOUT,
  *	%NL80211_ATTR_ACL_POLICY and %NL80211_ATTR_MAC_ADDRS.
  *	The channel to use can be set on the interface or be given using the
- *	%NL80211_ATTR_WIPHY_FREQ and the attributes determining channel width.
+ *	%NL80211_ATTR_WIPHY_FREQ and %NL80211_ATTR_WIPHY_FREQ_OFFSET, and the
+ *	attributes determining channel width.
  * @NL80211_CMD_NEW_BEACON: old alias for %NL80211_CMD_START_AP
  * @NL80211_CMD_STOP_AP: Stop AP operation on the given interface
  * @NL80211_CMD_DEL_BEACON: old alias for %NL80211_CMD_STOP_AP
@@ -308,7 +376,7 @@
  * @NL80211_CMD_SET_STATION: Set station attributes for station identified by
  *	%NL80211_ATTR_MAC on the interface identified by %NL80211_ATTR_IFINDEX.
  * @NL80211_CMD_NEW_STATION: Add a station with given attributes to the
- *	the interface identified by %NL80211_ATTR_IFINDEX.
+ *	interface identified by %NL80211_ATTR_IFINDEX.
  * @NL80211_CMD_DEL_STATION: Remove a station identified by %NL80211_ATTR_MAC
  *	or, if no MAC address given, all stations, on the interface identified
  *	by %NL80211_ATTR_IFINDEX. %NL80211_ATTR_MGMT_SUBTYPE and
@@ -328,7 +396,7 @@
  * @NL80211_CMD_DEL_MPATH: Delete a mesh path to the destination given by
  *	%NL80211_ATTR_MAC.
  * @NL80211_CMD_NEW_PATH: Add a mesh path with given attributes to the
- *	the interface identified by %NL80211_ATTR_IFINDEX.
+ *	interface identified by %NL80211_ATTR_IFINDEX.
  * @NL80211_CMD_DEL_PATH: Remove a mesh path identified by %NL80211_ATTR_MAC
  *	or, if no MAC address given, all mesh paths, on the interface identified
  *	by %NL80211_ATTR_IFINDEX.
@@ -483,11 +551,12 @@
  *	interface. %NL80211_ATTR_MAC is used to specify PeerSTAAddress (and
  *	BSSID in case of station mode). %NL80211_ATTR_SSID is used to specify
  *	the SSID (mainly for association, but is included in authentication
- *	request, too, to help BSS selection. %NL80211_ATTR_WIPHY_FREQ is used
- *	to specify the frequence of the channel in MHz. %NL80211_ATTR_AUTH_TYPE
- *	is used to specify the authentication type. %NL80211_ATTR_IE is used to
- *	define IEs (VendorSpecificInfo, but also including RSN IE and FT IEs)
- *	to be added to the frame.
+ *	request, too, to help BSS selection. %NL80211_ATTR_WIPHY_FREQ +
+ *	%NL80211_ATTR_WIPHY_FREQ_OFFSET is used to specify the frequence of the
+ *	channel in MHz. %NL80211_ATTR_AUTH_TYPE is used to specify the
+ *	authentication type. %NL80211_ATTR_IE is used to define IEs
+ *	(VendorSpecificInfo, but also including RSN IE and FT IEs) to be added
+ *	to the frame.
  *	When used as an event, this reports reception of an Authentication
  *	frame in station and IBSS modes when the local MLME processed the
  *	frame, i.e., it was for the local STA and was received in correct
@@ -542,8 +611,9 @@
  *	requests to connect to a specified network but without separating
  *	auth and assoc steps. For this, you need to specify the SSID in a
  *	%NL80211_ATTR_SSID attribute, and can optionally specify the association
- *	IEs in %NL80211_ATTR_IE, %NL80211_ATTR_AUTH_TYPE, %NL80211_ATTR_USE_MFP,
- *	%NL80211_ATTR_MAC, %NL80211_ATTR_WIPHY_FREQ, %NL80211_ATTR_CONTROL_PORT,
+ *	IEs in %NL80211_ATTR_IE, %NL80211_ATTR_AUTH_TYPE,
+ *	%NL80211_ATTR_USE_MFP, %NL80211_ATTR_MAC, %NL80211_ATTR_WIPHY_FREQ,
+ *	%NL80211_ATTR_WIPHY_FREQ_OFFSET, %NL80211_ATTR_CONTROL_PORT,
  *	%NL80211_ATTR_CONTROL_PORT_ETHERTYPE,
  *	%NL80211_ATTR_CONTROL_PORT_NO_ENCRYPT,
  *	%NL80211_ATTR_CONTROL_PORT_OVER_NL80211, %NL80211_ATTR_MAC_HINT, and
@@ -557,6 +627,14 @@
  *	set of BSSID,frequency parameters is used (i.e., either the enforcing
  *	%NL80211_ATTR_MAC,%NL80211_ATTR_WIPHY_FREQ or the less strict
  *	%NL80211_ATTR_MAC_HINT and %NL80211_ATTR_WIPHY_FREQ_HINT).
+ *	Driver shall not modify the IEs specified through %NL80211_ATTR_IE if
+ *	%NL80211_ATTR_MAC is included. However, if %NL80211_ATTR_MAC_HINT is
+ *	included, these IEs through %NL80211_ATTR_IE are specified by the user
+ *	space based on the best possible BSS selected. Thus, if the driver ends
+ *	up selecting a different BSS, it can modify these IEs accordingly (e.g.
+ *	userspace asks the driver to perform PMKSA caching with BSS1 and the
+ *	driver ends up selecting BSS2 with different PMKSA cache entry; RSNIE
+ *	has to get updated with the apt PMKID).
  *	%NL80211_ATTR_PREV_BSSID can be used to request a reassociation within
  *	the ESS in case the device is already associated and an association with
  *	a different BSS is desired.
@@ -573,14 +651,13 @@
  *	authentication/association or not receiving a response from the AP.
  *	Non-zero %NL80211_ATTR_STATUS_CODE value is indicated in that case as
  *	well to remain backwards compatible.
- *	When establishing a security association, drivers that support 4 way
- *	handshake offload should send %NL80211_CMD_PORT_AUTHORIZED event when
- *	the 4 way handshake is completed successfully.
  * @NL80211_CMD_ROAM: Notification indicating the card/driver roamed by itself.
- *	When a security association was established with the new AP (e.g. if
- *	the FT protocol was used for roaming or the driver completed the 4 way
- *	handshake), this event should be followed by an
+ *	When a security association was established on an 802.1X network using
+ *	fast transition, this event should be followed by an
  *	%NL80211_CMD_PORT_AUTHORIZED event.
+ *	Following a %NL80211_CMD_ROAM event userspace can issue
+ *	%NL80211_CMD_GET_SCAN in order to obtain the scan information for the
+ *	new BSS the card/driver roamed to.
  * @NL80211_CMD_DISCONNECT: drop a given connection; also used to notify
  *	userspace that a connection was dropped by the AP or due to other
  *	reasons, for this the %NL80211_ATTR_DISCONNECTED_BY_AP and
@@ -626,6 +703,10 @@
  *	four bytes for vendor frames including the OUI. The registration
  *	cannot be dropped, but is removed automatically when the netlink
  *	socket is closed. Multiple registrations can be made.
+ *	The %NL80211_ATTR_RECEIVE_MULTICAST flag attribute can be given if
+ *	%NL80211_EXT_FEATURE_MULTICAST_REGISTRATIONS is available, in which
+ *	case the registration can also be modified to include/exclude the
+ *	flag, rather than requiring unregistration to change it.
  * @NL80211_CMD_REGISTER_ACTION: Alias for @NL80211_CMD_REGISTER_FRAME for
  *	backward compatibility
  * @NL80211_CMD_FRAME: Management frame TX request and RX notification. This
@@ -648,7 +729,9 @@
  *	is used during CSA period.
  * @NL80211_CMD_FRAME_WAIT_CANCEL: When an off-channel TX was requested, this
  *	command may be used with the corresponding cookie to cancel the wait
- *	time if it is known that it is no longer necessary.
+ *	time if it is known that it is no longer necessary.  This command is
+ *	also sent as an event whenever the driver has completed the off-channel
+ *	wait time.
  * @NL80211_CMD_ACTION: Alias for @NL80211_CMD_FRAME for backward compatibility.
  * @NL80211_CMD_FRAME_TX_STATUS: Report TX status of a management frame
  *	transmitted with %NL80211_CMD_FRAME. %NL80211_ATTR_COOKIE identifies
@@ -677,7 +760,8 @@
  *	of any other interfaces, and other interfaces will again take
  *	precedence when they are used.
  *
- * @NL80211_CMD_SET_WDS_PEER: Set the MAC address of the peer on a WDS interface.
+ * @NL80211_CMD_SET_WDS_PEER: Set the MAC address of the peer on a WDS interface
+ *	(no longer supported).
  *
  * @NL80211_CMD_SET_MULTICAST_TO_UNICAST: Configure if this AP should perform
  *	multicast to unicast conversion. When enabled, all multicast packets
@@ -723,7 +807,7 @@
  *	various triggers. These triggers can be configured through this
  *	command with the %NL80211_ATTR_WOWLAN_TRIGGERS attribute. For
  *	more background information, see
- *	http://wireless.kernel.org/en/users/Documentation/WoWLAN.
+ *	https://wireless.wiki.kernel.org/en/users/Documentation/WoWLAN.
  *	The @NL80211_CMD_SET_WOWLAN command can also be used as a notification
  *	from the driver reporting the wakeup reason. In this case, the
  *	@NL80211_ATTR_WOWLAN_TRIGGERS attribute will contain the reason
@@ -863,7 +947,7 @@
  * @NL80211_CMD_SET_COALESCE: Configure coalesce rules or clear existing rules.
  *
  * @NL80211_CMD_CHANNEL_SWITCH: Perform a channel switch by announcing the
- *	the new channel information (Channel Switch Announcement - CSA)
+ *	new channel information (Channel Switch Announcement - CSA)
  *	in the beacon for some time (as defined in the
  *	%NL80211_ATTR_CH_SWITCH_COUNT parameter) and then change to the
  *	new channel. Userspace provides the new channel information (using
@@ -987,13 +1071,11 @@
  * @NL80211_CMD_DEL_PMK: For offloaded 4-Way handshake, delete the previously
  *	configured PMK for the authenticator address identified by
  *	%NL80211_ATTR_MAC.
- * @NL80211_CMD_PORT_AUTHORIZED: An event that indicates that the 4 way
- *	handshake was completed successfully by the driver. The BSSID is
- *	specified with %NL80211_ATTR_MAC. Drivers that support 4 way handshake
- *	offload should send this event after indicating 802.11 association with
- *	%NL80211_CMD_CONNECT or %NL80211_CMD_ROAM. If the 4 way handshake failed
- *	%NL80211_CMD_DISCONNECT should be indicated instead.
- *
+ * @NL80211_CMD_PORT_AUTHORIZED: An event that indicates an 802.1X FT roam was
+ *	completed successfully. Drivers that support 4 way handshake offload
+ *	should send this event after indicating 802.1X FT assocation with
+ *	%NL80211_CMD_ROAM. If the 4 way handshake failed %NL80211_CMD_DISCONNECT
+ *	should be indicated instead.
  * @NL80211_CMD_CONTROL_PORT_FRAME: Control Port (e.g. PAE) frame TX request
  *	and RX notification.  This command is used both as a request to transmit
  *	a control port frame and as a notification that a control port frame
@@ -1033,6 +1115,76 @@
  *	%NL80211_ATTR_CHANNEL_WIDTH,%NL80211_ATTR_NSS attributes with its
  *	address(specified in %NL80211_ATTR_MAC).
  *
+ * @NL80211_CMD_GET_FTM_RESPONDER_STATS: Retrieve FTM responder statistics, in
+ *	the %NL80211_ATTR_FTM_RESPONDER_STATS attribute.
+ *
+ * @NL80211_CMD_PEER_MEASUREMENT_START: start a (set of) peer measurement(s)
+ *	with the given parameters, which are encapsulated in the nested
+ *	%NL80211_ATTR_PEER_MEASUREMENTS attribute. Optionally, MAC address
+ *	randomization may be enabled and configured by specifying the
+ *	%NL80211_ATTR_MAC and %NL80211_ATTR_MAC_MASK attributes.
+ *	If a timeout is requested, use the %NL80211_ATTR_TIMEOUT attribute.
+ *	A u64 cookie for further %NL80211_ATTR_COOKIE use is returned in
+ *	the netlink extended ack message.
+ *
+ *	To cancel a measurement, close the socket that requested it.
+ *
+ *	Measurement results are reported to the socket that requested the
+ *	measurement using @NL80211_CMD_PEER_MEASUREMENT_RESULT when they
+ *	become available, so applications must ensure a large enough socket
+ *	buffer size.
+ *
+ *	Depending on driver support it may or may not be possible to start
+ *	multiple concurrent measurements.
+ * @NL80211_CMD_PEER_MEASUREMENT_RESULT: This command number is used for the
+ *	result notification from the driver to the requesting socket.
+ * @NL80211_CMD_PEER_MEASUREMENT_COMPLETE: Notification only, indicating that
+ *	the measurement completed, using the measurement cookie
+ *	(%NL80211_ATTR_COOKIE).
+ *
+ * @NL80211_CMD_NOTIFY_RADAR: Notify the kernel that a radar signal was
+ *	detected and reported by a neighboring device on the channel
+ *	indicated by %NL80211_ATTR_WIPHY_FREQ and other attributes
+ *	determining the width and type.
+ *
+ * @NL80211_CMD_UPDATE_OWE_INFO: This interface allows the host driver to
+ *	offload OWE processing to user space. This intends to support
+ *	OWE AKM by the host drivers that implement SME but rely
+ *	on the user space for the cryptographic/DH IE processing in AP mode.
+ *
+ * @NL80211_CMD_PROBE_MESH_LINK: The requirement for mesh link metric
+ *	refreshing, is that from one mesh point we be able to send some data
+ *	frames to other mesh points which are not currently selected as a
+ *	primary traffic path, but which are only 1 hop away. The absence of
+ *	the primary path to the chosen node makes it necessary to apply some
+ *	form of marking on a chosen packet stream so that the packets can be
+ *	properly steered to the selected node for testing, and not by the
+ *	regular mesh path lookup. Further, the packets must be of type data
+ *	so that the rate control (often embedded in firmware) is used for
+ *	rate selection.
+ *
+ *	Here attribute %NL80211_ATTR_MAC is used to specify connected mesh
+ *	peer MAC address and %NL80211_ATTR_FRAME is used to specify the frame
+ *	content. The frame is ethernet data.
+ *
+ * @NL80211_CMD_SET_TID_CONFIG: Data frame TID specific configuration
+ *	is passed using %NL80211_ATTR_TID_CONFIG attribute.
+ *
+ * @NL80211_CMD_UNPROT_BEACON: Unprotected or incorrectly protected Beacon
+ *	frame. This event is used to indicate that a received Beacon frame was
+ *	dropped because it did not include a valid MME MIC while beacon
+ *	protection was enabled (BIGTK configured in station mode).
+ *
+ * @NL80211_CMD_CONTROL_PORT_FRAME_TX_STATUS: Report TX status of a control
+ *	port frame transmitted with %NL80211_CMD_CONTROL_PORT_FRAME.
+ *	%NL80211_ATTR_COOKIE identifies the TX command and %NL80211_ATTR_FRAME
+ *	includes the contents of the frame. %NL80211_ATTR_ACK flag is included
+ *	if the recipient acknowledged the frame.
+ *
+ * @NL80211_CMD_SET_SAR_SPECS: SAR power limitation configuration is
+ *	passed using %NL80211_ATTR_SAR_SPEC. %NL80211_ATTR_WIPHY is used to
+ *	specify the wiphy index to be applied to.
+ *
  * @NL80211_CMD_MAX: highest used command number
  * @__NL80211_CMD_AFTER_LAST: internal use
  */
@@ -1245,6 +1397,26 @@ enum nl80211_commands {
 
 	NL80211_CMD_CONTROL_PORT_FRAME,
 
+	NL80211_CMD_GET_FTM_RESPONDER_STATS,
+
+	NL80211_CMD_PEER_MEASUREMENT_START,
+	NL80211_CMD_PEER_MEASUREMENT_RESULT,
+	NL80211_CMD_PEER_MEASUREMENT_COMPLETE,
+
+	NL80211_CMD_NOTIFY_RADAR,
+
+	NL80211_CMD_UPDATE_OWE_INFO,
+
+	NL80211_CMD_PROBE_MESH_LINK,
+
+	NL80211_CMD_SET_TID_CONFIG,
+
+	NL80211_CMD_UNPROT_BEACON,
+
+	NL80211_CMD_CONTROL_PORT_FRAME_TX_STATUS,
+
+	NL80211_CMD_SET_SAR_SPECS,
+
 	/* add new commands above here */
 
 	/* used to define NL80211_CMD_MAX below */
@@ -1290,7 +1462,8 @@ enum nl80211_commands {
  *	of &enum nl80211_chan_width, describing the channel width. See the
  *	documentation of the enum for more information.
  * @NL80211_ATTR_CENTER_FREQ1: Center frequency of the first part of the
- *	channel, used for anything but 20 MHz bandwidth
+ *	channel, used for anything but 20 MHz bandwidth. In S1G this is the
+ *	operating channel center frequency.
  * @NL80211_ATTR_CENTER_FREQ2: Center frequency of the second part of the
  *	channel, used only for 80+80 MHz bandwidth
  * @NL80211_ATTR_WIPHY_CHANNEL_TYPE: included with NL80211_ATTR_WIPHY_FREQ
@@ -1355,7 +1528,7 @@ enum nl80211_commands {
  *	rates as defined by IEEE 802.11 7.3.2.2 but without the length
  *	restriction (at most %NL80211_MAX_SUPP_RATES).
  * @NL80211_ATTR_STA_VLAN: interface index of VLAN interface to move station
- *	to, or the AP interface the station was originally added to to.
+ *	to, or the AP interface the station was originally added to.
  * @NL80211_ATTR_STA_INFO: information about a station, part of station info
  *	given for %NL80211_CMD_GET_STATION, nested attribute containing
  *	info as possible, see &enum nl80211_sta_info.
@@ -1500,7 +1673,8 @@ enum nl80211_commands {
  *	flag is included, then control port frames are sent over NL80211 instead
  *	using %CMD_CONTROL_PORT_FRAME.  If control port routing over NL80211 is
  *	to be used then userspace must also use the %NL80211_ATTR_SOCKET_OWNER
- *	flag.
+ *	flag. When used with %NL80211_ATTR_CONTROL_PORT_NO_PREAUTH, pre-auth
+ *	frames are not forwared over the control port.
  *
  * @NL80211_ATTR_TESTDATA: Testmode data blob, passed through to the driver.
  *	We recommend using nested, driver-specific attributes within this.
@@ -1525,6 +1699,12 @@ enum nl80211_commands {
  *	(a u32 with flags from &enum nl80211_wpa_versions).
  * @NL80211_ATTR_AKM_SUITES: Used with CONNECT, ASSOCIATE, and NEW_BEACON to
  *	indicate which key management algorithm(s) to use (an array of u32).
+ *	This attribute is also sent in response to @NL80211_CMD_GET_WIPHY,
+ *	indicating the supported AKM suites, intended for specific drivers which
+ *	implement SME and have constraints on which AKMs are supported and also
+ *	the cases where an AKM support is offloaded to the driver/firmware.
+ *	If there is no such notification from the driver, user space should
+ *	assume the driver supports all the AKM suites.
  *
  * @NL80211_ATTR_REQ_IE: (Re)association request information elements as
  *	sent out by the card, for ROAM and successful CONNECT events.
@@ -1580,8 +1760,9 @@ enum nl80211_commands {
  *	specify just a single bitrate, which is to be used for the beacon.
  *	The driver must also specify support for this with the extended
  *	features NL80211_EXT_FEATURE_BEACON_RATE_LEGACY,
- *	NL80211_EXT_FEATURE_BEACON_RATE_HT and
- *	NL80211_EXT_FEATURE_BEACON_RATE_VHT.
+ *	NL80211_EXT_FEATURE_BEACON_RATE_HT,
+ *	NL80211_EXT_FEATURE_BEACON_RATE_VHT and
+ *	NL80211_EXT_FEATURE_BEACON_RATE_HE.
  *
  * @NL80211_ATTR_FRAME_MATCH: A binary attribute which typically must contain
  *	at least one byte, currently used with @NL80211_CMD_REGISTER_FRAME.
@@ -1701,7 +1882,7 @@ enum nl80211_commands {
  *	the values passed in @NL80211_ATTR_SCAN_SSIDS (eg. if an SSID
  *	is included in the probe request, but the match attributes
  *	will never let it go through), -EINVAL may be returned.
- *	If ommited, no filtering is done.
+ *	If omitted, no filtering is done.
  *
  * @NL80211_ATTR_INTERFACE_COMBINATIONS: Nested attribute listing the supported
  *	interface combinations. In each nested item, it contains attributes
@@ -1785,8 +1966,15 @@ enum nl80211_commands {
  * @NL80211_ATTR_PROBE_RESP: Probe Response template data. Contains the entire
  *	probe-response frame. The DA field in the 802.11 header is zero-ed out,
  *	to be filled by the FW.
- * @NL80211_ATTR_DISABLE_HT:  Force HT capable interfaces to disable
- *      this feature.  Currently, only supported in mac80211 drivers.
+ * @NL80211_ATTR_DISABLE_HT: Force HT capable interfaces to disable
+ *      this feature during association. This is a flag attribute.
+ *	Currently only supported in mac80211 drivers.
+ * @NL80211_ATTR_DISABLE_VHT: Force VHT capable interfaces to disable
+ *      this feature during association. This is a flag attribute.
+ *	Currently only supported in mac80211 drivers.
+ * @NL80211_ATTR_DISABLE_HE: Force HE capable interfaces to disable
+ *      this feature during association. This is a flag attribute.
+ *	Currently only supported in mac80211 drivers.
  * @NL80211_ATTR_HT_CAPABILITY_MASK: Specify which bits of the
  *      ATTR_HT_CAPABILITY to which attention should be paid.
  *      Currently, only mac80211 NICs support this feature.
@@ -1806,7 +1994,7 @@ enum nl80211_commands {
  *
  * @NL80211_ATTR_INACTIVITY_TIMEOUT: timeout value in seconds, this can be
  *	used by the drivers which has MLME in firmware and does not have support
- *	to report per station tx/rx activity to free up the staion entry from
+ *	to report per station tx/rx activity to free up the station entry from
  *	the list. This needs to be used when the driver advertises the
  *	capability to timeout the stations.
  *
@@ -1907,13 +2095,14 @@ enum nl80211_commands {
  *	until the channel switch event.
  * @NL80211_ATTR_CH_SWITCH_BLOCK_TX: flag attribute specifying that transmission
  *	must be blocked on the current channel (before the channel switch
- *	operation).
+ *	operation). Also included in the channel switch started event if quiet
+ *	was requested by the AP.
  * @NL80211_ATTR_CSA_IES: Nested set of attributes containing the IE information
  *	for the time while performing a channel switch.
- * @NL80211_ATTR_CSA_C_OFF_BEACON: An array of offsets (u16) to the channel
- *	switch counters in the beacons tail (%NL80211_ATTR_BEACON_TAIL).
- * @NL80211_ATTR_CSA_C_OFF_PRESP: An array of offsets (u16) to the channel
- *	switch counters in the probe response (%NL80211_ATTR_PROBE_RESP).
+ * @NL80211_ATTR_CNTDWN_OFFS_BEACON: An array of offsets (u16) to the channel
+ *	switch or color change counters in the beacons tail (%NL80211_ATTR_BEACON_TAIL).
+ * @NL80211_ATTR_CNTDWN_OFFS_PRESP: An array of offsets (u16) to the channel
+ *	switch or color change counters in the probe response (%NL80211_ATTR_PROBE_RESP).
  *
  * @NL80211_ATTR_RXMGMT_FLAGS: flags for nl80211_send_mgmt(), u32.
  *	As specified in the &enum nl80211_rxmgmt_flags.
@@ -1921,7 +2110,7 @@ enum nl80211_commands {
  * @NL80211_ATTR_STA_SUPPORTED_CHANNELS: array of supported channels.
  *
  * @NL80211_ATTR_STA_SUPPORTED_OPER_CLASSES: array of supported
- *      supported operating classes.
+ *      operating classes.
  *
  * @NL80211_ATTR_HANDLE_DFS: A flag indicating whether user space
  *	controls DFS operation in IBSS mode. If the flag is included in
@@ -2167,7 +2356,7 @@ enum nl80211_commands {
  *
  * @NL80211_ATTR_SCHED_SCAN_RSSI_ADJUST: When present the RSSI level for BSSs in
  *	the specified band is to be adjusted before doing
- *	%NL80211_ATTR_SCHED_SCAN_RELATIVE_RSSI based comparision to figure out
+ *	%NL80211_ATTR_SCHED_SCAN_RELATIVE_RSSI based comparison to figure out
  *	better BSSs. The attribute value is a packed structure
  *	value as specified by &struct nl80211_bss_select_rssi_adjust.
  *
@@ -2199,10 +2388,11 @@ enum nl80211_commands {
  *
  * @NL80211_ATTR_PMK: attribute for passing PMK key material. Used with
  *	%NL80211_CMD_SET_PMKSA for the PMKSA identified by %NL80211_ATTR_PMKID.
- *	For %NL80211_CMD_CONNECT it is used to provide PSK for offloading 4-way
- *	handshake for WPA/WPA2-PSK networks. For 802.1X authentication it is
- *	used with %NL80211_CMD_SET_PMK. For offloaded FT support this attribute
- *	specifies the PMK-R0 if NL80211_ATTR_PMKR0_NAME is included as well.
+ *	For %NL80211_CMD_CONNECT and %NL80211_CMD_START_AP it is used to provide
+ *	PSK for offloading 4-way handshake for WPA/WPA2-PSK networks. For 802.1X
+ *	authentication it is used with %NL80211_CMD_SET_PMK. For offloaded FT
+ *	support this attribute specifies the PMK-R0 if NL80211_ATTR_PMKR0_NAME
+ *	is included as well.
  *
  * @NL80211_ATTR_SCHED_SCAN_MULTI: flag attribute which user-space shall use to
  *	indicate that it supports multiple active scheduled scan requests.
@@ -2220,10 +2410,10 @@ enum nl80211_commands {
  *     &enum nl80211_external_auth_action value). This is used with the
  *     %NL80211_CMD_EXTERNAL_AUTH request event.
  * @NL80211_ATTR_EXTERNAL_AUTH_SUPPORT: Flag attribute indicating that the user
- *     space supports external authentication. This attribute shall be used
- *     only with %NL80211_CMD_CONNECT request. The driver may offload
- *     authentication processing to user space if this capability is indicated
- *     in NL80211_CMD_CONNECT requests from the user space.
+ *	space supports external authentication. This attribute shall be used
+ *	with %NL80211_CMD_CONNECT and %NL80211_CMD_START_AP request. The driver
+ *	may offload authentication processing to user space if this capability
+ *	is indicated in the respective requests from the user space.
  *
  * @NL80211_ATTR_NSS: Station's New/updated  RX_NSS value notified using this
  *	u8 attribute. This is used with %NL80211_CMD_STA_OPMODE_CHANGED.
@@ -2232,7 +2422,7 @@ enum nl80211_commands {
  *      nl80211_txq_stats)
  * @NL80211_ATTR_TXQ_LIMIT: Total packet limit for the TXQ queues for this phy.
  *      The smaller of this and the memory limit is enforced.
- * @NL80211_ATTR_TXQ_MEMORY_LIMIT: Total memory memory limit (in bytes) for the
+ * @NL80211_ATTR_TXQ_MEMORY_LIMIT: Total memory limit (in bytes) for the
  *      TXQ queues for this phy. The smaller of this and the packet limit is
  *      enforced.
  * @NL80211_ATTR_TXQ_QUANTUM: TXQ scheduler quantum (bytes). Number of bytes
@@ -2241,6 +2431,135 @@ enum nl80211_commands {
  *	association request when used with NL80211_CMD_NEW_STATION). Can be set
  *	only if %NL80211_STA_FLAG_WME is set.
  *
+ * @NL80211_ATTR_FTM_RESPONDER: nested attribute which user-space can include
+ *	in %NL80211_CMD_START_AP or %NL80211_CMD_SET_BEACON for fine timing
+ *	measurement (FTM) responder functionality and containing parameters as
+ *	possible, see &enum nl80211_ftm_responder_attr
+ *
+ * @NL80211_ATTR_FTM_RESPONDER_STATS: Nested attribute with FTM responder
+ *	statistics, see &enum nl80211_ftm_responder_stats.
+ *
+ * @NL80211_ATTR_TIMEOUT: Timeout for the given operation in milliseconds (u32),
+ *	if the attribute is not given no timeout is requested. Note that 0 is an
+ *	invalid value.
+ *
+ * @NL80211_ATTR_PEER_MEASUREMENTS: peer measurements request (and result)
+ *	data, uses nested attributes specified in
+ *	&enum nl80211_peer_measurement_attrs.
+ *	This is also used for capability advertisement in the wiphy information,
+ *	with the appropriate sub-attributes.
+ *
+ * @NL80211_ATTR_AIRTIME_WEIGHT: Station's weight when scheduled by the airtime
+ *	scheduler.
+ *
+ * @NL80211_ATTR_STA_TX_POWER_SETTING: Transmit power setting type (u8) for
+ *	station associated with the AP. See &enum nl80211_tx_power_setting for
+ *	possible values.
+ * @NL80211_ATTR_STA_TX_POWER: Transmit power level (s16) in dBm units. This
+ *	allows to set Tx power for a station. If this attribute is not included,
+ *	the default per-interface tx power setting will be overriding. Driver
+ *	should be picking up the lowest tx power, either tx power per-interface
+ *	or per-station.
+ *
+ * @NL80211_ATTR_SAE_PASSWORD: attribute for passing SAE password material. It
+ *	is used with %NL80211_CMD_CONNECT to provide password for offloading
+ *	SAE authentication for WPA3-Personal networks.
+ *
+ * @NL80211_ATTR_TWT_RESPONDER: Enable target wait time responder support.
+ *
+ * @NL80211_ATTR_HE_OBSS_PD: nested attribute for OBSS Packet Detection
+ *	functionality.
+ *
+ * @NL80211_ATTR_WIPHY_EDMG_CHANNELS: bitmap that indicates the 2.16 GHz
+ *	channel(s) that are allowed to be used for EDMG transmissions.
+ *	Defined by IEEE P802.11ay/D4.0 section 9.4.2.251. (u8 attribute)
+ * @NL80211_ATTR_WIPHY_EDMG_BW_CONFIG: Channel BW Configuration subfield encodes
+ *	the allowed channel bandwidth configurations. (u8 attribute)
+ *	Defined by IEEE P802.11ay/D4.0 section 9.4.2.251, Table 13.
+ *
+ * @NL80211_ATTR_VLAN_ID: VLAN ID (1..4094) for the station and VLAN group key
+ *	(u16).
+ *
+ * @NL80211_ATTR_HE_BSS_COLOR: nested attribute for BSS Color Settings.
+ *
+ * @NL80211_ATTR_IFTYPE_AKM_SUITES: nested array attribute, with each entry
+ *	using attributes from &enum nl80211_iftype_akm_attributes. This
+ *	attribute is sent in a response to %NL80211_CMD_GET_WIPHY indicating
+ *	supported AKM suites capability per interface. AKMs advertised in
+ *	%NL80211_ATTR_AKM_SUITES are default capabilities if AKM suites not
+ *	advertised for a specific interface type.
+ *
+ * @NL80211_ATTR_TID_CONFIG: TID specific configuration in a
+ *	nested attribute with &enum nl80211_tid_config_attr sub-attributes;
+ *	on output (in wiphy attributes) it contains only the feature sub-
+ *	attributes.
+ *
+ * @NL80211_ATTR_CONTROL_PORT_NO_PREAUTH: disable preauth frame rx on control
+ *	port in order to forward/receive them as ordinary data frames.
+ *
+ * @NL80211_ATTR_PMK_LIFETIME: Maximum lifetime for PMKSA in seconds (u32,
+ *	dot11RSNAConfigPMKReauthThreshold; 0 is not a valid value).
+ *	An optional parameter configured through %NL80211_CMD_SET_PMKSA.
+ *	Drivers that trigger roaming need to know the lifetime of the
+ *	configured PMKSA for triggering the full vs. PMKSA caching based
+ *	authentication. This timeout helps authentication methods like SAE,
+ *	where PMK gets updated only by going through a full (new SAE)
+ *	authentication instead of getting updated during an association for EAP
+ *	authentication. No new full authentication within the PMK expiry shall
+ *	result in a disassociation at the end of the lifetime.
+ *
+ * @NL80211_ATTR_PMK_REAUTH_THRESHOLD: Reauthentication threshold time, in
+ *	terms of percentage of %NL80211_ATTR_PMK_LIFETIME
+ *	(u8, dot11RSNAConfigPMKReauthThreshold, 1..100). This is an optional
+ *	parameter configured through %NL80211_CMD_SET_PMKSA. Requests the
+ *	driver to trigger a full authentication roam (without PMKSA caching)
+ *	after the reauthentication threshold time, but before the PMK lifetime
+ *	has expired.
+ *
+ *	Authentication methods like SAE need to be able to generate a new PMKSA
+ *	entry without having to force a disconnection after the PMK timeout. If
+ *	no roaming occurs between the reauth threshold and PMK expiration,
+ *	disassociation is still forced.
+ * @NL80211_ATTR_RECEIVE_MULTICAST: multicast flag for the
+ *	%NL80211_CMD_REGISTER_FRAME command, see the description there.
+ * @NL80211_ATTR_WIPHY_FREQ_OFFSET: offset of the associated
+ *	%NL80211_ATTR_WIPHY_FREQ in positive KHz. Only valid when supplied with
+ *	an %NL80211_ATTR_WIPHY_FREQ_OFFSET.
+ * @NL80211_ATTR_CENTER_FREQ1_OFFSET: Center frequency offset in KHz for the
+ *	first channel segment specified in %NL80211_ATTR_CENTER_FREQ1.
+ * @NL80211_ATTR_SCAN_FREQ_KHZ: nested attribute with KHz frequencies
+ *
+ * @NL80211_ATTR_HE_6GHZ_CAPABILITY: HE 6 GHz Band Capability element (from
+ *	association request when used with NL80211_CMD_NEW_STATION).
+ *
+ * @NL80211_ATTR_FILS_DISCOVERY: Optional parameter to configure FILS
+ *	discovery. It is a nested attribute, see
+ *	&enum nl80211_fils_discovery_attributes.
+ *
+ * @NL80211_ATTR_UNSOL_BCAST_PROBE_RESP: Optional parameter to configure
+ *	unsolicited broadcast probe response. It is a nested attribute, see
+ *	&enum nl80211_unsol_bcast_probe_resp_attributes.
+ *
+ * @NL80211_ATTR_S1G_CAPABILITY: S1G Capability information element (from
+ *	association request when used with NL80211_CMD_NEW_STATION)
+ * @NL80211_ATTR_S1G_CAPABILITY_MASK: S1G Capability Information element
+ *	override mask. Used with NL80211_ATTR_S1G_CAPABILITY in
+ *	NL80211_CMD_ASSOCIATE or NL80211_CMD_CONNECT.
+ *
+ * @NL80211_ATTR_SAE_PWE: Indicates the mechanism(s) allowed for SAE PWE
+ *	derivation in WPA3-Personal networks which are using SAE authentication.
+ *	This is a u8 attribute that encapsulates one of the values from
+ *	&enum nl80211_sae_pwe_mechanism.
+ *
+ * @NL80211_ATTR_SAR_SPEC: SAR power limitation specification when
+ *	used with %NL80211_CMD_SET_SAR_SPECS. The message contains fields
+ *	of %nl80211_sar_attrs which specifies the sar type and related
+ *	sar specs. Sar specs contains array of %nl80211_sar_specs_attrs.
+ *
+ * @NL80211_ATTR_RECONNECT_REQUESTED: flag attribute, used with deauth and
+ *	disassoc events to indicate that an immediate reconnect to the AP
+ *	is desired.
+ *
  * @NUM_NL80211_ATTR: total number of nl80211_attrs available
  * @NL80211_ATTR_MAX: highest attribute number currently defined
  * @__NL80211_ATTR_AFTER_LAST: internal use
@@ -2547,8 +2866,8 @@ enum nl80211_attrs {
 	NL80211_ATTR_CH_SWITCH_COUNT,
 	NL80211_ATTR_CH_SWITCH_BLOCK_TX,
 	NL80211_ATTR_CSA_IES,
-	NL80211_ATTR_CSA_C_OFF_BEACON,
-	NL80211_ATTR_CSA_C_OFF_PRESP,
+	NL80211_ATTR_CNTDWN_OFFS_BEACON,
+	NL80211_ATTR_CNTDWN_OFFS_PRESP,
 
 	NL80211_ATTR_RXMGMT_FLAGS,
 
@@ -2682,6 +3001,66 @@ enum nl80211_attrs {
 
 	NL80211_ATTR_HE_CAPABILITY,
 
+	NL80211_ATTR_FTM_RESPONDER,
+
+	NL80211_ATTR_FTM_RESPONDER_STATS,
+
+	NL80211_ATTR_TIMEOUT,
+
+	NL80211_ATTR_PEER_MEASUREMENTS,
+
+	NL80211_ATTR_AIRTIME_WEIGHT,
+	NL80211_ATTR_STA_TX_POWER_SETTING,
+	NL80211_ATTR_STA_TX_POWER,
+
+	NL80211_ATTR_SAE_PASSWORD,
+
+	NL80211_ATTR_TWT_RESPONDER,
+
+	NL80211_ATTR_HE_OBSS_PD,
+
+	NL80211_ATTR_WIPHY_EDMG_CHANNELS,
+	NL80211_ATTR_WIPHY_EDMG_BW_CONFIG,
+
+	NL80211_ATTR_VLAN_ID,
+
+	NL80211_ATTR_HE_BSS_COLOR,
+
+	NL80211_ATTR_IFTYPE_AKM_SUITES,
+
+	NL80211_ATTR_TID_CONFIG,
+
+	NL80211_ATTR_CONTROL_PORT_NO_PREAUTH,
+
+	NL80211_ATTR_PMK_LIFETIME,
+	NL80211_ATTR_PMK_REAUTH_THRESHOLD,
+
+	NL80211_ATTR_RECEIVE_MULTICAST,
+	NL80211_ATTR_WIPHY_FREQ_OFFSET,
+	NL80211_ATTR_CENTER_FREQ1_OFFSET,
+	NL80211_ATTR_SCAN_FREQ_KHZ,
+
+	NL80211_ATTR_HE_6GHZ_CAPABILITY,
+
+	NL80211_ATTR_FILS_DISCOVERY,
+
+	NL80211_ATTR_UNSOL_BCAST_PROBE_RESP,
+
+	NL80211_ATTR_S1G_CAPABILITY,
+	NL80211_ATTR_S1G_CAPABILITY_MASK,
+
+	NL80211_ATTR_SAE_PWE,
+
+	NL80211_ATTR_RECONNECT_REQUESTED,
+
+	NL80211_ATTR_SAR_SPEC,
+
+	NL80211_ATTR_DISABLE_HE,
+
+	/* UBNT Attributes
+	* include userspace $(STAGING_DIR)/usr/include/linux/nl80211_actual.h */
+	NL80211_ATTR_STA_ROAMED,
+
 	/* add attributes here, update the policy in nl80211.c */
 
 	__NL80211_ATTR_AFTER_LAST,
@@ -2694,6 +3073,8 @@ enum nl80211_attrs {
 #define	NL80211_ATTR_MESH_PARAMS NL80211_ATTR_MESH_CONFIG
 #define NL80211_ATTR_IFACE_SOCKET_OWNER NL80211_ATTR_SOCKET_OWNER
 #define NL80211_ATTR_SAE_DATA NL80211_ATTR_AUTH_DATA
+#define NL80211_ATTR_CSA_C_OFF_BEACON NL80211_ATTR_CNTDWN_OFFS_BEACON
+#define NL80211_ATTR_CSA_C_OFF_PRESP NL80211_ATTR_CNTDWN_OFFS_PRESP
 
 /*
  * Allow user space programs to use #ifdef on new attributes by defining them
@@ -2725,7 +3106,7 @@ enum nl80211_attrs {
 
 #define NL80211_MAX_SUPP_RATES			32
 #define NL80211_MAX_SUPP_HT_RATES		77
-#define NL80211_MAX_SUPP_REG_RULES		64
+#define NL80211_MAX_SUPP_REG_RULES		128
 #define NL80211_TKIP_DATA_OFFSET_ENCR_KEY	0
 #define NL80211_TKIP_DATA_OFFSET_TX_MIC_KEY	16
 #define NL80211_TKIP_DATA_OFFSET_RX_MIC_KEY	24
@@ -2872,6 +3253,18 @@ enum nl80211_he_gi {
 };
 
 /**
+ * enum nl80211_he_ltf - HE long training field
+ * @NL80211_RATE_INFO_HE_1xLTF: 3.2 usec
+ * @NL80211_RATE_INFO_HE_2xLTF: 6.4 usec
+ * @NL80211_RATE_INFO_HE_4xLTF: 12.8 usec
+ */
+enum nl80211_he_ltf {
+	NL80211_RATE_INFO_HE_1XLTF,
+	NL80211_RATE_INFO_HE_2XLTF,
+	NL80211_RATE_INFO_HE_4XLTF,
+};
+
+/**
  * enum nl80211_he_ru_alloc - HE RU allocation values
  * @NL80211_RATE_INFO_HE_RU_ALLOC_26: 26-tone RU allocation
  * @NL80211_RATE_INFO_HE_RU_ALLOC_52: 52-tone RU allocation
@@ -3050,8 +3443,23 @@ enum nl80211_sta_bss_param {
  *	received from the station (u64, usec)
  * @NL80211_STA_INFO_PAD: attribute used for padding for 64-bit alignment
  * @NL80211_STA_INFO_ACK_SIGNAL: signal strength of the last ACK frame(u8, dBm)
- * @NL80211_STA_INFO_DATA_ACK_SIGNAL_AVG: avg signal strength of (data)
- *	ACK frame (s8, dBm)
+ * @NL80211_STA_INFO_ACK_SIGNAL_AVG: avg signal strength of ACK frames (s8, dBm)
+ * @NL80211_STA_INFO_RX_MPDUS: total number of received packets (MPDUs)
+ *	(u32, from this station)
+ * @NL80211_STA_INFO_FCS_ERROR_COUNT: total number of packets (MPDUs) received
+ *	with an FCS error (u32, from this station). This count may not include
+ *	some packets with an FCS error due to TA corruption. Hence this counter
+ *	might not be fully accurate.
+ * @NL80211_STA_INFO_CONNECTED_TO_GATE: set to true if STA has a path to a
+ *	mesh gate (u8, 0 or 1)
+ * @NL80211_STA_INFO_TX_DURATION: aggregate PPDU duration for all frames
+ *	sent to the station (u64, usec)
+ * @NL80211_STA_INFO_AIRTIME_WEIGHT: current airtime weight for station (u16)
+ * @NL80211_STA_INFO_AIRTIME_LINK_METRIC: airtime link metric for mesh station
+ * @NL80211_STA_INFO_ASSOC_AT_BOOTTIME: Timestamp (CLOCK_BOOTTIME, nanoseconds)
+ *	of STA's association
+ * @NL80211_STA_INFO_CONNECTED_TO_AS: set to true if STA has a path to a
+ *	authentication server (u8, 0 or 1)
  * @__NL80211_STA_INFO_AFTER_LAST: internal
  * @NL80211_STA_INFO_MAX: highest possible station info attribute
  */
@@ -3091,13 +3499,25 @@ enum nl80211_sta_info {
 	NL80211_STA_INFO_RX_DURATION,
 	NL80211_STA_INFO_PAD,
 	NL80211_STA_INFO_ACK_SIGNAL,
-	NL80211_STA_INFO_DATA_ACK_SIGNAL_AVG,
+	NL80211_STA_INFO_ACK_SIGNAL_AVG,
+	NL80211_STA_INFO_RX_MPDUS,
+	NL80211_STA_INFO_FCS_ERROR_COUNT,
+	NL80211_STA_INFO_CONNECTED_TO_GATE,
+	NL80211_STA_INFO_TX_DURATION,
+	NL80211_STA_INFO_AIRTIME_WEIGHT,
+	NL80211_STA_INFO_AIRTIME_LINK_METRIC,
+	NL80211_STA_INFO_ASSOC_AT_BOOTTIME,
+	NL80211_STA_INFO_CONNECTED_TO_AS,
 
 	/* keep last */
 	__NL80211_STA_INFO_AFTER_LAST,
 	NL80211_STA_INFO_MAX = __NL80211_STA_INFO_AFTER_LAST - 1
 };
 
+/* we renamed this - stay compatible */
+#define NL80211_STA_INFO_DATA_ACK_SIGNAL_AVG NL80211_STA_INFO_ACK_SIGNAL_AVG
+
+
 /**
  * enum nl80211_tid_stats - per TID statistics attributes
  * @__NL80211_TID_STATS_INVALID: attribute number 0 is reserved
@@ -3197,8 +3617,10 @@ enum nl80211_mpath_flags {
  * 	&enum nl80211_mpath_flags;
  * @NL80211_MPATH_INFO_DISCOVERY_TIMEOUT: total path discovery timeout, in msec
  * @NL80211_MPATH_INFO_DISCOVERY_RETRIES: mesh path discovery retries
+ * @NL80211_MPATH_INFO_HOP_COUNT: hop count to destination
+ * @NL80211_MPATH_INFO_PATH_CHANGE: total number of path changes to destination
  * @NL80211_MPATH_INFO_MAX: highest mesh path information attribute number
- *	currently defind
+ *	currently defined
  * @__NL80211_MPATH_INFO_AFTER_LAST: internal use
  */
 enum nl80211_mpath_info {
@@ -3210,6 +3632,8 @@ enum nl80211_mpath_info {
 	NL80211_MPATH_INFO_FLAGS,
 	NL80211_MPATH_INFO_DISCOVERY_TIMEOUT,
 	NL80211_MPATH_INFO_DISCOVERY_RETRIES,
+	NL80211_MPATH_INFO_HOP_COUNT,
+	NL80211_MPATH_INFO_PATH_CHANGE,
 
 	/* keep last */
 	__NL80211_MPATH_INFO_AFTER_LAST,
@@ -3232,6 +3656,8 @@ enum nl80211_mpath_info {
  *     defined in HE capabilities IE
  * @NL80211_BAND_IFTYPE_ATTR_MAX: highest band HE capability attribute currently
  *     defined
+ * @NL80211_BAND_IFTYPE_ATTR_HE_6GHZ_CAPA: HE 6GHz band capabilities (__le16),
+ *	given for all 6 GHz band channels
  * @__NL80211_BAND_IFTYPE_ATTR_AFTER_LAST: internal use
  */
 enum nl80211_band_iftype_attr {
@@ -3242,6 +3668,7 @@ enum nl80211_band_iftype_attr {
 	NL80211_BAND_IFTYPE_ATTR_HE_CAP_PHY,
 	NL80211_BAND_IFTYPE_ATTR_HE_CAP_MCS_SET,
 	NL80211_BAND_IFTYPE_ATTR_HE_CAP_PPE,
+	NL80211_BAND_IFTYPE_ATTR_HE_6GHZ_CAPA,
 
 	/* keep last */
 	__NL80211_BAND_IFTYPE_ATTR_AFTER_LAST,
@@ -3265,6 +3692,12 @@ enum nl80211_band_iftype_attr {
  * @NL80211_BAND_ATTR_VHT_CAPA: VHT capabilities, as in the HT information IE
  * @NL80211_BAND_ATTR_IFTYPE_DATA: nested array attribute, with each entry using
  *	attributes from &enum nl80211_band_iftype_attr
+ * @NL80211_BAND_ATTR_EDMG_CHANNELS: bitmap that indicates the 2.16 GHz
+ *	channel(s) that are allowed to be used for EDMG transmissions.
+ *	Defined by IEEE P802.11ay/D4.0 section 9.4.2.251.
+ * @NL80211_BAND_ATTR_EDMG_BW_CONFIG: Channel BW Configuration subfield encodes
+ *	the allowed channel bandwidth configurations.
+ *	Defined by IEEE P802.11ay/D4.0 section 9.4.2.251, Table 13.
  * @NL80211_BAND_ATTR_MAX: highest band attribute currently defined
  * @__NL80211_BAND_ATTR_AFTER_LAST: internal use
  */
@@ -3282,6 +3715,9 @@ enum nl80211_band_attr {
 	NL80211_BAND_ATTR_VHT_CAPA,
 	NL80211_BAND_ATTR_IFTYPE_DATA,
 
+	NL80211_BAND_ATTR_EDMG_CHANNELS,
+	NL80211_BAND_ATTR_EDMG_BW_CONFIG,
+
 	/* keep last */
 	__NL80211_BAND_ATTR_AFTER_LAST,
 	NL80211_BAND_ATTR_MAX = __NL80211_BAND_ATTR_AFTER_LAST - 1
@@ -3364,6 +3800,19 @@ enum nl80211_wmm_rule {
  * @NL80211_FREQUENCY_ATTR_WMM: this channel has wmm limitations.
  *	This is a nested attribute that contains the wmm limitation per AC.
  *	(see &enum nl80211_wmm_rule)
+ * @NL80211_FREQUENCY_ATTR_NO_HE: HE operation is not allowed on this channel
+ *	in current regulatory domain.
+ * @NL80211_FREQUENCY_ATTR_OFFSET: frequency offset in KHz
+ * @NL80211_FREQUENCY_ATTR_1MHZ: 1 MHz operation is allowed
+ *	on this channel in current regulatory domain.
+ * @NL80211_FREQUENCY_ATTR_2MHZ: 2 MHz operation is allowed
+ *	on this channel in current regulatory domain.
+ * @NL80211_FREQUENCY_ATTR_4MHZ: 4 MHz operation is allowed
+ *	on this channel in current regulatory domain.
+ * @NL80211_FREQUENCY_ATTR_8MHZ: 8 MHz operation is allowed
+ *	on this channel in current regulatory domain.
+ * @NL80211_FREQUENCY_ATTR_16MHZ: 16 MHz operation is allowed
+ *	on this channel in current regulatory domain.
  * @NL80211_FREQUENCY_ATTR_MAX: highest frequency attribute number
  *	currently defined
  * @__NL80211_FREQUENCY_ATTR_AFTER_LAST: internal use
@@ -3393,6 +3842,13 @@ enum nl80211_frequency_attr {
 	NL80211_FREQUENCY_ATTR_NO_20MHZ,
 	NL80211_FREQUENCY_ATTR_NO_10MHZ,
 	NL80211_FREQUENCY_ATTR_WMM,
+	NL80211_FREQUENCY_ATTR_NO_HE,
+	NL80211_FREQUENCY_ATTR_OFFSET,
+	NL80211_FREQUENCY_ATTR_1MHZ,
+	NL80211_FREQUENCY_ATTR_2MHZ,
+	NL80211_FREQUENCY_ATTR_4MHZ,
+	NL80211_FREQUENCY_ATTR_8MHZ,
+	NL80211_FREQUENCY_ATTR_16MHZ,
 
 	/* keep last */
 	__NL80211_FREQUENCY_ATTR_AFTER_LAST,
@@ -3538,6 +3994,14 @@ enum nl80211_reg_rule_attr {
  *	value as specified by &struct nl80211_bss_select_rssi_adjust.
  * @NL80211_SCHED_SCAN_MATCH_ATTR_BSSID: BSSID to be used for matching
  *	(this cannot be used together with SSID).
+ * @NL80211_SCHED_SCAN_MATCH_PER_BAND_RSSI: Nested attribute that carries the
+ *	band specific minimum rssi thresholds for the bands defined in
+ *	enum nl80211_band. The minimum rssi threshold value(s32) specific to a
+ *	band shall be encapsulated in attribute with type value equals to one
+ *	of the NL80211_BAND_* defined in enum nl80211_band. For example, the
+ *	minimum rssi threshold value for 2.4GHZ band shall be encapsulated
+ *	within an attribute of type NL80211_BAND_2GHZ. And one or more of such
+ *	attributes will be nested within this attribute.
  * @NL80211_SCHED_SCAN_MATCH_ATTR_MAX: highest scheduled scan filter
  *	attribute number currently defined
  * @__NL80211_SCHED_SCAN_MATCH_ATTR_AFTER_LAST: internal use
@@ -3550,6 +4014,7 @@ enum nl80211_sched_scan_match_attr {
 	NL80211_SCHED_SCAN_MATCH_ATTR_RELATIVE_RSSI,
 	NL80211_SCHED_SCAN_MATCH_ATTR_RSSI_ADJUST,
 	NL80211_SCHED_SCAN_MATCH_ATTR_BSSID,
+	NL80211_SCHED_SCAN_MATCH_PER_BAND_RSSI,
 
 	/* keep last */
 	__NL80211_SCHED_SCAN_MATCH_ATTR_AFTER_LAST,
@@ -3581,6 +4046,7 @@ enum nl80211_sched_scan_match_attr {
  * @NL80211_RRF_NO_HT40PLUS: channels can't be used in HT40+ operation
  * @NL80211_RRF_NO_80MHZ: 80MHz operation not allowed
  * @NL80211_RRF_NO_160MHZ: 160MHz operation not allowed
+ * @NL80211_RRF_NO_HE: HE operation not allowed
  */
 enum nl80211_reg_rule_flags {
 	NL80211_RRF_NO_OFDM		= 1<<0,
@@ -3598,6 +4064,7 @@ enum nl80211_reg_rule_flags {
 	NL80211_RRF_NO_HT40PLUS		= 1<<14,
 	NL80211_RRF_NO_80MHZ		= 1<<15,
 	NL80211_RRF_NO_160MHZ		= 1<<16,
+	NL80211_RRF_NO_HE		= 1<<17,
 };
 
 #define NL80211_RRF_PASSIVE_SCAN	NL80211_RRF_NO_IR
@@ -3671,8 +4138,11 @@ enum nl80211_user_reg_hint_type {
  * @NL80211_SURVEY_INFO_TIME_SCAN: time the radio spent for scan
  *	(on this channel or globally)
  * @NL80211_SURVEY_INFO_PAD: attribute used for padding for 64-bit alignment
+ * @NL80211_SURVEY_INFO_TIME_BSS_RX: amount of time the radio spent
+ *	receiving frames destined to the local BSS
  * @NL80211_SURVEY_INFO_MAX: highest survey info attribute number
  *	currently defined
+ * @NL80211_SURVEY_INFO_FREQUENCY_OFFSET: center frequency offset in KHz
  * @__NL80211_SURVEY_INFO_AFTER_LAST: internal use
  */
 enum nl80211_survey_info {
@@ -3687,6 +4157,8 @@ enum nl80211_survey_info {
 	NL80211_SURVEY_INFO_TIME_TX,
 	NL80211_SURVEY_INFO_TIME_SCAN,
 	NL80211_SURVEY_INFO_PAD,
+	NL80211_SURVEY_INFO_TIME_BSS_RX,
+	NL80211_SURVEY_INFO_FREQUENCY_OFFSET,
 
 	/* keep last */
 	__NL80211_SURVEY_INFO_AFTER_LAST,
@@ -3867,6 +4339,21 @@ enum nl80211_mesh_power_mode {
  *	remove it from the STA's list of peers. You may set this to 0 to disable
  *	the removal of the STA. Default is 30 minutes.
  *
+ * @NL80211_MESHCONF_CONNECTED_TO_GATE: If set to true then this mesh STA
+ *	will advertise that it is connected to a gate in the mesh formation
+ *	field.  If left unset then the mesh formation field will only
+ *	advertise such if there is an active root mesh path.
+ *
+ * @NL80211_MESHCONF_NOLEARN: Try to avoid multi-hop path discovery (e.g.
+ *      PREQ/PREP for HWMP) if the destination is a direct neighbor. Note that
+ *      this might not be the optimal decision as a multi-hop route might be
+ *      better. So if using this setting you will likely also want to disable
+ *      dot11MeshForwarding and use another mesh routing protocol on top.
+ *
+ * @NL80211_MESHCONF_CONNECTED_TO_AS: If set to true then this mesh STA
+ *	will advertise that it is connected to a authentication server
+ *	in the mesh formation field.
+ *
  * @__NL80211_MESHCONF_ATTR_AFTER_LAST: internal use
  */
 enum nl80211_meshconf_params {
@@ -3899,6 +4386,9 @@ enum nl80211_meshconf_params {
 	NL80211_MESHCONF_POWER_MODE,
 	NL80211_MESHCONF_AWAKE_WINDOW,
 	NL80211_MESHCONF_PLINK_TIMEOUT,
+	NL80211_MESHCONF_CONNECTED_TO_GATE,
+	NL80211_MESHCONF_NOLEARN,
+	NL80211_MESHCONF_CONNECTED_TO_AS,
 
 	/* keep last */
 	__NL80211_MESHCONF_ATTR_AFTER_LAST,
@@ -4029,6 +4519,27 @@ enum nl80211_channel_type {
 };
 
 /**
+ * enum nl80211_key_mode - Key mode
+ *
+ * @NL80211_KEY_RX_TX: (Default)
+ *	Key can be used for Rx and Tx immediately
+ *
+ * The following modes can only be selected for unicast keys and when the
+ * driver supports @NL80211_EXT_FEATURE_EXT_KEY_ID:
+ *
+ * @NL80211_KEY_NO_TX: Only allowed in combination with @NL80211_CMD_NEW_KEY:
+ *	Unicast key can only be used for Rx, Tx not allowed, yet
+ * @NL80211_KEY_SET_TX: Only allowed in combination with @NL80211_CMD_SET_KEY:
+ *	The unicast key identified by idx and mac is cleared for Tx and becomes
+ *	the preferred Tx key for the station.
+ */
+enum nl80211_key_mode {
+	NL80211_KEY_RX_TX,
+	NL80211_KEY_NO_TX,
+	NL80211_KEY_SET_TX
+};
+
+/**
  * enum nl80211_chan_width - channel width definitions
  *
  * These values are used with the %NL80211_ATTR_CHANNEL_WIDTH
@@ -4046,6 +4557,11 @@ enum nl80211_channel_type {
  *	attribute must be provided as well
  * @NL80211_CHAN_WIDTH_5: 5 MHz OFDM channel
  * @NL80211_CHAN_WIDTH_10: 10 MHz OFDM channel
+ * @NL80211_CHAN_WIDTH_1: 1 MHz OFDM channel
+ * @NL80211_CHAN_WIDTH_2: 2 MHz OFDM channel
+ * @NL80211_CHAN_WIDTH_4: 4 MHz OFDM channel
+ * @NL80211_CHAN_WIDTH_8: 8 MHz OFDM channel
+ * @NL80211_CHAN_WIDTH_16: 16 MHz OFDM channel
  */
 enum nl80211_chan_width {
 	NL80211_CHAN_WIDTH_20_NOHT,
@@ -4056,6 +4572,11 @@ enum nl80211_chan_width {
 	NL80211_CHAN_WIDTH_160,
 	NL80211_CHAN_WIDTH_5,
 	NL80211_CHAN_WIDTH_10,
+	NL80211_CHAN_WIDTH_1,
+	NL80211_CHAN_WIDTH_2,
+	NL80211_CHAN_WIDTH_4,
+	NL80211_CHAN_WIDTH_8,
+	NL80211_CHAN_WIDTH_16,
 };
 
 /**
@@ -4066,11 +4587,15 @@ enum nl80211_chan_width {
  * @NL80211_BSS_CHAN_WIDTH_20: control channel is 20 MHz wide or compatible
  * @NL80211_BSS_CHAN_WIDTH_10: control channel is 10 MHz wide
  * @NL80211_BSS_CHAN_WIDTH_5: control channel is 5 MHz wide
+ * @NL80211_BSS_CHAN_WIDTH_1: control channel is 1 MHz wide
+ * @NL80211_BSS_CHAN_WIDTH_2: control channel is 2 MHz wide
  */
 enum nl80211_bss_scan_width {
 	NL80211_BSS_CHAN_WIDTH_20,
 	NL80211_BSS_CHAN_WIDTH_10,
 	NL80211_BSS_CHAN_WIDTH_5,
+	NL80211_BSS_CHAN_WIDTH_1,
+	NL80211_BSS_CHAN_WIDTH_2,
 };
 
 /**
@@ -4122,6 +4647,7 @@ enum nl80211_bss_scan_width {
  * @NL80211_BSS_CHAIN_SIGNAL: per-chain signal strength of last BSS update.
  *	Contains a nested array of signal strength attributes (u8, dBm),
  *	using the nesting index as the antenna number.
+ * @NL80211_BSS_FREQUENCY_OFFSET: frequency offset in KHz
  * @__NL80211_BSS_AFTER_LAST: internal
  * @NL80211_BSS_MAX: highest BSS attribute
  */
@@ -4146,6 +4672,7 @@ enum nl80211_bss {
 	NL80211_BSS_PARENT_TSF,
 	NL80211_BSS_PARENT_BSSID,
 	NL80211_BSS_CHAIN_SIGNAL,
+	NL80211_BSS_FREQUENCY_OFFSET,
 
 	/* keep last */
 	__NL80211_BSS_AFTER_LAST,
@@ -4233,6 +4760,7 @@ enum nl80211_mfp {
 enum nl80211_wpa_versions {
 	NL80211_WPA_VERSION_1 = 1 << 0,
 	NL80211_WPA_VERSION_2 = 1 << 1,
+	NL80211_WPA_VERSION_3 = 1 << 2,
 };
 
 /**
@@ -4271,6 +4799,10 @@ enum nl80211_key_default_types {
  * @NL80211_KEY_DEFAULT_TYPES: A nested attribute containing flags
  *	attributes, specifying what a key should be set as default as.
  *	See &enum nl80211_key_default_types.
+ * @NL80211_KEY_MODE: the mode from enum nl80211_key_mode.
+ *	Defaults to @NL80211_KEY_RX_TX.
+ * @NL80211_KEY_DEFAULT_BEACON: flag indicating default Beacon frame key
+ *
  * @__NL80211_KEY_AFTER_LAST: internal
  * @NL80211_KEY_MAX: highest key attribute
  */
@@ -4284,6 +4816,8 @@ enum nl80211_key_attributes {
 	NL80211_KEY_DEFAULT_MGMT,
 	NL80211_KEY_TYPE,
 	NL80211_KEY_DEFAULT_TYPES,
+	NL80211_KEY_MODE,
+	NL80211_KEY_DEFAULT_BEACON,
 
 	/* keep last */
 	__NL80211_KEY_AFTER_LAST,
@@ -4302,6 +4836,10 @@ enum nl80211_key_attributes {
  * @NL80211_TXRATE_VHT: VHT rates allowed for TX rate selection,
  *	see &struct nl80211_txrate_vht
  * @NL80211_TXRATE_GI: configure GI, see &enum nl80211_txrate_gi
+ * @NL80211_TXRATE_HE: HE rates allowed for TX rate selection,
+ *	see &struct nl80211_txrate_he
+ * @NL80211_TXRATE_HE_GI: configure HE GI, 0.8us, 1.6us and 3.2us.
+ * @NL80211_TXRATE_HE_LTF: configure HE LTF, 1XLTF, 2XLTF and 4XLTF.
  * @__NL80211_TXRATE_AFTER_LAST: internal
  * @NL80211_TXRATE_MAX: highest TX rate attribute
  */
@@ -4311,6 +4849,9 @@ enum nl80211_tx_rate_attributes {
 	NL80211_TXRATE_HT,
 	NL80211_TXRATE_VHT,
 	NL80211_TXRATE_GI,
+	NL80211_TXRATE_HE,
+	NL80211_TXRATE_HE_GI,
+	NL80211_TXRATE_HE_LTF,
 
 	/* keep last */
 	__NL80211_TXRATE_AFTER_LAST,
@@ -4328,6 +4869,15 @@ struct nl80211_txrate_vht {
 	__u16 mcs[NL80211_VHT_NSS_MAX];
 };
 
+#define NL80211_HE_NSS_MAX		8
+/**
+ * struct nl80211_txrate_he - HE MCS/NSS txrate bitmap
+ * @mcs: MCS bitmap table for each NSS (array index 0 for 1 stream, etc.)
+ */
+struct nl80211_txrate_he {
+	__u16 mcs[NL80211_HE_NSS_MAX];
+};
+
 enum nl80211_txrate_gi {
 	NL80211_TXRATE_DEFAULT_GI,
 	NL80211_TXRATE_FORCE_SGI,
@@ -4338,7 +4888,9 @@ enum nl80211_txrate_gi {
  * enum nl80211_band - Frequency band
  * @NL80211_BAND_2GHZ: 2.4 GHz ISM band
  * @NL80211_BAND_5GHZ: around 5 GHz band (4.9 - 5.7 GHz)
- * @NL80211_BAND_60GHZ: around 60 GHz band (58.32 - 64.80 GHz)
+ * @NL80211_BAND_60GHZ: around 60 GHz band (58.32 - 69.12 GHz)
+ * @NL80211_BAND_6GHZ: around 6 GHz band (5.9 - 7.2 GHz)
+ * @NL80211_BAND_S1GHZ: around 900MHz, supported by S1G PHYs
  * @NUM_NL80211_BANDS: number of bands, avoid using this in userspace
  *	since newer kernel versions may support more bands
  */
@@ -4346,6 +4898,8 @@ enum nl80211_band {
 	NL80211_BAND_2GHZ,
 	NL80211_BAND_5GHZ,
 	NL80211_BAND_60GHZ,
+	NL80211_BAND_6GHZ,
+	NL80211_BAND_S1GHZ,
 
 	NUM_NL80211_BANDS,
 };
@@ -4438,6 +4992,92 @@ enum nl80211_tx_power_setting {
 };
 
 /**
+ * enum nl80211_tid_config - TID config state
+ * @NL80211_TID_CONFIG_ENABLE: Enable config for the TID
+ * @NL80211_TID_CONFIG_DISABLE: Disable config for the TID
+ */
+enum nl80211_tid_config {
+	NL80211_TID_CONFIG_ENABLE,
+	NL80211_TID_CONFIG_DISABLE,
+};
+
+/* enum nl80211_tx_rate_setting - TX rate configuration type
+ * @NL80211_TX_RATE_AUTOMATIC: automatically determine TX rate
+ * @NL80211_TX_RATE_LIMITED: limit the TX rate by the TX rate parameter
+ * @NL80211_TX_RATE_FIXED: fix TX rate to the TX rate parameter
+ */
+enum nl80211_tx_rate_setting {
+	NL80211_TX_RATE_AUTOMATIC,
+	NL80211_TX_RATE_LIMITED,
+	NL80211_TX_RATE_FIXED,
+};
+
+/* enum nl80211_tid_config_attr - TID specific configuration.
+ * @NL80211_TID_CONFIG_ATTR_PAD: pad attribute for 64-bit values
+ * @NL80211_TID_CONFIG_ATTR_VIF_SUPP: a bitmap (u64) of attributes supported
+ *	for per-vif configuration; doesn't list the ones that are generic
+ *	(%NL80211_TID_CONFIG_ATTR_TIDS, %NL80211_TID_CONFIG_ATTR_OVERRIDE).
+ * @NL80211_TID_CONFIG_ATTR_PEER_SUPP: same as the previous per-vif one, but
+ *	per peer instead.
+ * @NL80211_TID_CONFIG_ATTR_OVERRIDE: flag attribue, if set indicates
+ *	that the new configuration overrides all previous peer
+ *	configurations, otherwise previous peer specific configurations
+ *	should be left untouched.
+ * @NL80211_TID_CONFIG_ATTR_TIDS: a bitmask value of TIDs (bit 0 to 7)
+ *	Its type is u16.
+ * @NL80211_TID_CONFIG_ATTR_NOACK: Configure ack policy for the TID.
+ *	specified in %NL80211_TID_CONFIG_ATTR_TID. see %enum nl80211_tid_config.
+ *	Its type is u8.
+ * @NL80211_TID_CONFIG_ATTR_RETRY_SHORT: Number of retries used with data frame
+ *	transmission, user-space sets this configuration in
+ *	&NL80211_CMD_SET_TID_CONFIG. It is u8 type, min value is 1 and
+ *	the max value is advertised by the driver in this attribute on
+ *	output in wiphy capabilities.
+ * @NL80211_TID_CONFIG_ATTR_RETRY_LONG: Number of retries used with data frame
+ *	transmission, user-space sets this configuration in
+ *	&NL80211_CMD_SET_TID_CONFIG. Its type is u8, min value is 1 and
+ *	the max value is advertised by the driver in this attribute on
+ *	output in wiphy capabilities.
+ * @NL80211_TID_CONFIG_ATTR_AMPDU_CTRL: Enable/Disable MPDU aggregation
+ *	for the TIDs specified in %NL80211_TID_CONFIG_ATTR_TIDS.
+ *	Its type is u8, using the values from &nl80211_tid_config.
+ * @NL80211_TID_CONFIG_ATTR_RTSCTS_CTRL: Enable/Disable RTS_CTS for the TIDs
+ *	specified in %NL80211_TID_CONFIG_ATTR_TIDS. It is u8 type, using
+ *	the values from &nl80211_tid_config.
+ * @NL80211_TID_CONFIG_ATTR_AMSDU_CTRL: Enable/Disable MSDU aggregation
+ *	for the TIDs specified in %NL80211_TID_CONFIG_ATTR_TIDS.
+ *	Its type is u8, using the values from &nl80211_tid_config.
+ * @NL80211_TID_CONFIG_ATTR_TX_RATE_TYPE: This attribute will be useful
+ *	to notfiy the driver that what type of txrate should be used
+ *	for the TIDs specified in %NL80211_TID_CONFIG_ATTR_TIDS. using
+ *	the values form &nl80211_tx_rate_setting.
+ * @NL80211_TID_CONFIG_ATTR_TX_RATE: Data frame TX rate mask should be applied
+ *	with the parameters passed through %NL80211_ATTR_TX_RATES.
+ *	configuration is applied to the data frame for the tid to that connected
+ *	station.
+ */
+enum nl80211_tid_config_attr {
+	__NL80211_TID_CONFIG_ATTR_INVALID,
+	NL80211_TID_CONFIG_ATTR_PAD,
+	NL80211_TID_CONFIG_ATTR_VIF_SUPP,
+	NL80211_TID_CONFIG_ATTR_PEER_SUPP,
+	NL80211_TID_CONFIG_ATTR_OVERRIDE,
+	NL80211_TID_CONFIG_ATTR_TIDS,
+	NL80211_TID_CONFIG_ATTR_NOACK,
+	NL80211_TID_CONFIG_ATTR_RETRY_SHORT,
+	NL80211_TID_CONFIG_ATTR_RETRY_LONG,
+	NL80211_TID_CONFIG_ATTR_AMPDU_CTRL,
+	NL80211_TID_CONFIG_ATTR_RTSCTS_CTRL,
+	NL80211_TID_CONFIG_ATTR_AMSDU_CTRL,
+	NL80211_TID_CONFIG_ATTR_TX_RATE_TYPE,
+	NL80211_TID_CONFIG_ATTR_TX_RATE,
+
+	/* keep last */
+	__NL80211_TID_CONFIG_ATTR_AFTER_LAST,
+	NL80211_TID_CONFIG_ATTR_MAX = __NL80211_TID_CONFIG_ATTR_AFTER_LAST - 1
+};
+
+/**
  * enum nl80211_packet_pattern_attr - packet pattern attribute
  * @__NL80211_PKTPAT_INVALID: invalid number for nested attribute
  * @NL80211_PKTPAT_PATTERN: the pattern, values where the mask has
@@ -4831,7 +5471,7 @@ enum nl80211_iface_limit_attrs {
  *	numbers = [ #{STA} <= 1, #{P2P-client,P2P-GO} <= 3 ], max = 4
  *	=> allows a STA plus three P2P interfaces
  *
- * The list of these four possiblities could completely be contained
+ * The list of these four possibilities could completely be contained
  * within the %NL80211_ATTR_INTERFACE_COMBINATIONS attribute to indicate
  * that any of these groups must match.
  *
@@ -4861,7 +5501,7 @@ enum nl80211_if_combination_attrs {
  * enum nl80211_plink_state - state of a mesh peer link finite state machine
  *
  * @NL80211_PLINK_LISTEN: initial state, considered the implicit
- *	state of non existant mesh peer links
+ *	state of non existent mesh peer links
  * @NL80211_PLINK_OPN_SNT: mesh plink open frame has been sent to
  *	this mesh peer
  * @NL80211_PLINK_OPN_RCVD: mesh plink open frame has been received
@@ -4908,6 +5548,8 @@ enum plink_actions {
 
 #define NL80211_KCK_LEN			16
 #define NL80211_KEK_LEN			16
+#define NL80211_KCK_EXT_LEN		24
+#define NL80211_KEK_EXT_LEN		32
 #define NL80211_REPLAY_CTR_LEN		8
 
 /**
@@ -4916,6 +5558,7 @@ enum plink_actions {
  * @NL80211_REKEY_DATA_KEK: key encryption key (binary)
  * @NL80211_REKEY_DATA_KCK: key confirmation key (binary)
  * @NL80211_REKEY_DATA_REPLAY_CTR: replay counter (binary)
+ * @NL80211_REKEY_DATA_AKM: AKM data (OUI, suite type)
  * @NUM_NL80211_REKEY_DATA: number of rekey attributes (internal)
  * @MAX_NL80211_REKEY_DATA: highest rekey attribute (internal)
  */
@@ -4924,6 +5567,7 @@ enum nl80211_rekey_data {
 	NL80211_REKEY_DATA_KEK,
 	NL80211_REKEY_DATA_KCK,
 	NL80211_REKEY_DATA_REPLAY_CTR,
+	NL80211_REKEY_DATA_AKM,
 
 	/* keep last */
 	NUM_NL80211_REKEY_DATA,
@@ -5137,14 +5781,14 @@ enum nl80211_feature_flags {
 	NL80211_FEATURE_TDLS_CHANNEL_SWITCH		= 1 << 28,
 	NL80211_FEATURE_SCAN_RANDOM_MAC_ADDR		= 1 << 29,
 	NL80211_FEATURE_SCHED_SCAN_RANDOM_MAC_ADDR	= 1 << 30,
-	NL80211_FEATURE_ND_RANDOM_MAC_ADDR		= 1 << 31,
+	NL80211_FEATURE_ND_RANDOM_MAC_ADDR		= 1U << 31,
 };
 
 /**
  * enum nl80211_ext_feature_index - bit index of extended features.
  * @NL80211_EXT_FEATURE_VHT_IBSS: This driver supports IBSS with VHT datarates.
  * @NL80211_EXT_FEATURE_RRM: This driver supports RRM. When featured, user can
- *	can request to use RRM (see %NL80211_ATTR_USE_RRM) with
+ *	request to use RRM (see %NL80211_ATTR_USE_RRM) with
  *	%NL80211_CMD_ASSOCIATE and %NL80211_CMD_CONNECT requests, which will set
  *	the ASSOC_REQ_USE_RRM flag in the association request even if
  *	NL80211_FEATURE_QUIET is not advertized.
@@ -5213,9 +5857,8 @@ enum nl80211_feature_flags {
  *	"radar detected" event.
  * @NL80211_EXT_FEATURE_CONTROL_PORT_OVER_NL80211: Driver supports sending and
  *	receiving control port frames over nl80211 instead of the netdevice.
- * @NL80211_EXT_FEATURE_DATA_ACK_SIGNAL_SUPPORT: This Driver support data ack
- *	rssi if firmware support, this flag is to intimate about ack rssi
- *	support to nl80211.
+ * @NL80211_EXT_FEATURE_ACK_SIGNAL_SUPPORT: This driver/device supports
+ *	(average) ACK signal strength reporting.
  * @NL80211_EXT_FEATURE_TXQS: Driver supports FQ-CoDel-enabled intermediate
  *      TXQs.
  * @NL80211_EXT_FEATURE_SCAN_RANDOM_SN: Driver/device supports randomizing the
@@ -5223,6 +5866,93 @@ enum nl80211_feature_flags {
  * @NL80211_EXT_FEATURE_SCAN_MIN_PREQ_CONTENT: Driver/device can omit all data
  *	except for supported rates from the probe request content if requested
  *	by the %NL80211_SCAN_FLAG_MIN_PREQ_CONTENT flag.
+ * @NL80211_EXT_FEATURE_ENABLE_FTM_RESPONDER: Driver supports enabling fine
+ *	timing measurement responder role.
+ *
+ * @NL80211_EXT_FEATURE_CAN_REPLACE_PTK0: Driver/device confirm that they are
+ *      able to rekey an in-use key correctly. Userspace must not rekey PTK keys
+ *      if this flag is not set. Ignoring this can leak clear text packets and/or
+ *      freeze the connection.
+ * @NL80211_EXT_FEATURE_EXT_KEY_ID: Driver supports "Extended Key ID for
+ *      Individually Addressed Frames" from IEEE802.11-2016.
+ *
+ * @NL80211_EXT_FEATURE_AIRTIME_FAIRNESS: Driver supports getting airtime
+ *	fairness for transmitted packets and has enabled airtime fairness
+ *	scheduling.
+ *
+ * @NL80211_EXT_FEATURE_AP_PMKSA_CACHING: Driver/device supports PMKSA caching
+ *	(set/del PMKSA operations) in AP mode.
+ *
+ * @NL80211_EXT_FEATURE_SCHED_SCAN_BAND_SPECIFIC_RSSI_THOLD: Driver supports
+ *	filtering of sched scan results using band specific RSSI thresholds.
+ *
+ * @NL80211_EXT_FEATURE_STA_TX_PWR: This driver supports controlling tx power
+ *	to a station.
+ *
+ * @NL80211_EXT_FEATURE_SAE_OFFLOAD: Device wants to do SAE authentication in
+ *	station mode (SAE password is passed as part of the connect command).
+ *
+ * @NL80211_EXT_FEATURE_VLAN_OFFLOAD: The driver supports a single netdev
+ *	with VLAN tagged frames and separate VLAN-specific netdevs added using
+ *	vconfig similarly to the Ethernet case.
+ *
+ * @NL80211_EXT_FEATURE_AQL: The driver supports the Airtime Queue Limit (AQL)
+ *	feature, which prevents bufferbloat by using the expected transmission
+ *	time to limit the amount of data buffered in the hardware.
+ *
+ * @NL80211_EXT_FEATURE_BEACON_PROTECTION: The driver supports Beacon protection
+ *	and can receive key configuration for BIGTK using key indexes 6 and 7.
+ * @NL80211_EXT_FEATURE_BEACON_PROTECTION_CLIENT: The driver supports Beacon
+ *	protection as a client only and cannot transmit protected beacons.
+ *
+ * @NL80211_EXT_FEATURE_CONTROL_PORT_NO_PREAUTH: The driver can disable the
+ *	forwarding of preauth frames over the control port. They are then
+ *	handled as ordinary data frames.
+ *
+ * @NL80211_EXT_FEATURE_PROTECTED_TWT: Driver supports protected TWT frames
+ *
+ * @NL80211_EXT_FEATURE_DEL_IBSS_STA: The driver supports removing stations
+ *      in IBSS mode, essentially by dropping their state.
+ *
+ * @NL80211_EXT_FEATURE_MULTICAST_REGISTRATIONS: management frame registrations
+ *	are possible for multicast frames and those will be reported properly.
+ *
+ * @NL80211_EXT_FEATURE_SCAN_FREQ_KHZ: This driver supports receiving and
+ *	reporting scan request with %NL80211_ATTR_SCAN_FREQ_KHZ. In order to
+ *	report %NL80211_ATTR_SCAN_FREQ_KHZ, %NL80211_SCAN_FLAG_FREQ_KHZ must be
+ *	included in the scan request.
+ *
+ * @NL80211_EXT_FEATURE_CONTROL_PORT_OVER_NL80211_TX_STATUS: The driver
+ *	can report tx status for control port over nl80211 tx operations.
+ *
+ * @NL80211_EXT_FEATURE_OPERATING_CHANNEL_VALIDATION: Driver supports Operating
+ *	Channel Validation (OCV) when using driver's SME for RSNA handshakes.
+ *
+ * @NL80211_EXT_FEATURE_4WAY_HANDSHAKE_AP_PSK: Device wants to do 4-way
+ *	handshake with PSK in AP mode (PSK is passed as part of the start AP
+ *	command).
+ *
+ * @NL80211_EXT_FEATURE_SAE_OFFLOAD_AP: Device wants to do SAE authentication
+ *	in AP mode (SAE password is passed as part of the start AP command).
+ *
+ * @NL80211_EXT_FEATURE_FILS_DISCOVERY: Driver/device supports FILS discovery
+ *	frames transmission
+ *
+ * @NL80211_EXT_FEATURE_UNSOL_BCAST_PROBE_RESP: Driver/device supports
+ *	unsolicited broadcast probe response transmission
+ *
+ * @NL80211_EXT_FEATURE_BEACON_RATE_HE: Driver supports beacon rate
+ *	configuration (AP/mesh) with HE rates.
+ *
+ * @NL80211_EXT_FEATURE_SECURE_LTF: Device supports secure LTF measurement
+ *      exchange protocol.
+ *
+ * @NL80211_EXT_FEATURE_SECURE_RTT: Device supports secure RTT measurement
+ *      exchange protocol.
+ *
+ * @NL80211_EXT_FEATURE_PROT_RANGE_NEGO_AND_MEASURE: Device supports management
+ *      frame protection for all management frames exchanged during the
+ *      negotiation and range measurement procedure.
  *
  * @NUM_NL80211_EXT_FEATURES: number of extended features.
  * @MAX_NL80211_EXT_FEATURES: highest extended feature index.
@@ -5255,10 +5985,39 @@ enum nl80211_ext_feature_index {
 	NL80211_EXT_FEATURE_HIGH_ACCURACY_SCAN,
 	NL80211_EXT_FEATURE_DFS_OFFLOAD,
 	NL80211_EXT_FEATURE_CONTROL_PORT_OVER_NL80211,
-	NL80211_EXT_FEATURE_DATA_ACK_SIGNAL_SUPPORT,
+	NL80211_EXT_FEATURE_ACK_SIGNAL_SUPPORT,
+	/* we renamed this - stay compatible */
+	NL80211_EXT_FEATURE_DATA_ACK_SIGNAL_SUPPORT = NL80211_EXT_FEATURE_ACK_SIGNAL_SUPPORT,
 	NL80211_EXT_FEATURE_TXQS,
 	NL80211_EXT_FEATURE_SCAN_RANDOM_SN,
 	NL80211_EXT_FEATURE_SCAN_MIN_PREQ_CONTENT,
+	NL80211_EXT_FEATURE_CAN_REPLACE_PTK0,
+	NL80211_EXT_FEATURE_ENABLE_FTM_RESPONDER,
+	NL80211_EXT_FEATURE_AIRTIME_FAIRNESS,
+	NL80211_EXT_FEATURE_AP_PMKSA_CACHING,
+	NL80211_EXT_FEATURE_SCHED_SCAN_BAND_SPECIFIC_RSSI_THOLD,
+	NL80211_EXT_FEATURE_EXT_KEY_ID,
+	NL80211_EXT_FEATURE_STA_TX_PWR,
+	NL80211_EXT_FEATURE_SAE_OFFLOAD,
+	NL80211_EXT_FEATURE_VLAN_OFFLOAD,
+	NL80211_EXT_FEATURE_AQL,
+	NL80211_EXT_FEATURE_BEACON_PROTECTION,
+	NL80211_EXT_FEATURE_CONTROL_PORT_NO_PREAUTH,
+	NL80211_EXT_FEATURE_PROTECTED_TWT,
+	NL80211_EXT_FEATURE_DEL_IBSS_STA,
+	NL80211_EXT_FEATURE_MULTICAST_REGISTRATIONS,
+	NL80211_EXT_FEATURE_BEACON_PROTECTION_CLIENT,
+	NL80211_EXT_FEATURE_SCAN_FREQ_KHZ,
+	NL80211_EXT_FEATURE_CONTROL_PORT_OVER_NL80211_TX_STATUS,
+	NL80211_EXT_FEATURE_OPERATING_CHANNEL_VALIDATION,
+	NL80211_EXT_FEATURE_4WAY_HANDSHAKE_AP_PSK,
+	NL80211_EXT_FEATURE_SAE_OFFLOAD_AP,
+	NL80211_EXT_FEATURE_FILS_DISCOVERY,
+	NL80211_EXT_FEATURE_UNSOL_BCAST_PROBE_RESP,
+	NL80211_EXT_FEATURE_BEACON_RATE_HE,
+	NL80211_EXT_FEATURE_SECURE_LTF,
+	NL80211_EXT_FEATURE_SECURE_RTT,
+	NL80211_EXT_FEATURE_PROT_RANGE_NEGO_AND_MEASURE,
 
 	/* add new features before the definition below */
 	NUM_NL80211_EXT_FEATURES,
@@ -5343,7 +6102,7 @@ enum nl80211_timeout_reason {
  *	request parameters IE in the probe request
  * @NL80211_SCAN_FLAG_ACCEPT_BCAST_PROBE_RESP: accept broadcast probe responses
  * @NL80211_SCAN_FLAG_OCE_PROBE_REQ_HIGH_TX_RATE: send probe request frames at
- *	rate of at least 5.5M. In case non OCE AP is dicovered in the channel,
+ *	rate of at least 5.5M. In case non OCE AP is discovered in the channel,
  *	only the first probe req in the channel will be sent in high rate.
  * @NL80211_SCAN_FLAG_OCE_PROBE_REQ_DEFERRAL_SUPPRESSION: allow probe request
  *	tx deferral (dot11FILSProbeDelay shall be set to 15ms)
@@ -5370,6 +6129,11 @@ enum nl80211_timeout_reason {
  * @NL80211_SCAN_FLAG_MIN_PREQ_CONTENT: minimize probe request content to
  *	only have supported rates and no additional capabilities (unless
  *	added by userspace explicitly.)
+ * @NL80211_SCAN_FLAG_FREQ_KHZ: report scan results with
+ *	%NL80211_ATTR_SCAN_FREQ_KHZ. This also means
+ *	%NL80211_ATTR_SCAN_FREQUENCIES will not be included.
+ * @NL80211_SCAN_FLAG_COLOCATED_6GHZ: scan for colocated APs reported by
+ *	2.4/5 GHz APs
  */
 enum nl80211_scan_flags {
 	NL80211_SCAN_FLAG_LOW_PRIORITY				= 1<<0,
@@ -5385,6 +6149,8 @@ enum nl80211_scan_flags {
 	NL80211_SCAN_FLAG_HIGH_ACCURACY				= 1<<10,
 	NL80211_SCAN_FLAG_RANDOM_SN				= 1<<11,
 	NL80211_SCAN_FLAG_MIN_PREQ_CONTENT			= 1<<12,
+	NL80211_SCAN_FLAG_FREQ_KHZ				= 1<<13,
+	NL80211_SCAN_FLAG_COLOCATED_6GHZ			= 1<<14,
 };
 
 /**
@@ -5472,7 +6238,7 @@ enum nl80211_dfs_state {
 };
 
 /**
- * enum enum nl80211_protocol_features - nl80211 protocol features
+ * enum nl80211_protocol_features - nl80211 protocol features
  * @NL80211_PROTOCOL_FEATURE_SPLIT_WIPHY_DUMP: nl80211 supports splitting
  *	wiphy dumps (if requested by the application with the attribute
  *	%NL80211_ATTR_SPLIT_WIPHY_DUMP. Also supported is filtering the
@@ -5510,9 +6276,14 @@ enum nl80211_crit_proto_id {
  * Used by cfg80211_rx_mgmt()
  *
  * @NL80211_RXMGMT_FLAG_ANSWERED: frame was answered by device/driver.
+ * @NL80211_RXMGMT_FLAG_EXTERNAL_AUTH: Host driver intends to offload
+ *	the authentication. Exclusively defined for host drivers that
+ *	advertises the SME functionality but would like the userspace
+ *	to handle certain authentication algorithms (e.g. SAE).
  */
 enum nl80211_rxmgmt_flags {
 	NL80211_RXMGMT_FLAG_ANSWERED = 1 << 0,
+	NL80211_RXMGMT_FLAG_EXTERNAL_AUTH = 1 << 1,
 };
 
 /*
@@ -5544,11 +6315,13 @@ struct nl80211_vendor_cmd_info {
  * @NL80211_TDLS_PEER_HT: TDLS peer is HT capable.
  * @NL80211_TDLS_PEER_VHT: TDLS peer is VHT capable.
  * @NL80211_TDLS_PEER_WMM: TDLS peer is WMM capable.
+ * @NL80211_TDLS_PEER_HE: TDLS peer is HE capable.
  */
 enum nl80211_tdls_peer_capability {
 	NL80211_TDLS_PEER_HT = 1<<0,
 	NL80211_TDLS_PEER_VHT = 1<<1,
 	NL80211_TDLS_PEER_WMM = 1<<2,
+	NL80211_TDLS_PEER_HE = 1<<3,
 };
 
 /**
@@ -5798,4 +6571,736 @@ enum nl80211_external_auth_action {
 	NL80211_EXTERNAL_AUTH_ABORT,
 };
 
+/**
+ * enum nl80211_ftm_responder_attributes - fine timing measurement
+ *	responder attributes
+ * @__NL80211_FTM_RESP_ATTR_INVALID: Invalid
+ * @NL80211_FTM_RESP_ATTR_ENABLED: FTM responder is enabled
+ * @NL80211_FTM_RESP_ATTR_LCI: The content of Measurement Report Element
+ *	(9.4.2.22 in 802.11-2016) with type 8 - LCI (9.4.2.22.10),
+ *	i.e. starting with the measurement token
+ * @NL80211_FTM_RESP_ATTR_CIVIC: The content of Measurement Report Element
+ *	(9.4.2.22 in 802.11-2016) with type 11 - Civic (Section 9.4.2.22.13),
+ *	i.e. starting with the measurement token
+ * @__NL80211_FTM_RESP_ATTR_LAST: Internal
+ * @NL80211_FTM_RESP_ATTR_MAX: highest FTM responder attribute.
+ */
+enum nl80211_ftm_responder_attributes {
+	__NL80211_FTM_RESP_ATTR_INVALID,
+
+	NL80211_FTM_RESP_ATTR_ENABLED,
+	NL80211_FTM_RESP_ATTR_LCI,
+	NL80211_FTM_RESP_ATTR_CIVICLOC,
+
+	/* keep last */
+	__NL80211_FTM_RESP_ATTR_LAST,
+	NL80211_FTM_RESP_ATTR_MAX = __NL80211_FTM_RESP_ATTR_LAST - 1,
+};
+
+/*
+ * enum nl80211_ftm_responder_stats - FTM responder statistics
+ *
+ * These attribute types are used with %NL80211_ATTR_FTM_RESPONDER_STATS
+ * when getting FTM responder statistics.
+ *
+ * @__NL80211_FTM_STATS_INVALID: attribute number 0 is reserved
+ * @NL80211_FTM_STATS_SUCCESS_NUM: number of FTM sessions in which all frames
+ *	were ssfully answered (u32)
+ * @NL80211_FTM_STATS_PARTIAL_NUM: number of FTM sessions in which part of the
+ *	frames were successfully answered (u32)
+ * @NL80211_FTM_STATS_FAILED_NUM: number of failed FTM sessions (u32)
+ * @NL80211_FTM_STATS_ASAP_NUM: number of ASAP sessions (u32)
+ * @NL80211_FTM_STATS_NON_ASAP_NUM: number of non-ASAP sessions (u32)
+ * @NL80211_FTM_STATS_TOTAL_DURATION_MSEC: total sessions durations - gives an
+ *	indication of how much time the responder was busy (u64, msec)
+ * @NL80211_FTM_STATS_UNKNOWN_TRIGGERS_NUM: number of unknown FTM triggers -
+ *	triggers from initiators that didn't finish successfully the negotiation
+ *	phase with the responder (u32)
+ * @NL80211_FTM_STATS_RESCHEDULE_REQUESTS_NUM: number of FTM reschedule requests
+ *	- initiator asks for a new scheduling although it already has scheduled
+ *	FTM slot (u32)
+ * @NL80211_FTM_STATS_OUT_OF_WINDOW_TRIGGERS_NUM: number of FTM triggers out of
+ *	scheduled window (u32)
+ * @NL80211_FTM_STATS_PAD: used for padding, ignore
+ * @__NL80211_TXQ_ATTR_AFTER_LAST: Internal
+ * @NL80211_FTM_STATS_MAX: highest possible FTM responder stats attribute
+ */
+enum nl80211_ftm_responder_stats {
+	__NL80211_FTM_STATS_INVALID,
+	NL80211_FTM_STATS_SUCCESS_NUM,
+	NL80211_FTM_STATS_PARTIAL_NUM,
+	NL80211_FTM_STATS_FAILED_NUM,
+	NL80211_FTM_STATS_ASAP_NUM,
+	NL80211_FTM_STATS_NON_ASAP_NUM,
+	NL80211_FTM_STATS_TOTAL_DURATION_MSEC,
+	NL80211_FTM_STATS_UNKNOWN_TRIGGERS_NUM,
+	NL80211_FTM_STATS_RESCHEDULE_REQUESTS_NUM,
+	NL80211_FTM_STATS_OUT_OF_WINDOW_TRIGGERS_NUM,
+	NL80211_FTM_STATS_PAD,
+
+	/* keep last */
+	__NL80211_FTM_STATS_AFTER_LAST,
+	NL80211_FTM_STATS_MAX = __NL80211_FTM_STATS_AFTER_LAST - 1
+};
+
+/**
+ * enum nl80211_preamble - frame preamble types
+ * @NL80211_PREAMBLE_LEGACY: legacy (HR/DSSS, OFDM, ERP PHY) preamble
+ * @NL80211_PREAMBLE_HT: HT preamble
+ * @NL80211_PREAMBLE_VHT: VHT preamble
+ * @NL80211_PREAMBLE_DMG: DMG preamble
+ * @NL80211_PREAMBLE_HE: HE preamble
+ */
+enum nl80211_preamble {
+	NL80211_PREAMBLE_LEGACY,
+	NL80211_PREAMBLE_HT,
+	NL80211_PREAMBLE_VHT,
+	NL80211_PREAMBLE_DMG,
+	NL80211_PREAMBLE_HE,
+};
+
+/**
+ * enum nl80211_peer_measurement_type - peer measurement types
+ * @NL80211_PMSR_TYPE_INVALID: invalid/unused, needed as we use
+ *	these numbers also for attributes
+ *
+ * @NL80211_PMSR_TYPE_FTM: flight time measurement
+ *
+ * @NUM_NL80211_PMSR_TYPES: internal
+ * @NL80211_PMSR_TYPE_MAX: highest type number
+ */
+enum nl80211_peer_measurement_type {
+	NL80211_PMSR_TYPE_INVALID,
+
+	NL80211_PMSR_TYPE_FTM,
+
+	NUM_NL80211_PMSR_TYPES,
+	NL80211_PMSR_TYPE_MAX = NUM_NL80211_PMSR_TYPES - 1
+};
+
+/**
+ * enum nl80211_peer_measurement_status - peer measurement status
+ * @NL80211_PMSR_STATUS_SUCCESS: measurement completed successfully
+ * @NL80211_PMSR_STATUS_REFUSED: measurement was locally refused
+ * @NL80211_PMSR_STATUS_TIMEOUT: measurement timed out
+ * @NL80211_PMSR_STATUS_FAILURE: measurement failed, a type-dependent
+ *	reason may be available in the response data
+ */
+enum nl80211_peer_measurement_status {
+	NL80211_PMSR_STATUS_SUCCESS,
+	NL80211_PMSR_STATUS_REFUSED,
+	NL80211_PMSR_STATUS_TIMEOUT,
+	NL80211_PMSR_STATUS_FAILURE,
+};
+
+/**
+ * enum nl80211_peer_measurement_req - peer measurement request attributes
+ * @__NL80211_PMSR_REQ_ATTR_INVALID: invalid
+ *
+ * @NL80211_PMSR_REQ_ATTR_DATA: This is a nested attribute with measurement
+ *	type-specific request data inside. The attributes used are from the
+ *	enums named nl80211_peer_measurement_<type>_req.
+ * @NL80211_PMSR_REQ_ATTR_GET_AP_TSF: include AP TSF timestamp, if supported
+ *	(flag attribute)
+ *
+ * @NUM_NL80211_PMSR_REQ_ATTRS: internal
+ * @NL80211_PMSR_REQ_ATTR_MAX: highest attribute number
+ */
+enum nl80211_peer_measurement_req {
+	__NL80211_PMSR_REQ_ATTR_INVALID,
+
+	NL80211_PMSR_REQ_ATTR_DATA,
+	NL80211_PMSR_REQ_ATTR_GET_AP_TSF,
+
+	/* keep last */
+	NUM_NL80211_PMSR_REQ_ATTRS,
+	NL80211_PMSR_REQ_ATTR_MAX = NUM_NL80211_PMSR_REQ_ATTRS - 1
+};
+
+/**
+ * enum nl80211_peer_measurement_resp - peer measurement response attributes
+ * @__NL80211_PMSR_RESP_ATTR_INVALID: invalid
+ *
+ * @NL80211_PMSR_RESP_ATTR_DATA: This is a nested attribute with measurement
+ *	type-specific results inside. The attributes used are from the enums
+ *	named nl80211_peer_measurement_<type>_resp.
+ * @NL80211_PMSR_RESP_ATTR_STATUS: u32 value with the measurement status
+ *	(using values from &enum nl80211_peer_measurement_status.)
+ * @NL80211_PMSR_RESP_ATTR_HOST_TIME: host time (%CLOCK_BOOTTIME) when the
+ *	result was measured; this value is not expected to be accurate to
+ *	more than 20ms. (u64, nanoseconds)
+ * @NL80211_PMSR_RESP_ATTR_AP_TSF: TSF of the AP that the interface
+ *	doing the measurement is connected to when the result was measured.
+ *	This shall be accurately reported if supported and requested
+ *	(u64, usec)
+ * @NL80211_PMSR_RESP_ATTR_FINAL: If results are sent to the host partially
+ *	(*e.g. with FTM per-burst data) this flag will be cleared on all but
+ *	the last result; if all results are combined it's set on the single
+ *	result.
+ * @NL80211_PMSR_RESP_ATTR_PAD: padding for 64-bit attributes, ignore
+ *
+ * @NUM_NL80211_PMSR_RESP_ATTRS: internal
+ * @NL80211_PMSR_RESP_ATTR_MAX: highest attribute number
+ */
+enum nl80211_peer_measurement_resp {
+	__NL80211_PMSR_RESP_ATTR_INVALID,
+
+	NL80211_PMSR_RESP_ATTR_DATA,
+	NL80211_PMSR_RESP_ATTR_STATUS,
+	NL80211_PMSR_RESP_ATTR_HOST_TIME,
+	NL80211_PMSR_RESP_ATTR_AP_TSF,
+	NL80211_PMSR_RESP_ATTR_FINAL,
+	NL80211_PMSR_RESP_ATTR_PAD,
+
+	/* keep last */
+	NUM_NL80211_PMSR_RESP_ATTRS,
+	NL80211_PMSR_RESP_ATTR_MAX = NUM_NL80211_PMSR_RESP_ATTRS - 1
+};
+
+/**
+ * enum nl80211_peer_measurement_peer_attrs - peer attributes for measurement
+ * @__NL80211_PMSR_PEER_ATTR_INVALID: invalid
+ *
+ * @NL80211_PMSR_PEER_ATTR_ADDR: peer's MAC address
+ * @NL80211_PMSR_PEER_ATTR_CHAN: channel definition, nested, using top-level
+ *	attributes like %NL80211_ATTR_WIPHY_FREQ etc.
+ * @NL80211_PMSR_PEER_ATTR_REQ: This is a nested attribute indexed by
+ *	measurement type, with attributes from the
+ *	&enum nl80211_peer_measurement_req inside.
+ * @NL80211_PMSR_PEER_ATTR_RESP: This is a nested attribute indexed by
+ *	measurement type, with attributes from the
+ *	&enum nl80211_peer_measurement_resp inside.
+ *
+ * @NUM_NL80211_PMSR_PEER_ATTRS: internal
+ * @NL80211_PMSR_PEER_ATTR_MAX: highest attribute number
+ */
+enum nl80211_peer_measurement_peer_attrs {
+	__NL80211_PMSR_PEER_ATTR_INVALID,
+
+	NL80211_PMSR_PEER_ATTR_ADDR,
+	NL80211_PMSR_PEER_ATTR_CHAN,
+	NL80211_PMSR_PEER_ATTR_REQ,
+	NL80211_PMSR_PEER_ATTR_RESP,
+
+	/* keep last */
+	NUM_NL80211_PMSR_PEER_ATTRS,
+	NL80211_PMSR_PEER_ATTR_MAX = NUM_NL80211_PMSR_PEER_ATTRS - 1,
+};
+
+/**
+ * enum nl80211_peer_measurement_attrs - peer measurement attributes
+ * @__NL80211_PMSR_ATTR_INVALID: invalid
+ *
+ * @NL80211_PMSR_ATTR_MAX_PEERS: u32 attribute used for capability
+ *	advertisement only, indicates the maximum number of peers
+ *	measurements can be done with in a single request
+ * @NL80211_PMSR_ATTR_REPORT_AP_TSF: flag attribute in capability
+ *	indicating that the connected AP's TSF can be reported in
+ *	measurement results
+ * @NL80211_PMSR_ATTR_RANDOMIZE_MAC_ADDR: flag attribute in capability
+ *	indicating that MAC address randomization is supported.
+ * @NL80211_PMSR_ATTR_TYPE_CAPA: capabilities reported by the device,
+ *	this contains a nesting indexed by measurement type, and
+ *	type-specific capabilities inside, which are from the enums
+ *	named nl80211_peer_measurement_<type>_capa.
+ * @NL80211_PMSR_ATTR_PEERS: nested attribute, the nesting index is
+ *	meaningless, just a list of peers to measure with, with the
+ *	sub-attributes taken from
+ *	&enum nl80211_peer_measurement_peer_attrs.
+ *
+ * @NUM_NL80211_PMSR_ATTR: internal
+ * @NL80211_PMSR_ATTR_MAX: highest attribute number
+ */
+enum nl80211_peer_measurement_attrs {
+	__NL80211_PMSR_ATTR_INVALID,
+
+	NL80211_PMSR_ATTR_MAX_PEERS,
+	NL80211_PMSR_ATTR_REPORT_AP_TSF,
+	NL80211_PMSR_ATTR_RANDOMIZE_MAC_ADDR,
+	NL80211_PMSR_ATTR_TYPE_CAPA,
+	NL80211_PMSR_ATTR_PEERS,
+
+	/* keep last */
+	NUM_NL80211_PMSR_ATTR,
+	NL80211_PMSR_ATTR_MAX = NUM_NL80211_PMSR_ATTR - 1
+};
+
+/**
+ * enum nl80211_peer_measurement_ftm_capa - FTM capabilities
+ * @__NL80211_PMSR_FTM_CAPA_ATTR_INVALID: invalid
+ *
+ * @NL80211_PMSR_FTM_CAPA_ATTR_ASAP: flag attribute indicating ASAP mode
+ *	is supported
+ * @NL80211_PMSR_FTM_CAPA_ATTR_NON_ASAP: flag attribute indicating non-ASAP
+ *	mode is supported
+ * @NL80211_PMSR_FTM_CAPA_ATTR_REQ_LCI: flag attribute indicating if LCI
+ *	data can be requested during the measurement
+ * @NL80211_PMSR_FTM_CAPA_ATTR_REQ_CIVICLOC: flag attribute indicating if civic
+ *	location data can be requested during the measurement
+ * @NL80211_PMSR_FTM_CAPA_ATTR_PREAMBLES: u32 bitmap attribute of bits
+ *	from &enum nl80211_preamble.
+ * @NL80211_PMSR_FTM_CAPA_ATTR_BANDWIDTHS: bitmap of values from
+ *	&enum nl80211_chan_width indicating the supported channel
+ *	bandwidths for FTM. Note that a higher channel bandwidth may be
+ *	configured to allow for other measurements types with different
+ *	bandwidth requirement in the same measurement.
+ * @NL80211_PMSR_FTM_CAPA_ATTR_MAX_BURSTS_EXPONENT: u32 attribute indicating
+ *	the maximum bursts exponent that can be used (if not present anything
+ *	is valid)
+ * @NL80211_PMSR_FTM_CAPA_ATTR_MAX_FTMS_PER_BURST: u32 attribute indicating
+ *	the maximum FTMs per burst (if not present anything is valid)
+ * @NL80211_PMSR_FTM_CAPA_ATTR_TRIGGER_BASED: flag attribute indicating if
+ *	trigger based ranging measurement is supported
+ * @NL80211_PMSR_FTM_CAPA_ATTR_NON_TRIGGER_BASED: flag attribute indicating
+ *	if non trigger based ranging measurement is supported
+ *
+ * @NUM_NL80211_PMSR_FTM_CAPA_ATTR: internal
+ * @NL80211_PMSR_FTM_CAPA_ATTR_MAX: highest attribute number
+ */
+enum nl80211_peer_measurement_ftm_capa {
+	__NL80211_PMSR_FTM_CAPA_ATTR_INVALID,
+
+	NL80211_PMSR_FTM_CAPA_ATTR_ASAP,
+	NL80211_PMSR_FTM_CAPA_ATTR_NON_ASAP,
+	NL80211_PMSR_FTM_CAPA_ATTR_REQ_LCI,
+	NL80211_PMSR_FTM_CAPA_ATTR_REQ_CIVICLOC,
+	NL80211_PMSR_FTM_CAPA_ATTR_PREAMBLES,
+	NL80211_PMSR_FTM_CAPA_ATTR_BANDWIDTHS,
+	NL80211_PMSR_FTM_CAPA_ATTR_MAX_BURSTS_EXPONENT,
+	NL80211_PMSR_FTM_CAPA_ATTR_MAX_FTMS_PER_BURST,
+	NL80211_PMSR_FTM_CAPA_ATTR_TRIGGER_BASED,
+	NL80211_PMSR_FTM_CAPA_ATTR_NON_TRIGGER_BASED,
+
+	/* keep last */
+	NUM_NL80211_PMSR_FTM_CAPA_ATTR,
+	NL80211_PMSR_FTM_CAPA_ATTR_MAX = NUM_NL80211_PMSR_FTM_CAPA_ATTR - 1
+};
+
+/**
+ * enum nl80211_peer_measurement_ftm_req - FTM request attributes
+ * @__NL80211_PMSR_FTM_REQ_ATTR_INVALID: invalid
+ *
+ * @NL80211_PMSR_FTM_REQ_ATTR_ASAP: ASAP mode requested (flag)
+ * @NL80211_PMSR_FTM_REQ_ATTR_PREAMBLE: preamble type (see
+ *	&enum nl80211_preamble), optional for DMG (u32)
+ * @NL80211_PMSR_FTM_REQ_ATTR_NUM_BURSTS_EXP: number of bursts exponent as in
+ *	802.11-2016 9.4.2.168 "Fine Timing Measurement Parameters element"
+ *	(u8, 0-15, optional with default 15 i.e. "no preference")
+ * @NL80211_PMSR_FTM_REQ_ATTR_BURST_PERIOD: interval between bursts in units
+ *	of 100ms (u16, optional with default 0)
+ * @NL80211_PMSR_FTM_REQ_ATTR_BURST_DURATION: burst duration, as in 802.11-2016
+ *	Table 9-257 "Burst Duration field encoding" (u8, 0-15, optional with
+ *	default 15 i.e. "no preference")
+ * @NL80211_PMSR_FTM_REQ_ATTR_FTMS_PER_BURST: number of successful FTM frames
+ *	requested per burst
+ *	(u8, 0-31, optional with default 0 i.e. "no preference")
+ * @NL80211_PMSR_FTM_REQ_ATTR_NUM_FTMR_RETRIES: number of FTMR frame retries
+ *	(u8, default 3)
+ * @NL80211_PMSR_FTM_REQ_ATTR_REQUEST_LCI: request LCI data (flag)
+ * @NL80211_PMSR_FTM_REQ_ATTR_REQUEST_CIVICLOC: request civic location data
+ *	(flag)
+ * @NL80211_PMSR_FTM_REQ_ATTR_TRIGGER_BASED: request trigger based ranging
+ *	measurement (flag).
+ *	This attribute and %NL80211_PMSR_FTM_REQ_ATTR_NON_TRIGGER_BASED are
+ *	mutually exclusive.
+ *      if neither %NL80211_PMSR_FTM_REQ_ATTR_TRIGGER_BASED nor
+ *	%NL80211_PMSR_FTM_REQ_ATTR_NON_TRIGGER_BASED is set, EDCA based
+ *	ranging will be used.
+ * @NL80211_PMSR_FTM_REQ_ATTR_NON_TRIGGER_BASED: request non trigger based
+ *	ranging measurement (flag)
+ *	This attribute and %NL80211_PMSR_FTM_REQ_ATTR_TRIGGER_BASED are
+ *	mutually exclusive.
+ *      if neither %NL80211_PMSR_FTM_REQ_ATTR_TRIGGER_BASED nor
+ *	%NL80211_PMSR_FTM_REQ_ATTR_NON_TRIGGER_BASED is set, EDCA based
+ *	ranging will be used.
+ * @NL80211_PMSR_FTM_REQ_ATTR_LMR_FEEDBACK: negotiate for LMR feedback. Only
+ *	valid if either %NL80211_PMSR_FTM_REQ_ATTR_TRIGGER_BASED or
+ *	%NL80211_PMSR_FTM_REQ_ATTR_NON_TRIGGER_BASED is set.
+ *
+ * @NUM_NL80211_PMSR_FTM_REQ_ATTR: internal
+ * @NL80211_PMSR_FTM_REQ_ATTR_MAX: highest attribute number
+ */
+enum nl80211_peer_measurement_ftm_req {
+	__NL80211_PMSR_FTM_REQ_ATTR_INVALID,
+
+	NL80211_PMSR_FTM_REQ_ATTR_ASAP,
+	NL80211_PMSR_FTM_REQ_ATTR_PREAMBLE,
+	NL80211_PMSR_FTM_REQ_ATTR_NUM_BURSTS_EXP,
+	NL80211_PMSR_FTM_REQ_ATTR_BURST_PERIOD,
+	NL80211_PMSR_FTM_REQ_ATTR_BURST_DURATION,
+	NL80211_PMSR_FTM_REQ_ATTR_FTMS_PER_BURST,
+	NL80211_PMSR_FTM_REQ_ATTR_NUM_FTMR_RETRIES,
+	NL80211_PMSR_FTM_REQ_ATTR_REQUEST_LCI,
+	NL80211_PMSR_FTM_REQ_ATTR_REQUEST_CIVICLOC,
+	NL80211_PMSR_FTM_REQ_ATTR_TRIGGER_BASED,
+	NL80211_PMSR_FTM_REQ_ATTR_NON_TRIGGER_BASED,
+	NL80211_PMSR_FTM_REQ_ATTR_LMR_FEEDBACK,
+
+	/* keep last */
+	NUM_NL80211_PMSR_FTM_REQ_ATTR,
+	NL80211_PMSR_FTM_REQ_ATTR_MAX = NUM_NL80211_PMSR_FTM_REQ_ATTR - 1
+};
+
+/**
+ * enum nl80211_peer_measurement_ftm_failure_reasons - FTM failure reasons
+ * @NL80211_PMSR_FTM_FAILURE_UNSPECIFIED: unspecified failure, not used
+ * @NL80211_PMSR_FTM_FAILURE_NO_RESPONSE: no response from the FTM responder
+ * @NL80211_PMSR_FTM_FAILURE_REJECTED: FTM responder rejected measurement
+ * @NL80211_PMSR_FTM_FAILURE_WRONG_CHANNEL: we already know the peer is
+ *	on a different channel, so can't measure (if we didn't know, we'd
+ *	try and get no response)
+ * @NL80211_PMSR_FTM_FAILURE_PEER_NOT_CAPABLE: peer can't actually do FTM
+ * @NL80211_PMSR_FTM_FAILURE_INVALID_TIMESTAMP: invalid T1/T4 timestamps
+ *	received
+ * @NL80211_PMSR_FTM_FAILURE_PEER_BUSY: peer reports busy, you may retry
+ *	later (see %NL80211_PMSR_FTM_RESP_ATTR_BUSY_RETRY_TIME)
+ * @NL80211_PMSR_FTM_FAILURE_BAD_CHANGED_PARAMS: parameters were changed
+ *	by the peer and are no longer supported
+ */
+enum nl80211_peer_measurement_ftm_failure_reasons {
+	NL80211_PMSR_FTM_FAILURE_UNSPECIFIED,
+	NL80211_PMSR_FTM_FAILURE_NO_RESPONSE,
+	NL80211_PMSR_FTM_FAILURE_REJECTED,
+	NL80211_PMSR_FTM_FAILURE_WRONG_CHANNEL,
+	NL80211_PMSR_FTM_FAILURE_PEER_NOT_CAPABLE,
+	NL80211_PMSR_FTM_FAILURE_INVALID_TIMESTAMP,
+	NL80211_PMSR_FTM_FAILURE_PEER_BUSY,
+	NL80211_PMSR_FTM_FAILURE_BAD_CHANGED_PARAMS,
+};
+
+/**
+ * enum nl80211_peer_measurement_ftm_resp - FTM response attributes
+ * @__NL80211_PMSR_FTM_RESP_ATTR_INVALID: invalid
+ *
+ * @NL80211_PMSR_FTM_RESP_ATTR_FAIL_REASON: FTM-specific failure reason
+ *	(u32, optional)
+ * @NL80211_PMSR_FTM_RESP_ATTR_BURST_INDEX: optional, if bursts are reported
+ *	as separate results then it will be the burst index 0...(N-1) and
+ *	the top level will indicate partial results (u32)
+ * @NL80211_PMSR_FTM_RESP_ATTR_NUM_FTMR_ATTEMPTS: number of FTM Request frames
+ *	transmitted (u32, optional)
+ * @NL80211_PMSR_FTM_RESP_ATTR_NUM_FTMR_SUCCESSES: number of FTM Request frames
+ *	that were acknowleged (u32, optional)
+ * @NL80211_PMSR_FTM_RESP_ATTR_BUSY_RETRY_TIME: retry time received from the
+ *	busy peer (u32, seconds)
+ * @NL80211_PMSR_FTM_RESP_ATTR_NUM_BURSTS_EXP: actual number of bursts exponent
+ *	used by the responder (similar to request, u8)
+ * @NL80211_PMSR_FTM_RESP_ATTR_BURST_DURATION: actual burst duration used by
+ *	the responder (similar to request, u8)
+ * @NL80211_PMSR_FTM_RESP_ATTR_FTMS_PER_BURST: actual FTMs per burst used
+ *	by the responder (similar to request, u8)
+ * @NL80211_PMSR_FTM_RESP_ATTR_RSSI_AVG: average RSSI across all FTM action
+ *	frames (optional, s32, 1/2 dBm)
+ * @NL80211_PMSR_FTM_RESP_ATTR_RSSI_SPREAD: RSSI spread across all FTM action
+ *	frames (optional, s32, 1/2 dBm)
+ * @NL80211_PMSR_FTM_RESP_ATTR_TX_RATE: bitrate we used for the response to the
+ *	FTM action frame (optional, nested, using &enum nl80211_rate_info
+ *	attributes)
+ * @NL80211_PMSR_FTM_RESP_ATTR_RX_RATE: bitrate the responder used for the FTM
+ *	action frame (optional, nested, using &enum nl80211_rate_info attrs)
+ * @NL80211_PMSR_FTM_RESP_ATTR_RTT_AVG: average RTT (s64, picoseconds, optional
+ *	but one of RTT/DIST must be present)
+ * @NL80211_PMSR_FTM_RESP_ATTR_RTT_VARIANCE: RTT variance (u64, ps^2, note that
+ *	standard deviation is the square root of variance, optional)
+ * @NL80211_PMSR_FTM_RESP_ATTR_RTT_SPREAD: RTT spread (u64, picoseconds,
+ *	optional)
+ * @NL80211_PMSR_FTM_RESP_ATTR_DIST_AVG: average distance (s64, mm, optional
+ *	but one of RTT/DIST must be present)
+ * @NL80211_PMSR_FTM_RESP_ATTR_DIST_VARIANCE: distance variance (u64, mm^2, note
+ *	that standard deviation is the square root of variance, optional)
+ * @NL80211_PMSR_FTM_RESP_ATTR_DIST_SPREAD: distance spread (u64, mm, optional)
+ * @NL80211_PMSR_FTM_RESP_ATTR_LCI: LCI data from peer (binary, optional);
+ *	this is the contents of the Measurement Report Element (802.11-2016
+ *	9.4.2.22.1) starting with the Measurement Token, with Measurement
+ *	Type 8.
+ * @NL80211_PMSR_FTM_RESP_ATTR_CIVICLOC: civic location data from peer
+ *	(binary, optional);
+ *	this is the contents of the Measurement Report Element (802.11-2016
+ *	9.4.2.22.1) starting with the Measurement Token, with Measurement
+ *	Type 11.
+ * @NL80211_PMSR_FTM_RESP_ATTR_PAD: ignore, for u64/s64 padding only
+ *
+ * @NUM_NL80211_PMSR_FTM_RESP_ATTR: internal
+ * @NL80211_PMSR_FTM_RESP_ATTR_MAX: highest attribute number
+ */
+enum nl80211_peer_measurement_ftm_resp {
+	__NL80211_PMSR_FTM_RESP_ATTR_INVALID,
+
+	NL80211_PMSR_FTM_RESP_ATTR_FAIL_REASON,
+	NL80211_PMSR_FTM_RESP_ATTR_BURST_INDEX,
+	NL80211_PMSR_FTM_RESP_ATTR_NUM_FTMR_ATTEMPTS,
+	NL80211_PMSR_FTM_RESP_ATTR_NUM_FTMR_SUCCESSES,
+	NL80211_PMSR_FTM_RESP_ATTR_BUSY_RETRY_TIME,
+	NL80211_PMSR_FTM_RESP_ATTR_NUM_BURSTS_EXP,
+	NL80211_PMSR_FTM_RESP_ATTR_BURST_DURATION,
+	NL80211_PMSR_FTM_RESP_ATTR_FTMS_PER_BURST,
+	NL80211_PMSR_FTM_RESP_ATTR_RSSI_AVG,
+	NL80211_PMSR_FTM_RESP_ATTR_RSSI_SPREAD,
+	NL80211_PMSR_FTM_RESP_ATTR_TX_RATE,
+	NL80211_PMSR_FTM_RESP_ATTR_RX_RATE,
+	NL80211_PMSR_FTM_RESP_ATTR_RTT_AVG,
+	NL80211_PMSR_FTM_RESP_ATTR_RTT_VARIANCE,
+	NL80211_PMSR_FTM_RESP_ATTR_RTT_SPREAD,
+	NL80211_PMSR_FTM_RESP_ATTR_DIST_AVG,
+	NL80211_PMSR_FTM_RESP_ATTR_DIST_VARIANCE,
+	NL80211_PMSR_FTM_RESP_ATTR_DIST_SPREAD,
+	NL80211_PMSR_FTM_RESP_ATTR_LCI,
+	NL80211_PMSR_FTM_RESP_ATTR_CIVICLOC,
+	NL80211_PMSR_FTM_RESP_ATTR_PAD,
+
+	/* keep last */
+	NUM_NL80211_PMSR_FTM_RESP_ATTR,
+	NL80211_PMSR_FTM_RESP_ATTR_MAX = NUM_NL80211_PMSR_FTM_RESP_ATTR - 1
+};
+
+/**
+ * enum nl80211_obss_pd_attributes - OBSS packet detection attributes
+ * @__NL80211_HE_OBSS_PD_ATTR_INVALID: Invalid
+ *
+ * @NL80211_HE_OBSS_PD_ATTR_MIN_OFFSET: the OBSS PD minimum tx power offset.
+ * @NL80211_HE_OBSS_PD_ATTR_MAX_OFFSET: the OBSS PD maximum tx power offset.
+ * @NL80211_HE_OBSS_PD_ATTR_NON_SRG_MAX_OFFSET: the non-SRG OBSS PD maximum
+ *	tx power offset.
+ * @NL80211_HE_OBSS_PD_ATTR_BSS_COLOR_BITMAP: bitmap that indicates the BSS color
+ *	values used by members of the SRG.
+ * @NL80211_HE_OBSS_PD_ATTR_PARTIAL_BSSID_BITMAP: bitmap that indicates the partial
+ *	BSSID values used by members of the SRG.
+ * @NL80211_HE_OBSS_PD_ATTR_SR_CTRL: The SR Control field of SRP element.
+ *
+ * @__NL80211_HE_OBSS_PD_ATTR_LAST: Internal
+ * @NL80211_HE_OBSS_PD_ATTR_MAX: highest OBSS PD attribute.
+ */
+enum nl80211_obss_pd_attributes {
+	__NL80211_HE_OBSS_PD_ATTR_INVALID,
+
+	NL80211_HE_OBSS_PD_ATTR_MIN_OFFSET,
+	NL80211_HE_OBSS_PD_ATTR_MAX_OFFSET,
+	NL80211_HE_OBSS_PD_ATTR_NON_SRG_MAX_OFFSET,
+	NL80211_HE_OBSS_PD_ATTR_BSS_COLOR_BITMAP,
+	NL80211_HE_OBSS_PD_ATTR_PARTIAL_BSSID_BITMAP,
+	NL80211_HE_OBSS_PD_ATTR_SR_CTRL,
+
+	/* keep last */
+	__NL80211_HE_OBSS_PD_ATTR_LAST,
+	NL80211_HE_OBSS_PD_ATTR_MAX = __NL80211_HE_OBSS_PD_ATTR_LAST - 1,
+};
+
+/**
+ * enum nl80211_bss_color_attributes - BSS Color attributes
+ * @__NL80211_HE_BSS_COLOR_ATTR_INVALID: Invalid
+ *
+ * @NL80211_HE_BSS_COLOR_ATTR_COLOR: the current BSS Color.
+ * @NL80211_HE_BSS_COLOR_ATTR_DISABLED: is BSS coloring disabled.
+ * @NL80211_HE_BSS_COLOR_ATTR_PARTIAL: the AID equation to be used..
+ *
+ * @__NL80211_HE_BSS_COLOR_ATTR_LAST: Internal
+ * @NL80211_HE_BSS_COLOR_ATTR_MAX: highest BSS Color attribute.
+ */
+enum nl80211_bss_color_attributes {
+	__NL80211_HE_BSS_COLOR_ATTR_INVALID,
+
+	NL80211_HE_BSS_COLOR_ATTR_COLOR,
+	NL80211_HE_BSS_COLOR_ATTR_DISABLED,
+	NL80211_HE_BSS_COLOR_ATTR_PARTIAL,
+
+	/* keep last */
+	__NL80211_HE_BSS_COLOR_ATTR_LAST,
+	NL80211_HE_BSS_COLOR_ATTR_MAX = __NL80211_HE_BSS_COLOR_ATTR_LAST - 1,
+};
+
+/**
+ * enum nl80211_iftype_akm_attributes - interface type AKM attributes
+ * @__NL80211_IFTYPE_AKM_ATTR_INVALID: Invalid
+ *
+ * @NL80211_IFTYPE_AKM_ATTR_IFTYPES: nested attribute containing a flag
+ *	attribute for each interface type that supports AKM suites specified in
+ *	%NL80211_IFTYPE_AKM_ATTR_SUITES
+ * @NL80211_IFTYPE_AKM_ATTR_SUITES: an array of u32. Used to indicate supported
+ *	AKM suites for the specified interface types.
+ *
+ * @__NL80211_IFTYPE_AKM_ATTR_LAST: Internal
+ * @NL80211_IFTYPE_AKM_ATTR_MAX: highest interface type AKM attribute.
+ */
+enum nl80211_iftype_akm_attributes {
+	__NL80211_IFTYPE_AKM_ATTR_INVALID,
+
+	NL80211_IFTYPE_AKM_ATTR_IFTYPES,
+	NL80211_IFTYPE_AKM_ATTR_SUITES,
+
+	/* keep last */
+	__NL80211_IFTYPE_AKM_ATTR_LAST,
+	NL80211_IFTYPE_AKM_ATTR_MAX = __NL80211_IFTYPE_AKM_ATTR_LAST - 1,
+};
+
+/**
+ * enum nl80211_fils_discovery_attributes - FILS discovery configuration
+ * from IEEE Std 802.11ai-2016, Annex C.3 MIB detail.
+ *
+ * @__NL80211_FILS_DISCOVERY_ATTR_INVALID: Invalid
+ *
+ * @NL80211_FILS_DISCOVERY_ATTR_INT_MIN: Minimum packet interval (u32, TU).
+ *	Allowed range: 0..10000 (TU = Time Unit)
+ * @NL80211_FILS_DISCOVERY_ATTR_INT_MAX: Maximum packet interval (u32, TU).
+ *	Allowed range: 0..10000 (TU = Time Unit)
+ * @NL80211_FILS_DISCOVERY_ATTR_TMPL: Template data for FILS discovery action
+ *	frame including the headers.
+ *
+ * @__NL80211_FILS_DISCOVERY_ATTR_LAST: Internal
+ * @NL80211_FILS_DISCOVERY_ATTR_MAX: highest attribute
+ */
+enum nl80211_fils_discovery_attributes {
+	__NL80211_FILS_DISCOVERY_ATTR_INVALID,
+
+	NL80211_FILS_DISCOVERY_ATTR_INT_MIN,
+	NL80211_FILS_DISCOVERY_ATTR_INT_MAX,
+	NL80211_FILS_DISCOVERY_ATTR_TMPL,
+
+	/* keep last */
+	__NL80211_FILS_DISCOVERY_ATTR_LAST,
+	NL80211_FILS_DISCOVERY_ATTR_MAX = __NL80211_FILS_DISCOVERY_ATTR_LAST - 1
+};
+
+/*
+ * FILS discovery template minimum length with action frame headers and
+ * mandatory fields.
+ */
+#define NL80211_FILS_DISCOVERY_TMPL_MIN_LEN 42
+
+/**
+ * enum nl80211_unsol_bcast_probe_resp_attributes - Unsolicited broadcast probe
+ *	response configuration. Applicable only in 6GHz.
+ *
+ * @__NL80211_UNSOL_BCAST_PROBE_RESP_ATTR_INVALID: Invalid
+ *
+ * @NL80211_UNSOL_BCAST_PROBE_RESP_ATTR_INT: Maximum packet interval (u32, TU).
+ *	Allowed range: 0..20 (TU = Time Unit). IEEE P802.11ax/D6.0
+ *	26.17.2.3.2 (AP behavior for fast passive scanning).
+ * @NL80211_UNSOL_BCAST_PROBE_RESP_ATTR_TMPL: Unsolicited broadcast probe response
+ *	frame template (binary).
+ *
+ * @__NL80211_UNSOL_BCAST_PROBE_RESP_ATTR_LAST: Internal
+ * @NL80211_UNSOL_BCAST_PROBE_RESP_ATTR_MAX: highest attribute
+ */
+enum nl80211_unsol_bcast_probe_resp_attributes {
+	__NL80211_UNSOL_BCAST_PROBE_RESP_ATTR_INVALID,
+
+	NL80211_UNSOL_BCAST_PROBE_RESP_ATTR_INT,
+	NL80211_UNSOL_BCAST_PROBE_RESP_ATTR_TMPL,
+
+	/* keep last */
+	__NL80211_UNSOL_BCAST_PROBE_RESP_ATTR_LAST,
+	NL80211_UNSOL_BCAST_PROBE_RESP_ATTR_MAX =
+		__NL80211_UNSOL_BCAST_PROBE_RESP_ATTR_LAST - 1
+};
+
+/**
+ * enum nl80211_sae_pwe_mechanism - The mechanism(s) allowed for SAE PWE
+ *	derivation. Applicable only when WPA3-Personal SAE authentication is
+ *	used.
+ *
+ * @NL80211_SAE_PWE_UNSPECIFIED: not specified, used internally to indicate that
+ *	attribute is not present from userspace.
+ * @NL80211_SAE_PWE_HUNT_AND_PECK: hunting-and-pecking loop only
+ * @NL80211_SAE_PWE_HASH_TO_ELEMENT: hash-to-element only
+ * @NL80211_SAE_PWE_BOTH: both hunting-and-pecking loop and hash-to-element
+ *	can be used.
+ */
+enum nl80211_sae_pwe_mechanism {
+	NL80211_SAE_PWE_UNSPECIFIED,
+	NL80211_SAE_PWE_HUNT_AND_PECK,
+	NL80211_SAE_PWE_HASH_TO_ELEMENT,
+	NL80211_SAE_PWE_BOTH,
+};
+
+/**
+ * enum nl80211_sar_type - type of SAR specs
+ *
+ * @NL80211_SAR_TYPE_POWER: power limitation specified in 0.25dBm unit
+ *
+ */
+enum nl80211_sar_type {
+	NL80211_SAR_TYPE_POWER,
+
+	/* add new type here */
+
+	/* Keep last */
+	NUM_NL80211_SAR_TYPE,
+};
+
+/**
+ * enum nl80211_sar_attrs - Attributes for SAR spec
+ *
+ * @NL80211_SAR_ATTR_TYPE: the SAR type as defined in &enum nl80211_sar_type.
+ *
+ * @NL80211_SAR_ATTR_SPECS: Nested array of SAR power
+ *	limit specifications. Each specification contains a set
+ *	of %nl80211_sar_specs_attrs.
+ *
+ *	For SET operation, it contains array of %NL80211_SAR_ATTR_SPECS_POWER
+ *	and %NL80211_SAR_ATTR_SPECS_RANGE_INDEX.
+ *
+ *	For sar_capa dump, it contains array of
+ *	%NL80211_SAR_ATTR_SPECS_START_FREQ
+ *	and %NL80211_SAR_ATTR_SPECS_END_FREQ.
+ *
+ * @__NL80211_SAR_ATTR_LAST: Internal
+ * @NL80211_SAR_ATTR_MAX: highest sar attribute
+ *
+ * These attributes are used with %NL80211_CMD_SET_SAR_SPEC
+ */
+enum nl80211_sar_attrs {
+	__NL80211_SAR_ATTR_INVALID,
+
+	NL80211_SAR_ATTR_TYPE,
+	NL80211_SAR_ATTR_SPECS,
+
+	__NL80211_SAR_ATTR_LAST,
+	NL80211_SAR_ATTR_MAX = __NL80211_SAR_ATTR_LAST - 1,
+};
+
+/**
+ * enum nl80211_sar_specs_attrs - Attributes for SAR power limit specs
+ *
+ * @NL80211_SAR_ATTR_SPECS_POWER: Required (s32)value to specify the actual
+ *	power limit value in units of 0.25 dBm if type is
+ *	NL80211_SAR_TYPE_POWER. (i.e., a value of 44 represents 11 dBm).
+ *	0 means userspace doesn't have SAR limitation on this associated range.
+ *
+ * @NL80211_SAR_ATTR_SPECS_RANGE_INDEX: Required (u32) value to specify the
+ *	index of exported freq range table and the associated power limitation
+ *	is applied to this range.
+ *
+ *	Userspace isn't required to set all the ranges advertised by WLAN driver,
+ *	and userspace can skip some certain ranges. These skipped ranges don't
+ *	have SAR limitations, and they are same as setting the
+ *	%NL80211_SAR_ATTR_SPECS_POWER to any unreasonable high value because any
+ *	value higher than regulatory allowed value just means SAR power
+ *	limitation is removed, but it's required to set at least one range.
+ *	It's not allowed to set duplicated range in one SET operation.
+ *
+ *	Every SET operation overwrites previous SET operation.
+ *
+ * @NL80211_SAR_ATTR_SPECS_START_FREQ: Required (u32) value to specify the start
+ *	frequency of this range edge when registering SAR capability to wiphy.
+ *	It's not a channel center frequency. The unit is kHz.
+ *
+ * @NL80211_SAR_ATTR_SPECS_END_FREQ: Required (u32) value to specify the end
+ *	frequency of this range edge when registering SAR capability to wiphy.
+ *	It's not a channel center frequency. The unit is kHz.
+ *
+ * @__NL80211_SAR_ATTR_SPECS_LAST: Internal
+ * @NL80211_SAR_ATTR_SPECS_MAX: highest sar specs attribute
+ */
+enum nl80211_sar_specs_attrs {
+	__NL80211_SAR_ATTR_SPECS_INVALID,
+
+	NL80211_SAR_ATTR_SPECS_POWER,
+	NL80211_SAR_ATTR_SPECS_RANGE_INDEX,
+	NL80211_SAR_ATTR_SPECS_START_FREQ,
+	NL80211_SAR_ATTR_SPECS_END_FREQ,
+
+	__NL80211_SAR_ATTR_SPECS_LAST,
+	NL80211_SAR_ATTR_SPECS_MAX = __NL80211_SAR_ATTR_SPECS_LAST - 1,
+};
+
 #endif /* __LINUX_NL80211_H */
--- a/include/uapi/linux/pkt_cls.h
+++ b/include/uapi/linux/pkt_cls.h
@@ -260,11 +260,16 @@ enum {
 	TCA_FW_INDEV, /*  used by CONFIG_NET_CLS_IND */
 	TCA_FW_ACT, /* used by CONFIG_NET_CLS_ACT */
 	TCA_FW_MASK,
+	TCA_FW_FMASK,
+	TCA_FW_FSHIFT,
+	TCA_FW_FLAGS,
 	__TCA_FW_MAX
 };
 
 #define TCA_FW_MAX (__TCA_FW_MAX - 1)
 
+#define TCA_FW_FLAG_UBNT_MARK (1 << 0) /* use ubnt_mark instead of skb->mark */
+
 /* TC index filter */
 
 enum {
--- a/include/uapi/linux/rtnetlink.h
+++ b/include/uapi/linux/rtnetlink.h
@@ -142,6 +142,9 @@ enum {
 	RTM_GETNSID = 90,
 #define RTM_GETNSID RTM_GETNSID
 
+	RTM_LOOP = 91,
+#define RTM_LOOP RTM_LOOP
+
 	RTM_NEWSTATS = 92,
 #define RTM_NEWSTATS RTM_NEWSTATS
 	RTM_GETSTATS = 94,
@@ -514,6 +517,21 @@ struct ifinfomsg {
 	unsigned	ifi_change;		/* IFF_* change mask */
 };
 
+/*
+ * struct phymsg
+ * passes ethernet phy level information
+ */
+
+struct phymsg {
+	unsigned char switch_idx;
+	unsigned char port_idx;
+	unsigned char status;
+};
+
+struct loopmsg {
+	unsigned char loop;
+};
+
 /********************************************************************
  *		prefix information 
  ****/
--- a/include/uapi/linux/sockios.h
+++ b/include/uapi/linux/sockios.h
@@ -143,8 +143,8 @@
  *	THESE IOCTLS ARE _DEPRECATED_ AND WILL DISAPPEAR IN 2.5.X -DaveM
  */
  
-#define SIOCDEVPRIVATE	0x89F0	/* to 89FF */
-
+#define SIOCDEVPRIVATE		0x89F0	/* UBNT - to 8AFF */
+#define SIOCDEVPRIVATE_LEN	0x10F
 /*
  *	These 16 ioctl calls are protocol private
  */
--- a/include/uapi/linux/wireless.h
+++ b/include/uapi/linux/wireless.h
@@ -557,7 +557,7 @@
 #define IW_SCAN_CAPA_TIME		0x40
 
 /* Max number of char in custom event - use multiple of them if needed */
-#define IW_CUSTOM_MAX		256	/* In bytes */
+#define IW_CUSTOM_MAX		2048	/* In bytes */ /* UBNT: increased from 256 */
 
 /* Generic information element */
 #define IW_GENERIC_IE_MAX	1024
@@ -944,6 +944,10 @@ struct iwreq {
 
 	/* Data part (defined just above) */
 	union iwreq_data	u;
+#ifdef __aarch64__
+    /* For aligning to ifreq size in 64 bit platform */
+     __u32   reserved[2];
+#endif
 };
 
 /* -------------------------- IOCTL DATA -------------------------- */
--- a/init/main.c
+++ b/init/main.c
@@ -133,6 +133,7 @@ void (*__initdata late_time_init)(void);
 char __initdata boot_command_line[COMMAND_LINE_SIZE];
 /* Untouched saved command line (eg. for /proc) */
 char *saved_command_line;
+EXPORT_SYMBOL(saved_command_line);
 /* Command line for parameter parsing */
 static char *static_command_line;
 /* Command line for per-initcall parameter parsing */
--- a/kernel/panic.c
+++ b/kernel/panic.c
@@ -31,6 +31,10 @@
 #include <linux/debugfs.h>
 #include <asm/sections.h>
 
+#if defined(CONFIG_UBNT_REBOOT_REASON)
+#include <linux/resvmem_reboot.h>
+#endif
+
 #define PANIC_TIMER_STEP 100
 #define PANIC_BLINK_SPD 18
 
@@ -268,6 +272,9 @@ void panic(const char *fmt, ...)
 				i_next = i + 3600 / PANIC_BLINK_SPD;
 			}
 			mdelay(PANIC_TIMER_STEP);
+#if defined(CONFIG_UBNT_REBOOT_REASON)
+		resvmem_set_reboot_reason(RESVMEM_REBOOT_KERNEL_PANIC);
+#endif
 		}
 	}
 	if (panic_timeout != 0) {
--- a/kernel/reboot.c
+++ b/kernel/reboot.c
@@ -17,6 +17,9 @@
 #include <linux/syscore_ops.h>
 #include <linux/uaccess.h>
 
+#if defined(CONFIG_UBNT_REBOOT_REASON)
+#include <linux/resvmem_reboot.h>
+#endif
 /*
  * this indicates whether you can reboot with ctrl-alt-del: the default is yes
  */
@@ -240,6 +243,9 @@ void migrate_to_reboot_cpu(void)
  */
 void kernel_restart(char *cmd)
 {
+#if defined(CONFIG_UBNT_REBOOT_REASON)
+	resvmem_set_reboot_reason(RESVMEM_REBOOT_USER_MANUAL);
+#endif
 	kernel_restart_prepare(cmd);
 	migrate_to_reboot_cpu();
 	syscore_shutdown();
@@ -296,6 +302,63 @@ EXPORT_SYMBOL_GPL(kernel_power_off);
 
 DEFINE_MUTEX(system_transition_mutex);
 
+static void print_reboot_calling_pids(unsigned int cmd)
+{
+	struct task_struct *task;
+	char *pre_cmd;
+
+	switch (cmd) {
+	case LINUX_REBOOT_CMD_CAD_ON:
+	case LINUX_REBOOT_CMD_CAD_OFF:
+		// ignore the C_A_D setters
+		return;
+	}
+	// inverted commands are used only to print task pids
+	switch (~cmd) {
+	case LINUX_REBOOT_CMD_RESTART:
+	case LINUX_REBOOT_CMD_HALT:
+	case LINUX_REBOOT_CMD_CAD_ON:
+	case LINUX_REBOOT_CMD_CAD_OFF:
+	case LINUX_REBOOT_CMD_POWER_OFF:
+	case LINUX_REBOOT_CMD_RESTART2:
+	case LINUX_REBOOT_CMD_SW_SUSPEND:
+	case LINUX_REBOOT_CMD_KEXEC:
+		pre_cmd = "pre-";
+		cmd = ~cmd;
+		break;
+	default:
+		pre_cmd = "";
+		break;
+	}
+	pr_emerg("%scmd=%08x\n", pre_cmd, cmd);
+
+	for (task = current; task; task = task->real_parent) {
+		char * cmd_ptr;
+		char cmd_buf[128];
+		int cmd_len = get_cmdline(task, cmd_buf, sizeof(cmd_buf) - 1);
+		// strip off all tailing null chars
+		while (cmd_len > 0 && (cmd_buf[cmd_len - 1] == '\0')) {
+			cmd_len--;
+		}
+		// turn all null chars to spaces
+		for (cmd_ptr = cmd_buf; cmd_len > 0; cmd_ptr++, cmd_len--) {
+			if (*cmd_ptr == '\0') {
+				*cmd_ptr = ' ';
+			}
+		}
+		*cmd_ptr = '\0';
+		cmd_ptr = cmd_buf;
+		if (*cmd_ptr == '\0') {
+			// fallback to task->comm
+			cmd_ptr = task->comm;
+		}
+
+		pr_emerg("  called by: [%5d]%s\n", task_pid_nr(task), cmd_buf);
+		if (task == task->real_parent)
+			break;
+	}
+}
+
 /*
  * Reboot system call: for obvious reasons only root may call it,
  * and even root needs to set up some magic numbers in the registers
@@ -323,6 +386,7 @@ SYSCALL_DEFINE4(reboot, int, magic1, int
 			magic2 != LINUX_REBOOT_MAGIC2C))
 		return -EINVAL;
 
+	print_reboot_calling_pids(cmd);
 	/*
 	 * If pid namespaces are enabled and the current task is in a child
 	 * pid_namespace, the command is handled by reboot_pid_ns() which will
--- a/net/Kconfig
+++ b/net/Kconfig
@@ -25,6 +25,12 @@ menuconfig NET
 
 if NET
 
+config ETHERNET_PACKET_MANGLE
+	bool
+	help
+	  This option can be selected by phy drivers that need to mangle
+	  packets going in or out of an ethernet device.
+
 config WANT_COMPAT_NETLINK_MESSAGES
 	bool
 	help
@@ -112,6 +118,15 @@ config NETWORK_PHY_TIMESTAMPING
 
 	  If you are unsure how to answer this question, answer N.
 
+config LLDP_RX_DROP_COUNTER
+	bool "Separate counter for dropped lldp Rx packets"
+	default y
+	help
+	  UBNT hotfix for UDM-177.
+	  LLDP frames will increase 'rx_drop' count for switch0.1 on UDM,
+	  even if try to read them with lldpd exclusively on this interface.
+	  Users DDoS tech support about "why the device drops MY traffic"
+
 menuconfig NETFILTER
 	bool "Network packet filtering framework (Netfilter)"
 	---help---
--- a/net/bluetooth/Kconfig
+++ b/net/bluetooth/Kconfig
@@ -126,4 +126,13 @@ config BT_DEBUGFS
 	  Provide extensive information about internal Bluetooth states
 	  in debugfs.
 
+config BT_NORDIC_QUIRK_LOOKUP_FIX
+	bool "Quirk for Nordic to lookup device"
+	depends on BT
+	help
+	  nRF82532 only provides link type SCO instead of ACL which results in
+	  HCI layer not able to lookup devices correctly. This feature is to fix
+	  this case.
+
+
 source "drivers/bluetooth/Kconfig"
--- a/net/bluetooth/hci_event.c
+++ b/net/bluetooth/hci_event.c
@@ -5222,7 +5222,8 @@ static void process_adv_report(struct hc
 
 	/* Adjust for actual length */
 	if (len != real_len) {
-		bt_dev_err_ratelimited(hdev, "advertising data len corrected");
+		bt_dev_dbg(hdev, "advertising data len corrected  %u -> %u",
+				len, real_len);
 		len = real_len;
 	}
 
--- a/net/bridge/br_fdb.c
+++ b/net/bridge/br_fdb.c
@@ -202,6 +202,9 @@ static void fdb_delete(struct net_bridge
 {
 	trace_fdb_delete(br, f);
 
+	if (br_handle_entry_hook)
+		br_handle_entry_hook(NULL, (void *)f, BR_FDB_ENTRY_DEL, NULL);
+
 	if (f->is_static)
 		fdb_del_hw_addr(br, f->key.addr.addr);
 
@@ -505,6 +508,7 @@ static struct net_bridge_fdb_entry *fdb_
 		fdb->added_by_external_learn = 0;
 		fdb->offloaded = 0;
 		fdb->updated = fdb->used = jiffies;
+		fdb->flags = 0;
 		if (rhashtable_lookup_insert_fast(&br->fdb_hash_tbl,
 						  &fdb->rhnode,
 						  br_fdb_rht_params)) {
@@ -558,28 +562,35 @@ int br_fdb_insert(struct net_bridge *br,
 	return ret;
 }
 
-void br_fdb_update(struct net_bridge *br, struct net_bridge_port *source,
-		   const unsigned char *addr, u16 vid, bool added_by_user)
+int (*ubnt_loop_event)(struct net_device *dev);
+EXPORT_SYMBOL(ubnt_loop_event);
+
+struct net_bridge_fdb_entry *br_fdb_update(struct net_bridge *br, struct net_bridge_port *source,
+					   const unsigned char *addr, u16 vid, bool added_by_user, void *context)
 {
 	struct net_bridge_fdb_entry *fdb;
 	bool fdb_modified = false;
 
 	/* some users want to always flood. */
 	if (hold_time(br) == 0)
-		return;
+		return NULL;
 
 	/* ignore packets unless we are using this port */
 	if (!(source->state == BR_STATE_LEARNING ||
 	      source->state == BR_STATE_FORWARDING))
-		return;
+		return NULL;
 
 	fdb = fdb_find_rcu(&br->fdb_hash_tbl, addr, vid);
 	if (likely(fdb)) {
 		/* attempt to update an entry for a local interface */
 		if (unlikely(fdb->is_local)) {
-			if (net_ratelimit())
+			if (net_ratelimit()) {
+				if (ubnt_loop_event)
+					ubnt_loop_event(source->dev);
+
 				br_warn(br, "received packet on %s with own address as source address (addr:%pM, vlan:%u)\n",
 					source->dev->name, addr, vid);
+			}
 		} else {
 			unsigned long now = jiffies;
 
@@ -602,6 +613,8 @@ void br_fdb_update(struct net_bridge *br
 		}
 	} else {
 		spin_lock(&br->hash_lock);
+		if (fdb && br_handle_entry_hook && context)
+			br_handle_entry_hook(source, (void *)fdb, BR_FDB_ENTRY_ADD, context);
 		fdb = fdb_create(br, source, addr, vid, 0, 0);
 		if (fdb) {
 			if (unlikely(added_by_user))
@@ -615,6 +628,7 @@ void br_fdb_update(struct net_bridge *br
 		 */
 		spin_unlock(&br->hash_lock);
 	}
+	return fdb;
 }
 
 static int fdb_to_nud(const struct net_bridge *br,
@@ -857,7 +871,7 @@ static int __br_fdb_add(struct ndmsg *nd
 		}
 		local_bh_disable();
 		rcu_read_lock();
-		br_fdb_update(br, p, addr, vid, true);
+		br_fdb_update(br, p, addr, vid, true, NULL);
 		rcu_read_unlock();
 		local_bh_enable();
 	} else if (ndm->ndm_flags & NTF_EXT_LEARNED) {
--- a/net/bridge/br_input.c
+++ b/net/bridge/br_input.c
@@ -27,6 +27,10 @@
 br_should_route_hook_t __rcu *br_should_route_hook __read_mostly;
 EXPORT_SYMBOL(br_should_route_hook);
 
+/* UBNT bridge hook */
+br_handle_entry_hook_t *br_handle_entry_hook;
+EXPORT_SYMBOL(br_handle_entry_hook);
+
 static int
 br_netif_receive_skb(struct net *net, struct sock *sk, struct sk_buff *skb)
 {
@@ -83,13 +87,13 @@ int br_handle_frame_finish(struct net *n
 {
 	struct net_bridge_port *p = br_port_get_rcu(skb->dev);
 	enum br_pkt_type pkt_type = BR_PKT_UNICAST;
-	struct net_bridge_fdb_entry *dst = NULL;
+	struct net_bridge_fdb_entry *dst = NULL, *src = NULL;
 	struct net_bridge_mdb_entry *mdst;
 	bool local_rcv, mcast_hit = false;
 	struct net_bridge *br;
 	u16 vid = 0;
 
-	if (!p || p->state == BR_STATE_DISABLED)
+	if (!p || (p->state == BR_STATE_DISABLED && skb->protocol != htons(ETH_P_PAE)))
 		goto drop;
 
 	if (!br_allowed_ingress(p->br, nbp_vlan_group_rcu(p), skb, &vid))
@@ -99,8 +103,11 @@ int br_handle_frame_finish(struct net *n
 
 	/* insert into forwarding database after filtering to avoid spoofing */
 	br = p->br;
-	if (p->flags & BR_LEARNING)
-		br_fdb_update(br, p, eth_hdr(skb)->h_source, vid, false);
+	if (p->flags & BR_LEARNING) {
+		src = br_fdb_update(br, p, eth_hdr(skb)->h_source, vid, false, skb);
+		if (src && br_handle_entry_hook)
+			br_handle_entry_hook(p, (void *)src, BR_FDB_ENTRY_SRC, skb);
+	}
 
 	local_rcv = !!(br->dev->flags & IFF_PROMISC);
 	if (is_multicast_ether_addr(eth_hdr(skb)->h_dest)) {
@@ -168,8 +175,14 @@ int br_handle_frame_finish(struct net *n
 
 		if (now != dst->used)
 			dst->used = now;
+
+		if (br_handle_entry_hook)
+			br_handle_entry_hook(dst->dst, (void *)dst, BR_FDB_ENTRY_DST, skb);
 		br_forward(dst->dst, skb, local_rcv, false);
 	} else {
+		if (src && br_handle_entry_hook)
+			br_handle_entry_hook(p, (void *)src, BR_FDB_ENTRY_FWD, skb);
+
 		if (!mcast_hit)
 			br_flood(br, skb, pkt_type, local_rcv, false);
 		else
@@ -194,7 +207,7 @@ static void __br_handle_local_finish(str
 
 	/* check if vlan is allowed, to avoid spoofing */
 	if (p->flags & BR_LEARNING && br_should_learn(p, skb, &vid))
-		br_fdb_update(p->br, p, eth_hdr(skb)->h_source, vid, false);
+		br_fdb_update(p->br, p, eth_hdr(skb)->h_source, vid, false, skb);
 }
 
 /* note: already called with rcu_read_lock */
@@ -216,6 +229,7 @@ rx_handler_result_t br_handle_frame(stru
 	struct sk_buff *skb = *pskb;
 	const unsigned char *dest = eth_hdr(skb)->h_dest;
 	br_should_route_hook_t *rhook;
+	u8 state;
 
 	if (unlikely(skb->pkt_type == PACKET_LOOPBACK))
 		return RX_HANDLER_PASS;
@@ -295,7 +309,12 @@ rx_handler_result_t br_handle_frame(stru
 	}
 
 forward:
-	switch (p->state) {
+	if (likely(skb->protocol != htons(ETH_P_PAE)))
+		state = p->state;
+	else
+		state = BR_STATE_FORWARDING;
+
+	switch (state) {
 	case BR_STATE_FORWARDING:
 		rhook = rcu_dereference(br_should_route_hook);
 		if (rhook) {
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -168,6 +168,14 @@ struct net_bridge_vlan_group {
 	u16				pvid;
 };
 
+enum {
+	BR_FDB_ENTRY_ADD = 0,
+	BR_FDB_ENTRY_DEL,
+	BR_FDB_ENTRY_SRC,
+	BR_FDB_ENTRY_DST,
+	BR_FDB_ENTRY_FWD,
+};
+
 struct net_bridge_fdb_key {
 	mac_addr addr;
 	u16 vlan_id;
@@ -188,6 +196,7 @@ struct net_bridge_fdb_entry {
 	/* write-heavy members should not affect lookups */
 	unsigned long			updated ____cacheline_aligned_in_smp;
 	unsigned long			used;
+	unsigned long			flags;
 
 	struct rcu_head			rcu;
 };
@@ -546,8 +555,8 @@ int br_fdb_fillbuf(struct net_bridge *br
 		   unsigned long off);
 int br_fdb_insert(struct net_bridge *br, struct net_bridge_port *source,
 		  const unsigned char *addr, u16 vid);
-void br_fdb_update(struct net_bridge *br, struct net_bridge_port *source,
-		   const unsigned char *addr, u16 vid, bool added_by_user);
+struct net_bridge_fdb_entry *br_fdb_update(struct net_bridge *br, struct net_bridge_port *source,
+		                           const unsigned char *addr, u16 vid, bool added_by_user, void *context);
 
 int br_fdb_delete(struct ndmsg *ndm, struct nlattr *tb[],
 		  struct net_device *dev, const unsigned char *addr, u16 vid);
--- a/net/bridge/br_stp_bpdu.c
+++ b/net/bridge/br_stp_bpdu.c
@@ -139,6 +139,10 @@ void br_send_tcn_bpdu(struct net_bridge_
 	br_send_bpdu(p, buf, 4);
 }
 
+//: UBNT loop detection
+void (*ubnt_loop_detection)(struct sk_buff *skb, struct net_device *dev);
+EXPORT_SYMBOL(ubnt_loop_detection);
+
 /*
  * Called from llc.
  *
@@ -154,6 +158,9 @@ void br_stp_rcv(const struct stp_proto *
 	if (!pskb_may_pull(skb, 4))
 		goto err;
 
+	if (ubnt_loop_detection)
+		ubnt_loop_detection(skb, dev);
+
 	/* compare of protocol id and version */
 	buf = skb->data;
 	if (buf[0] != 0 || buf[1] != 0 || buf[2] != 0)
--- a/net/bridge/netfilter/Kconfig
+++ b/net/bridge/netfilter/Kconfig
@@ -150,6 +150,17 @@ config BRIDGE_EBT_VLAN
 	  802.1Q vlan fields.
 
 	  To compile it as a module, choose M here.  If unsure, say N.
+
+config BRIDGE_EBT_SET
+	tristate "ebt: set support"
+	depends on IP_SET
+	help
+	  This option adds set match.
+
+	  Using this match, you can match
+	  elements in the sets created by ipset(8).
+
+	  To compile it as a module, choose M here.  If unsure, say N.
 #
 # targets
 #
--- a/net/bridge/netfilter/Makefile
+++ b/net/bridge/netfilter/Makefile
@@ -26,6 +26,7 @@ obj-$(CONFIG_BRIDGE_EBT_MARK) += ebt_mar
 obj-$(CONFIG_BRIDGE_EBT_PKTTYPE) += ebt_pkttype.o
 obj-$(CONFIG_BRIDGE_EBT_STP) += ebt_stp.o
 obj-$(CONFIG_BRIDGE_EBT_VLAN) += ebt_vlan.o
+obj-$(CONFIG_BRIDGE_EBT_SET) += ebt_set.o
 
 # targets
 obj-$(CONFIG_BRIDGE_EBT_ARPREPLY) += ebt_arpreply.o
--- a/net/bridge/netfilter/ebt_mark.c
+++ b/net/bridge/netfilter/ebt_mark.c
@@ -30,8 +30,16 @@ ebt_mark_tg(struct sk_buff *skb, const s
 		skb->mark |= info->mark;
 	else if (action == MARK_AND_VALUE)
 		skb->mark &= info->mark;
-	else
+	else if (action == MARK_XOR_VALUE)
 		skb->mark ^= info->mark;
+	else if (action == MARK_UBNT_SET_VALUE)
+		skb->ubnt_mark = info->mark;
+	else if (action == MARK_UBNT_OR_VALUE)
+		skb->ubnt_mark |= info->mark;
+	else if (action == MARK_UBNT_AND_VALUE)
+		skb->ubnt_mark &= info->mark;
+	else if (action == MARK_UBNT_XOR_VALUE)
+		skb->ubnt_mark ^= info->mark;
 
 	return info->target | ~EBT_VERDICT_BITS;
 }
@@ -48,7 +56,9 @@ static int ebt_mark_tg_check(const struc
 		return -EINVAL;
 	tmp = info->target & ~EBT_VERDICT_BITS;
 	if (tmp != MARK_SET_VALUE && tmp != MARK_OR_VALUE &&
-	    tmp != MARK_AND_VALUE && tmp != MARK_XOR_VALUE)
+	    tmp != MARK_AND_VALUE && tmp != MARK_XOR_VALUE &&
+	    tmp != MARK_UBNT_SET_VALUE && tmp != MARK_UBNT_OR_VALUE &&
+	    tmp != MARK_UBNT_AND_VALUE && tmp != MARK_UBNT_XOR_VALUE)
 		return -EINVAL;
 	return 0;
 }
--- a/net/core/dev.c
+++ b/net/core/dev.c
@@ -3259,10 +3259,20 @@ static int xmit_one(struct sk_buff *skb,
 	if (!list_empty(&ptype_all) || !list_empty(&dev->ptype_all))
 		dev_queue_xmit_nit(skb, dev);
 
-	len = skb->len;
-	trace_net_dev_start_xmit(skb, dev);
-	rc = netdev_start_xmit(skb, dev, txq, more);
-	trace_net_dev_xmit(skb, rc, dev, len);
+#ifdef CONFIG_ETHERNET_PACKET_MANGLE
+	if (!dev->eth_mangle_tx ||
+	    (skb = dev->eth_mangle_tx(dev, skb)) != NULL)
+#else
+	if (1)
+#endif
+	{
+		len = skb->len;
+		trace_net_dev_start_xmit(skb, dev);
+		rc = netdev_start_xmit(skb, dev, txq, more);
+		trace_net_dev_xmit(skb, rc, dev, len);
+	} else {
+		rc = NETDEV_TX_OK;
+	}
 
 	return rc;
 }
@@ -3768,6 +3778,9 @@ struct netdev_queue *netdev_pick_tx(stru
  *      the BH enable code must have IRQs enabled so that it will not deadlock.
  *          --BLG
  */
+//: UBNT frame id
+void (*ubnt_frame_id_check)(struct sk_buff *skb, struct net_device *dev);
+EXPORT_SYMBOL(ubnt_frame_id_check);
 static int __dev_queue_xmit(struct sk_buff *skb, struct net_device *sb_dev)
 {
 	struct net_device *dev = skb->dev;
@@ -3781,6 +3794,8 @@ static int __dev_queue_xmit(struct sk_bu
 	if (unlikely(skb_shinfo(skb)->tx_flags & SKBTX_SCHED_TSTAMP))
 		__skb_tstamp_tx(skb, NULL, skb->sk, SCM_TSTAMP_SCHED);
 
+	if (ubnt_frame_id_check)
+		ubnt_frame_id_check(skb, dev);
 	/* Disable soft irqs for various locks below. Also
 	 * stops preemption for RCU.
 	 */
@@ -4932,10 +4947,21 @@ skip_classify:
 		*ppt_prev = pt_prev;
 	} else {
 drop:
+#ifdef CONFIG_LLDP_RX_DROP_COUNTER
+		switch (skb->protocol) {
+		case htons(ETH_P_LLDP):
+			atomic_long_inc(&skb->dev->rx_lldp_dropped);
+			break;
+		default:
+#endif
 		if (!deliver_exact)
 			atomic_long_inc(&skb->dev->rx_dropped);
 		else
 			atomic_long_inc(&skb->dev->rx_nohandler);
+#ifdef CONFIG_LLDP_RX_DROP_COUNTER
+			break;
+		}
+#endif
 		kfree_skb(skb);
 		/* Jamal, now you will not able to escape explaining
 		 * me how you were going to use this. :-)
@@ -9078,6 +9104,9 @@ struct rtnl_link_stats64 *dev_get_stats(
 	storage->rx_dropped += (unsigned long)atomic_long_read(&dev->rx_dropped);
 	storage->tx_dropped += (unsigned long)atomic_long_read(&dev->tx_dropped);
 	storage->rx_nohandler += (unsigned long)atomic_long_read(&dev->rx_nohandler);
+#ifdef CONFIG_LLDP_RX_DROP_COUNTER
+	storage->rx_lldp_dropped += atomic_long_read(&dev->rx_lldp_dropped);
+#endif
 	return storage;
 }
 EXPORT_SYMBOL(dev_get_stats);
--- a/net/core/dev_ioctl.c
+++ b/net/core/dev_ioctl.c
@@ -301,7 +301,7 @@ static int dev_ifsioc(struct net *net, s
 	 */
 	default:
 		if ((cmd >= SIOCDEVPRIVATE &&
-		    cmd <= SIOCDEVPRIVATE + 15) ||
+		    cmd <= SIOCDEVPRIVATE + SIOCDEVPRIVATE_LEN) || // UBNT - extended SIOCDEVPRIVATE to 0x8aff for ubnt_ioctl.h
 		    cmd == SIOCBONDENSLAVE ||
 		    cmd == SIOCBONDRELEASE ||
 		    cmd == SIOCBONDSETHWADDR ||
@@ -507,7 +507,7 @@ int dev_ioctl(struct net *net, unsigned
 		if (cmd == SIOCWANDEV ||
 		    cmd == SIOCGHWTSTAMP ||
 		    (cmd >= SIOCDEVPRIVATE &&
-		     cmd <= SIOCDEVPRIVATE + 15)) {
+		     cmd <= SIOCDEVPRIVATE + SIOCDEVPRIVATE_LEN)) { // UBNT - extended SIOCDEVPRIVATE to 0x8aff for ubnt_ioctl.h
 			dev_load(net, ifr->ifr_name);
 			rtnl_lock();
 			ret = dev_ifsioc(net, ifr, cmd);
--- a/net/core/net-sysfs.c
+++ b/net/core/net-sysfs.c
@@ -608,6 +608,9 @@ NETSTAT_ENTRY(tx_window_errors);
 NETSTAT_ENTRY(rx_compressed);
 NETSTAT_ENTRY(tx_compressed);
 NETSTAT_ENTRY(rx_nohandler);
+#ifdef CONFIG_LLDP_RX_DROP_COUNTER
+NETSTAT_ENTRY(rx_lldp_dropped);
+#endif
 
 static struct attribute *netstat_attrs[] __ro_after_init = {
 	&dev_attr_rx_packets.attr,
@@ -634,6 +637,9 @@ static struct attribute *netstat_attrs[]
 	&dev_attr_rx_compressed.attr,
 	&dev_attr_tx_compressed.attr,
 	&dev_attr_rx_nohandler.attr,
+#ifdef CONFIG_LLDP_RX_DROP_COUNTER
+	&dev_attr_rx_lldp_dropped.attr,
+#endif
 	NULL
 };
 
--- a/net/core/skbuff.c
+++ b/net/core/skbuff.c
@@ -63,6 +63,7 @@
 #include <linux/errqueue.h>
 #include <linux/prefetch.h>
 #include <linux/if_vlan.h>
+#include <linux/if.h>
 
 #include <net/protocol.h>
 #include <net/dst.h>
@@ -512,6 +513,22 @@ skb_fail:
 }
 EXPORT_SYMBOL(__napi_alloc_skb);
 
+struct sk_buff *__netdev_alloc_skb_ip_align(struct net_device *dev,
+		unsigned int length, gfp_t gfp)
+{
+	struct sk_buff *skb = __netdev_alloc_skb(dev, length + NET_IP_ALIGN, gfp);
+
+#ifdef CONFIG_ETHERNET_PACKET_MANGLE
+	if (dev && (dev->priv_flags & IFF_NO_IP_ALIGN))
+		return skb;
+#endif
+
+	if (NET_IP_ALIGN && skb)
+		skb_reserve(skb, NET_IP_ALIGN);
+	return skb;
+}
+EXPORT_SYMBOL(__netdev_alloc_skb_ip_align);
+
 void skb_add_rx_frag(struct sk_buff *skb, int i, struct page *page, int off,
 		     int size, unsigned int truesize)
 {
--- a/net/ethernet/eth.c
+++ b/net/ethernet/eth.c
@@ -160,6 +160,12 @@ __be16 eth_type_trans(struct sk_buff *sk
 	const struct ethhdr *eth;
 
 	skb->dev = dev;
+
+#ifdef CONFIG_ETHERNET_PACKET_MANGLE
+	if (dev->eth_mangle_rx)
+		dev->eth_mangle_rx(dev, skb);
+#endif
+
 	skb_reset_mac_header(skb);
 
 	eth = (struct ethhdr *)skb->data;
--- a/net/ipv4/udp_tunnel.c
+++ b/net/ipv4/udp_tunnel.c
@@ -15,11 +15,20 @@ int udp_sock_create4(struct net *net, st
 	int err;
 	struct socket *sock = NULL;
 	struct sockaddr_in udp_addr;
+	int one = 1;
 
 	err = sock_create_kern(net, AF_INET, SOCK_DGRAM, 0, &sock);
 	if (err < 0)
 		goto error;
 
+	if (cfg->reuse_addr && kernel_setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, (char *)&one, sizeof(one))) {
+		goto error;
+	}
+
+	if (cfg->reuse_port && kernel_setsockopt(sock, SOL_SOCKET, SO_REUSEPORT, (char *)&one, sizeof(one))) {
+		goto error;
+	}
+
 	udp_addr.sin_family = AF_INET;
 	udp_addr.sin_addr = cfg->local_ip;
 	udp_addr.sin_port = cfg->local_udp_port;
--- a/net/ipv6/ip6_udp_tunnel.c
+++ b/net/ipv6/ip6_udp_tunnel.c
@@ -18,11 +18,20 @@ int udp_sock_create6(struct net *net, st
 	struct sockaddr_in6 udp6_addr = {};
 	int err;
 	struct socket *sock = NULL;
+	int one = 1;
 
 	err = sock_create_kern(net, AF_INET6, SOCK_DGRAM, 0, &sock);
 	if (err < 0)
 		goto error;
 
+	if (cfg->reuse_addr && kernel_setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, (char *)&one, sizeof(one))) {
+		goto error;
+	}
+
+	if (cfg->reuse_port && kernel_setsockopt(sock, SOL_SOCKET, SO_REUSEPORT, (char *)&one, sizeof(one))) {
+		goto error;
+	}
+
 	if (cfg->ipv6_v6only) {
 		int val = 1;
 
--- a/net/netfilter/Kconfig
+++ b/net/netfilter/Kconfig
@@ -162,6 +162,13 @@ config NF_CONNTRACK_LABELS
 	  to connection tracking entries.  It can be used with xtables connlabel
 	  match and the nftables ct expression.
 
+config NF_CONNTRACK_DPI
+	bool 'Connection tracking DPI'
+	depends on NETFILTER_ADVANCED
+	help
+	  This option enables support for storing DPI info in connection tracking
+	  entries.
+
 config NF_CT_PROTO_DCCP
 	bool 'DCCP protocol connection tracking support'
 	depends on NETFILTER_ADVANCED
@@ -1248,6 +1255,12 @@ config NETFILTER_XT_MATCH_DSCP
 
 	  To compile it as a module, choose M here.  If unsure, say N.
 
+config NETFILTER_XT_MATCH_DYN_RANDOM
+	tristate  '"dyn_random" match support'
+	depends on NETFILTER_ADVANCED
+	help
+	  This option adds a `dyn_random' match.
+
 config NETFILTER_XT_MATCH_ECN
 	tristate '"ecn" match support'
 	depends on NETFILTER_ADVANCED
--- a/net/netfilter/Makefile
+++ b/net/netfilter/Makefile
@@ -13,6 +13,7 @@ nf_conntrack-$(CONFIG_NF_CONNTRACK_EVENT
 nf_conntrack-$(CONFIG_NF_CONNTRACK_LABELS) += nf_conntrack_labels.o
 nf_conntrack-$(CONFIG_NF_CT_PROTO_DCCP) += nf_conntrack_proto_dccp.o
 nf_conntrack-$(CONFIG_NF_CT_PROTO_SCTP) += nf_conntrack_proto_sctp.o
+nf_conntrack-$(CONFIG_NF_CONNTRACK_DPI) += nf_conntrack_dpi.o
 
 obj-$(CONFIG_NETFILTER) = netfilter.o
 
@@ -170,6 +171,7 @@ obj-$(CONFIG_NETFILTER_XT_MATCH_CPU) +=
 obj-$(CONFIG_NETFILTER_XT_MATCH_DCCP) += xt_dccp.o
 obj-$(CONFIG_NETFILTER_XT_MATCH_DEVGROUP) += xt_devgroup.o
 obj-$(CONFIG_NETFILTER_XT_MATCH_DSCP) += xt_dscp.o
+obj-$(CONFIG_NETFILTER_XT_MATCH_DYN_RANDOM) += xt_dyn_random.o
 obj-$(CONFIG_NETFILTER_XT_MATCH_ECN) += xt_ecn.o
 obj-$(CONFIG_NETFILTER_XT_MATCH_ESP) += xt_esp.o
 obj-$(CONFIG_NETFILTER_XT_MATCH_HASHLIMIT) += xt_hashlimit.o
--- a/net/netfilter/nf_conntrack_core.c
+++ b/net/netfilter/nf_conntrack_core.c
@@ -51,6 +51,7 @@
 #include <net/netfilter/nf_conntrack_timeout.h>
 #include <net/netfilter/nf_conntrack_labels.h>
 #include <net/netfilter/nf_conntrack_synproxy.h>
+#include <net/netfilter/nf_conntrack_dpi.h>
 #include <net/netfilter/nf_nat.h>
 #include <net/netfilter/nf_nat_core.h>
 #include <net/netfilter/nf_nat_helper.h>
@@ -1424,6 +1425,7 @@ init_conntrack(struct net *net, struct n
 	nf_ct_acct_ext_add(ct, GFP_ATOMIC);
 	nf_ct_tstamp_ext_add(ct, GFP_ATOMIC);
 	nf_ct_labels_ext_add(ct);
+	nf_ct_dpi_ext_add(ct);
 
 	ecache = tmpl ? nf_ct_ecache_find(tmpl) : NULL;
 	nf_ct_ecache_ext_add(ct, ecache ? ecache->ctmask : 0,
@@ -2084,6 +2086,7 @@ void nf_conntrack_cleanup_end(void)
 	nf_conntrack_tstamp_fini();
 	nf_conntrack_acct_fini();
 	nf_conntrack_expect_fini();
+	nf_conntrack_dpi_fini();
 
 	kmem_cache_destroy(nf_conntrack_cachep);
 }
@@ -2342,6 +2345,10 @@ int nf_conntrack_init_start(void)
 	if (ret < 0)
 		goto err_labels;
 
+	ret = nf_conntrack_dpi_init();
+	if (ret < 0)
+		goto err_dpi;
+
 	ret = nf_conntrack_seqadj_init();
 	if (ret < 0)
 		goto err_seqadj;
@@ -2358,6 +2365,8 @@ int nf_conntrack_init_start(void)
 err_proto:
 	nf_conntrack_seqadj_fini();
 err_seqadj:
+	nf_conntrack_dpi_fini();
+err_dpi:
 	nf_conntrack_labels_fini();
 err_labels:
 	nf_conntrack_helper_fini();
--- a/net/netfilter/nf_conntrack_netlink.c
+++ b/net/netfilter/nf_conntrack_netlink.c
@@ -46,6 +46,7 @@
 #include <net/netfilter/nf_conntrack_timestamp.h>
 #include <net/netfilter/nf_conntrack_labels.h>
 #include <net/netfilter/nf_conntrack_synproxy.h>
+#include <net/netfilter/nf_conntrack_dpi.h>
 #ifdef CONFIG_NF_NAT_NEEDED
 #include <net/netfilter/nf_nat_core.h>
 #include <net/netfilter/nf_nat_l4proto.h>
@@ -393,6 +394,55 @@ ctnetlink_dump_labels(struct sk_buff *sk
 #define ctnetlink_label_size(a)	(0)
 #endif
 
+#ifdef CONFIG_NF_CONNTRACK_DPI
+static inline int
+ctnetlink_dump_dpi(struct sk_buff *skb, const struct nf_conn *ct)
+{
+	struct nlattr *nest_count;
+	struct nf_conn_dpi *dpi = nfct_dpi(ct);
+	if (!dpi)
+		return 0;
+
+	nest_count = nla_nest_start(skb, CTA_DPI | NLA_F_NESTED);
+	if (!nest_count)
+		goto nla_put_failure;
+
+	if (nla_put_u8(skb, CTA_DPI_PROTO, dpi->ubnt_proto))
+		goto nla_put_failure;
+	if (dpi->dns) {
+		if (nla_put_u8(skb, CTA_DPI_DNS_LEN, dpi->dns_len))
+			goto nla_put_failure;
+		if (nla_put(skb, CTA_DPI_DNS, dpi->dns_len, dpi->dns))
+			goto nla_put_failure;
+		kfree(dpi->dns);
+		dpi->dns = NULL;
+	}
+	if (dpi->domain_name) {
+		if (nla_put_u8(skb, CTA_DPI_DOMAIN_NAME_LEN, dpi->domain_name_len))
+			goto nla_put_failure;
+		if (nla_put(skb, CTA_DPI_DOMAIN_NAME, dpi->domain_name_len, dpi->domain_name))
+			goto nla_put_failure;
+		kfree(dpi->domain_name);
+		dpi->domain_name = NULL;
+	}
+	if (dpi->cat || dpi->app) {
+		if (nla_put_u8(skb, CTA_DPI_CAT, dpi->cat))
+			goto nla_put_failure;
+		if (nla_put_u16(skb, CTA_DPI_APP, dpi->app))
+			goto nla_put_failure;
+	}
+
+	nla_nest_end(skb, nest_count);
+
+	return 0;
+
+nla_put_failure:
+	return -1;
+}
+#else
+#define ctnetlink_dump_dpi(a, b) (0)
+#endif
+
 #define master_tuple(ct) &(ct->master->tuplehash[IP_CT_DIR_ORIGINAL].tuple)
 
 static int ctnetlink_dump_master(struct sk_buff *skb, const struct nf_conn *ct)
@@ -564,6 +614,7 @@ ctnetlink_fill_info(struct sk_buff *skb,
 	    ctnetlink_dump_mark(skb, ct) < 0 ||
 	    ctnetlink_dump_secctx(skb, ct) < 0 ||
 	    ctnetlink_dump_labels(skb, ct) < 0 ||
+	    ctnetlink_dump_dpi(skb, ct) < 0 ||
 	    ctnetlink_dump_id(skb, ct) < 0 ||
 	    ctnetlink_dump_use(skb, ct) < 0 ||
 	    ctnetlink_dump_master(skb, ct) < 0 ||
--- a/net/sched/cls_fw.c
+++ b/net/sched/cls_fw.c
@@ -48,6 +48,9 @@ struct fw_filter {
 	struct tcf_exts		exts;
 	struct tcf_proto	*tp;
 	struct rcu_work		rwork;
+	u32			mask;
+	u8			shift;
+	u8			flags;
 };
 
 static u32 fw_hash(u32 handle)
@@ -64,14 +67,43 @@ static int fw_classify(struct sk_buff *s
 	struct fw_filter *f;
 	int r;
 	u32 id = skb->mark;
+	u32 ubnt_id = skb->ubnt_mark;
 
 	if (head != NULL) {
+		ubnt_id &= head->mask;
+
+		for (f = rcu_dereference_bh(head->ht[fw_hash(ubnt_id)]); f;
+		     f = rcu_dereference_bh(f->next)) {
+			if (f->flags & TCA_FW_FLAG_UBNT_MARK && f->id == ubnt_id) {
+
+				*res = f->res;
+				if (f->mask) {
+					// force overwrite res->class = 0 to make pseudo device and use fw mask rule
+					res->class = 0;
+					res->classid += (skb->ubnt_mark & f->mask) >> f->shift;
+				}
+#ifdef CONFIG_NET_CLS_IND
+				if (!tcf_match_indev(skb, f->ifindex))
+					continue;
+#endif /* CONFIG_NET_CLS_IND */
+				r = tcf_exts_exec(skb, &f->exts, res);
+				if (r < 0)
+					continue;
+				return r;
+			}
+		}
+
 		id &= head->mask;
 
 		for (f = rcu_dereference_bh(head->ht[fw_hash(id)]); f;
 		     f = rcu_dereference_bh(f->next)) {
-			if (f->id == id) {
+			if (!(f->flags & TCA_FW_FLAG_UBNT_MARK) && f->id == id) {
 				*res = f->res;
+				if (f->mask) {
+					// force overwrite res->class = 0 to make pseudo device and use fw mask rule
+					res->class = 0;
+					res->classid += (skb->mark & f->mask) >> f->shift;
+				}
 #ifdef CONFIG_NET_CLS_IND
 				if (!tcf_match_indev(skb, f->ifindex))
 					continue;
@@ -205,6 +237,9 @@ static const struct nla_policy fw_policy
 	[TCA_FW_CLASSID]	= { .type = NLA_U32 },
 	[TCA_FW_INDEV]		= { .type = NLA_STRING, .len = IFNAMSIZ },
 	[TCA_FW_MASK]		= { .type = NLA_U32 },
+	[TCA_FW_FMASK]		= { .type = NLA_U32 },
+	[TCA_FW_FSHIFT]		= { .type = NLA_U8 },
+	[TCA_FW_FLAGS]		= { .type = NLA_U8 },
 };
 
 static int fw_set_parms(struct net *net, struct tcf_proto *tp,
@@ -244,6 +279,17 @@ static int fw_set_parms(struct net *net,
 	} else if (head->mask != 0xFFFFFFFF)
 		return err;
 
+	if (tb[TCA_FW_FMASK]) {
+		f->mask = nla_get_u32(tb[TCA_FW_FMASK]);
+	}
+
+	if (tb[TCA_FW_FSHIFT]) {
+		f->shift = nla_get_u8(tb[TCA_FW_FSHIFT]);
+	}
+
+	if (tb[TCA_FW_FLAGS]) {
+		f->flags = nla_get_u8(tb[TCA_FW_FLAGS]);
+	}
 	return 0;
 }
 
@@ -417,6 +463,21 @@ static int fw_dump(struct net *net, stru
 	    nla_put_u32(skb, TCA_FW_MASK, head->mask))
 		goto nla_put_failure;
 
+	if (f->mask != 0) {
+		if (nla_put_u32(skb, TCA_FW_FMASK, f->mask))
+			goto nla_put_failure;
+	}
+
+	if (f->shift != 0) {
+		if (nla_put_u8(skb, TCA_FW_FSHIFT, f->shift))
+			goto nla_put_failure;
+	}
+
+	if (f->flags != 0) {
+		if (nla_put_u8(skb, TCA_FW_FLAGS, f->flags))
+			goto nla_put_failure;
+	}
+
 	if (tcf_exts_dump(skb, &f->exts) < 0)
 		goto nla_put_failure;
 
--- a/net/socket.c
+++ b/net/socket.c
@@ -1061,7 +1061,7 @@ static long sock_ioctl(struct file *file
 	sock = file->private_data;
 	sk = sock->sk;
 	net = sock_net(sk);
-	if (unlikely(cmd >= SIOCDEVPRIVATE && cmd <= (SIOCDEVPRIVATE + 15))) {
+	if (cmd >= SIOCDEVPRIVATE && cmd <= (SIOCDEVPRIVATE + SIOCDEVPRIVATE_LEN)) { // UBNT - extended SIOCDEVPRIVATE to 0x8aff for ubnt_ioctl.h
 		struct ifreq ifr;
 		bool need_copyout;
 		if (copy_from_user(&ifr, argp, sizeof(struct ifreq)))
@@ -3269,7 +3269,7 @@ static int compat_sock_ioctl_trans(struc
 	struct sock *sk = sock->sk;
 	struct net *net = sock_net(sk);
 
-	if (cmd >= SIOCDEVPRIVATE && cmd <= (SIOCDEVPRIVATE + 15))
+	if (cmd >= SIOCDEVPRIVATE && cmd <= (SIOCDEVPRIVATE + SIOCDEVPRIVATE_LEN)) // UBNT - extended SIOCDEVPRIVATE to 0x8aff for ubnt_ioctl.h
 		return compat_ifr_data_ioctl(net, cmd, argp);
 
 	switch (cmd) {
--- a/net/wireless/Kconfig
+++ b/net/wireless/Kconfig
@@ -1,5 +1,5 @@
 config WIRELESS_EXT
-	bool
+	bool "WIRELESS EXT"
 
 config WEXT_CORE
 	def_bool y
@@ -11,10 +11,10 @@ config WEXT_PROC
 	depends on WEXT_CORE
 
 config WEXT_SPY
-	bool
+	bool "WEXT_SPY"
 
 config WEXT_PRIV
-	bool
+	bool "WEXT_PRIV"
 
 config CFG80211
 	tristate "cfg80211 - wireless configuration API"
--- a/net/wireless/nl80211.c
+++ b/net/wireless/nl80211.c
@@ -469,6 +469,7 @@ static const struct nla_policy nl80211_p
 	[NL80211_ATTR_TXQ_QUANTUM] = { .type = NLA_U32 },
 	[NL80211_ATTR_HE_CAPABILITY] = { .type = NLA_BINARY,
 					 .len = NL80211_HE_MAX_CAPABILITY_LEN },
+	[NL80211_ATTR_STA_ROAMED] = { .type = NLA_FLAG },
 };
 
 /* policy for the key attributes */
@@ -5648,6 +5649,10 @@ static int nl80211_del_station(struct sk
 		params.reason_code = WLAN_REASON_PREV_AUTH_NOT_VALID;
 	}
 
+	if (info->attrs[NL80211_ATTR_STA_ROAMED]) {
+		params.sta_roamed = 1;
+	}
+
 	return rdev_del_station(rdev, dev, &params);
 }
 
--- a/net/wireless/wext-core.c
+++ b/net/wireless/wext-core.c
@@ -922,6 +922,7 @@ static int wireless_process_ioctl(struct
 {
 	struct net_device *dev;
 	iw_handler	handler;
+	struct ifreq *ifr = (struct ifreq *) iwr;
 
 	/* Permissions are already checked in dev_ioctl() before calling us.
 	 * The copy_to/from_user() of ifr is also dealt with in there */
@@ -956,6 +957,10 @@ static int wireless_process_ioctl(struct
 		else if (private)
 			return private(dev, iwr, cmd, info, handler);
 	}
+
+	if (dev->netdev_ops->ndo_do_ioctl)
+		return dev->netdev_ops->ndo_do_ioctl(dev, ifr, cmd);
+
 	return -EOPNOTSUPP;
 }
 
